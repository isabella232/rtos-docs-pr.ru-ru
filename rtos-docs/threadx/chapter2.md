---
title: Глава 2. Установка и использование ThreadX для ОСРВ Azure
description: В этой главе описаны различные проблемы, связанные с установкой, настройкой и использованием высокопроизводительного ядра ThreadX для ОСРВ Azure.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: a88dc75c3b01e8054f72b3e1475791f064eac0ded02b22ccd18dd46da8c7200a
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116785045"
---
# <a name="chapter-2---installation-and-use-of-azure-rtos-threadx"></a>Глава 2. Установка и использование ThreadX для ОСРВ Azure

В этой главе описаны различные проблемы, связанные с установкой, настройкой и использованием высокопроизводительного ядра ThreadX для ОСРВ Azure.

## <a name="host-considerations"></a>Рекомендации по размещению

Встраиваемое программное обеспечение обычно разрабатывается на главных компьютерах Windows или Linux (UNIX). После компиляции, связывания и размещения на главном компьютере приложение скачивается на целевое оборудование для выполнения.

Как правило, скачивание на целевой объект запускается из отладчика средства разработки. Когда скачивание завершится, отладчик берет на себя управление выполнением на целевом объекте (запуск, остановка, точка останова и т. д.), а также доступом к памяти и регистрам процессора.

Большинство отладчиков инструментов разработки обменивается данными с целевым оборудованием через подключения отладки на микросхеме (OCD), например JTAG (IEEE 1149.1) и BDM (режим фоновой отладки). Кроме того, отладчики взаимодействуют с целевым оборудованием через подключения ICE (внутрисхемная эмуляция). Подключения OCD и ICE обеспечивают надежную передачу данных с минимальным влиянием на резидентное ПО на целевом объекте.

Как и в случае с ресурсами, используемыми на главном компьютере, исходный код для ThreadX предоставляется в формате ASCII и требует около 1 МБ свободного пространства на жестком диске главного компьютера.

## <a name="target-considerations"></a>Замечания, касающиеся целевого оборудования

ThreadX требует от 2 до 20 КБ доступной только для чтения памяти в целевой системе. Кроме того, в целевой системе нужно 1–2 КБ оперативной памяти (ОЗУ) для системного стека ThreadX и других глобальных структур данных.

Для использования функций, связанных с таймером, таких как время ожидания при вызовах службы, временной срез и таймеры приложений, базовое целевое оборудование должно предоставлять источник периодических прерываний. Если процессор поддерживает такую возможность, ThreadX использует ее. В противном случае, когда у целевого процессора нет возможности создавать периодические прерывания, их должно обеспечивать оборудование пользователя. Установка и настройка прерываний по таймеру обычно выполняется в файле сборки ***tx_initialize_low_level*** из дистрибутива ThreadX.

> [!NOTE]
> *ThreadX будет нормально работать и без источника периодических прерываний, но вы не сможете использовать службы, связанные с таймером.*

## <a name="product-distribution"></a>Распространение продукта

ThreadX для ОСРВ Azure можно получить из нашего общедоступного репозитория исходного кода, расположенного по адресу <https://github.com/azure-rtos/threadx/>.

Ниже приведен список основных файлов в этом репозитории.

| Имя файла | Описание |
|------------------- | ----------- |
| **tx_api.h**                      | Файл заголовка на C включает все системные равенства, структуры данных и прототипы служб.                                                             |
| **tx_port.h**                     | Файл заголовка на C, содержащий все определения и структуры данных для средств разработки и целевой системы.                                                 |
| **demo_threadx.c**                | Файл на C, содержащий небольшое демонстрационное приложение.                                                                                                       |
| **tx.a (или tx.lib)**              | Двоичная версия библиотеки ThreadX для C, распространяемая со *стандартным* пакетом.                                                          |
|                                   |                                                                                                                                                   |

>[!NOTE]
>*Все имена файлов содержат только буквы нижнего регистра. Это соглашение об именовании упрощает преобразование команд для использования на платформах разработки в среде Linux (UNIX).*

## <a name="threadx-installation"></a>Установка ThreadX

ThreadX устанавливается путем клонирования репозитория GitHub на локальный компьютер. Ниже приведен типичный синтаксис для создания клона репозитория ThreadX на локальном компьютере:

```c
    git clone https://github.com/azure-rtos/threadx
```

Также вы можете скачать копию репозитория с помощью соответствующей кнопки на главной странице GitHub.

Кроме того, вы можете найти инструкции по созданию библиотеки ThreadX на главной странице онлайн-репозитория.

> [!NOTE]
> * Программному обеспечению требуется доступ к файлу библиотеки ThreadX (обычно это **tx.a** или **tx.lib**) и к включаемым файлам на C **_tx_api.h_* _ и _*_tx_port.h_*_. Для этого задайте путь к файлам в средствах разработки или скопируйте файлы в область разработки приложения.

## <a name="using-threadx"></a>Использование ThreadX

Чтобы использовать ThreadX, код приложения должен включить файл ***tx_api.h** _ во время компиляции и выполнить связывание с библиотекой ThreadX времени выполнения (_*_tx.a_*_ или _*_tx.lib_**).

Для создания приложения ThreadX необходимо выполнить четыре действия.

1. Включите файл ***gx_api.h*** во все файлы приложения, которые используют службы или структуры данных ThreadX.

1. Создайте стандартную функцию ***main** _ на C. Эта функция должна в конце выполнения вызывать _ *_tx_kernel_enter_** для запуска ядра ThreadX. Перед входом в ядро допускается выполнить инициализацию конкретного приложения, которая не имеет отношения к ThreadX.

      > [!IMPORTANT]
      > * Функция ***tx_kernel_enter** _ для входа в ThreadX не выполняет возврат. Поэтому не размещайте после нее никакие вызовы функций и процедуры вычислений.

1. Создайте функцию ***tx_application_define***. Именно здесь создаются исходные системные ресурсы. К таким системным ресурсам могут относиться потоки, очереди, пулы памяти, группы флагов событий, мьютексы и семафоры.

1. Скомпилируйте исходный код приложения и свяжите его с библиотекой ThreadX времени выполнения (***tx.lib***). Полученный образ можно скачать в целевую систему и запустить.

## <a name="small-example-system"></a>Пример небольшой системы

В этом примере небольшой системы, который представлен на рис. 1, создается один поток с приоритетом 3. Этот поток выполняется и увеличивает значение счетчика, а затем переходит в спящий режим и остается в нем в течение такта длительностью в один час.
Этот процесс повторяется неограниченно долго.

```c
#include "tx_api.h"
unsigned long my_thread_counter = 0;
TX_THREAD my_thread;
main( )
{
    /* Enter the ThreadX kernel. */
    tx_kernel_enter( );
}
void tx_application_define(void *first_unused_memory)
{
    /* Create my_thread! */
    tx_thread_create(&my_thread, "My Thread",
    my_thread_entry, 0x1234, first_unused_memory, 1024,
    3, 3, TX_NO_TIME_SLICE, TX_AUTO_START);
}
void my_thread_entry(ULONG thread_input)
{
    /* Enter into a forever loop. */
    while(1)
    {
        /* Increment thread counter. */
        my_thread_counter++;
        /* Sleep for 1 tick. */
        tx_thread_sleep(1);
    }
}
```

**Рис. 1. Шаблон для разработки приложения**

Это очень простой пример, но он предоставляет хороший шаблон для разработки реальных приложений.

## <a name="troubleshooting"></a>Устранение неполадок

Версии ThreadX для любой системы включают демонстрационное приложение. Мы рекомендуем всегда начинать с запуска этой демонстрационной системы, как на реальном оборудовании, так и в имитированной среде.

Если демонстрационная система не работает должным образом, воспользуйтесь приведенными ниже советами по устранению неполадок.

1. Определите, на каком этапе демонстрации возникает ошибка.
1. Увеличьте размеры стека (это с большей вероятностью принесет пользу в фактическом коде приложения, чем в демонстрации).
1. Перестройте библиотеку ThreadX, определив параметр TX_ENABLE_STACK_CHECKING. Это позволит активировать встроенную проверку стека ThreadX.
1. Временно отключите все недавно внесенные изменения и проверьте, сохраняется ли проблема и изменяется ли ее проявление. Такая информация будет полезной специалистам поддержки.

Выполните инструкции, приведенные в разделе [Центр поддержки клиентов](about-this-guide.md#customer-support-center), чтобы отправить сведения, собранные на этапах устранения неполадок.

## <a name="configuration-options"></a>Параметры конфигурации

При сборке библиотеки ThreadX и приложения, использующего ThreadX, можно применить несколько параметров конфигурации. Указанные ниже параметры можно определить в исходном коде приложения, в командной строке или во включаемом файле ***tx_user. h***.

> [!IMPORTANT]
> * Параметры, определенные в файле ***tx_user.h** _, применяются только в случае сборки библиотеки ThreadX с определенным параметром _ *TX_INCLUDE_USER_DEFINE_FILE**.*

### <a name="smallest-configuration"></a>Наименьшая конфигурация

Чтобы получить код наименьшего размера, попробуйте применить следующие параметры конфигурации ThreadX (без всех остальных параметров):

```c
TX_DISABLE_ERROR_CHECKING
TX_DISABLE_PREEMPTION_THRESHOLD
TX_DISABLE_NOTIFY_CALLBACKS
TX_DISABLE_REDUNDANT_CLEARING
TX_DISABLE_STACK_FILLING
TX_NOT_INTERRUPTABLE
TX_TIMER_PROCESS_IN_ISR
```

### <a name="fastest-configuration"></a>Самая быстрая конфигурация

Чтобы добиться наиболее быстрого выполнения, используйте те же параметры, что и для минимальной конфигурации, но с возможным добавлением следующих параметров:

```c
TX_REACTIVATE_INLINE
TX_INLINE_THREAD_RESUME_SUSPEND
```

Изучите также раздел [Подробное описание параметров конфигурации](#detailed-configuration-options).

### <a name="global-time-source"></a>Глобальный источник времени

Для других продуктов ОСРВ Microsoft Azure (FileX, NetX, GUIX,USBX и т. д.) ThreadX вычисляет количество тактов таймера ThreadX, которое соответствует одной секунде. Остальные службы определяют свои требования к времени на основе этой константы. По умолчанию используется значение 100, то есть одно прерывание каждые 10 мс. Пользователь может переопределить это значение, указав нужное значение параметра TX_TIMER_TICKS_PER_SECOND в файле ***tx_port.h***, в интегрированной среде разработки или в командной строке.

### <a name="detailed-configuration-options"></a>Подробное описание параметров конфигурации

**TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для пулов байтов. По умолчанию этот параметр не определен.

**TX_BYTE_POOL_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для пулов байтов. По умолчанию этот параметр не определен.

**TX_DISABLE_ERROR_CHECKING**

Пропуск базовой проверки на предмет ошибок при вызове службы. Если этот параметр определен в исходном коде приложения, отключаются все базовые проверки на предмет ошибок в параметрах. Это может повысить производительность на 30 % и уменьшить размер образа.

> [!NOTE]
> *Проверку на предмет ошибок можно отключать, только если приложение полностью гарантирует допустимые значения всех входных параметров в любых обстоятельствах, в том числе для параметров, полученных из внешних источников. Если проверку на предмет ошибок отключить и в API будут переданы недопустимые входные данные, поведение системы будет неопределенным и может привести к повреждению памяти или аварийному завершению.*

> [!NOTE]
> *Возвращаемые из API ThreadX значения, на которые не влияет отключение проверки на предмет ошибок, выделены полужирным шрифтом в разделе Return Values (Возвращаемые значения) в описании каждого API в главе 4. Возвращаемые значения, не выделенные полужирным шрифтом, всегда будут пустыми, если проверка на предмет ошибок отключена (при заданном параметре TX_DISABLE_ERROR_CHECKING).*

**TX_DISABLE_NOTIFY_CALLBACKS**

Если этот параметр определен, обратные вызовы оповещения для разных объектов ThreadX отключаются. Использование этого параметра немного сокращает размер кода и повышает производительность. По умолчанию этот параметр не определен.

**TX_DISABLE_PREEMPTION_THRESHOLD**

Если этот параметр определен, отключается функция проверки порога вытеснения, что немного уменьшает размер кода и повышает производительность. Разумеется, при этом становится недоступной проверка порога вытеснения. По умолчанию этот параметр не определен.

**TX_DISABLE_REDUNDANT_CLEARING**

Если этот параметр определен, удаляется логика инициализации с обнулением для глобальных структур данных C среды ThreadX. Этот параметр следует использовать, только если код инициализации компилятора устанавливает значение 0 для всех неинициализированных глобальных данных C. При использовании этого параметра немного сокращается размер кода и повышается производительность на этапе инициализации. По умолчанию этот параметр не определен.

**TX_DISABLE_STACK_FILLING**

Если этот параметр определен, отключается присвоение значения 0xEF каждому байту стека каждого потока при его создании. По умолчанию этот параметр не определен.

**TX_ENABLE_EVENT_TRACE**

Если этот параметр определен, ThreadX включает код сбора событий для создания буфера трассировки ThreadX.

**TX_ENABLE_STACK_CHECKING**

Если этот параметр определен, включается проверка стека времени выполнения ThreadX, в которую входит анализ объема использованного стека и изучение "ограждений" шаблона данных до и после области стека. При обнаружении ошибки стека вызывается зарегистрированный обработчик ошибок стека приложений. При использовании этого параметра немного увеличиваются затраты времени и размер кода. Дополнительные сведения см. в описании функции API ***tx_thread_stack_error_notify***. По умолчанию этот параметр не определен.

**TX_EVENT_FLAGS_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для групп флагов событий. По умолчанию этот параметр не определен.

**TX_INLINE_THREAD_RESUME_SUSPEND**

Если этот параметр определен, ThreadX улучшает вызовы API ***tx_thread_resume** _ и _ *_tx_thread_suspend_** путем применения встроенного кода. Это увеличивает размер кода, но повышает производительность для этих двух вызовов API.

**TX_MAX_PRIORITIES**

Определяет уровни приоритета для ThreadX. Допускаются значения в диапазоне от 32 до 1024 (включительно), но *строго* кратные 32. При увеличении числа поддерживаемых уровней приоритета увеличивается объем использования ОЗУ на 128 байт для каждой группы из 32 уровней приоритета. Но это оказывает крайне несущественное влияние на производительность. По умолчанию используются 32 уровня приоритета.

**TX_MINIMUM_STACK**

Определяет минимальный размер стека (в байтах). Он используется для проверки на предмет ошибок при создании потоков. Значение по умолчанию зависит от конкретной версии и определяется в файле ***tx_port.h***.

**TX_MISRA_ENABLE**

Если этот параметр определен, ThreadX использует соглашения, совместимые с MISRA C. Дополнительные сведения см. в файле ***ThreadX_MISRA_Compliance.pdf***.

**TX_MUTEX_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для мьютексов. По умолчанию этот параметр не определен.

**TX_NO_TIMER**

Если этот параметр определен, полностью отключается логика таймера ThreadX. Это полезно в тех случаях, когда функции таймера ThreadX не используются (режим сна для потока, время ожидания ответов API, временной срез или таймеры приложений). Если определен параметр **TX_NO_TIMER**, необходимо определить и параметр **TX_TIMER_PROCESS_IN_ISR**.

**TX_NOT_INTERRUPTABLE**

Если этот параметр определен, ThreadX не пытается сокращать время блокировки прерываний. Это приводит к ускорению выполнения, но немного увеличивает время блокировки прерываний.

**TX_QUEUE_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для очередей. По умолчанию этот параметр не определен.

**TX_REACTIVATE_INLINE**

Если этот параметр определен, повторная активация встроенных таймеров ThreadX выполняется во встроенном коде, без вызова функции. Это повышает производительность, но немного увеличивает размер кода. По умолчанию этот параметр не определен.

**TX_SEMAPHORE_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для семафоров. По умолчанию этот параметр не определен.

**TX_THREAD_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для потоков. По умолчанию этот параметр не определен.

**TX_TIMER_ENABLE_PERFORMANCE_INFO**

Если этот параметр определен, включается сбор сведений о производительности для таймеров. По умолчанию этот параметр не определен.

**TX_TIMER_PROCESS_IN_ISR**

Если этот параметр определен, из ThreadX удаляется внутренний поток системного таймера. Это приводит к повышению производительности событий таймера и уменьшению объема требований к ОЗУ, так как стек таймера и блок управления становятся не нужны. Но при использовании этого параметра вся обработка периодов для таймера переносится на уровень таймера ISR. По умолчанию этот параметр не определен.

> [!NOTE]
> *Службы, разрешенные в таймерах, могут быть запрещены в ISR, а значит, они не смогут работать при использовании этого параметра.*

**TX_TIMER_THREAD_PRIORITY**

Определяет приоритет для внутреннего потока системного таймера ThreadX. По умолчанию используется приоритет 0, то есть максимальный возможный приоритет в ThreadX. Значение по умолчанию определяется в файле ***tx_port.h***.

**TX_TIMER_THREAD_STACK_SIZE**

Определяет размер стека (в байтах) для внутреннего потока системного таймера ThreadX. Этот поток обрабатывает все запросы спящего режима и периоды ожидания для вызовов служб. Кроме того, из этого контекста вызываются все подпрограммы обратного вызова таймера приложений. Значение по умолчанию зависит от конкретной версии и определяется в файле ***tx_port.h***.

## <a name="threadx-version-id"></a>Идентификатор версии ThreadX

Программист может получить данные о версии ThreadX, изучив файл ***tx_port.h** _. Кроме того, этот файл содержит журнал версий для соответствующей платформы. Программное обеспечение приложения может получить сведения о версии ThreadX из глобальной строки _*_tx_version_id**.
