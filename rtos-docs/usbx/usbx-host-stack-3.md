---
title: Глава 3. Функциональные компоненты стека узлов USBX
description: В этой главе приведено описание высокопроизводительного внедренного в USBX стека узлов USB с точки зрения функциональных возможностей.
author: philmea
ms.author: philmea
ms.date: 5/19/2020
ms.service: rtos
ms.topic: article
ms.openlocfilehash: a3cbbb2e26d66d3db26144a47a1b6cbb11387c7b5b2ba5e19d35df026e5e3598
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116790894"
---
# <a name="chapter-3---functional-components-of-usbx-host-stack"></a>Глава 3. Функциональные компоненты стека узлов USBX

В этой главе приведено описание высокопроизводительного внедренного в USBX стека узлов USB с точки зрения функциональных возможностей.

## <a name="execution-overview"></a>Общие сведения о выполнении

USBX включает в себя следующие компоненты:

- инициализация;
- вызовы интерфейса приложения;
- корневой концентратор;
- класс концентраторов;
- классы узлов;
- стек узлов USB;
- хост-контроллер.

Стек узлов USBX показан на схеме ниже.

![Стек узлов USBX](./media/usbx-host-stack/usbx-host-stack.png)

### <a name="initialization"></a>Инициализация

Чтобы активировать USBX, нужно вызвать функцию ***ux_system_initialize***. Эта функция инициализирует ресурсы памяти USBX.

Чтобы активировать средства узлов USBX, нужно вызвать функцию ***ux_system_initialize***. Эта функция в свою очередь инициализирует все ресурсы, используемые стеком узлов USBX, например потоки ThreadX, мьютексы и семафоры.

Активация как минимум одного хост-контроллера USB и одного или нескольких классов USB выполняется уже при инициализации приложения. Если классы были зарегистрированы в стеке и была вызвана функция инициализации хост-контроллеров, то шина является активной и можно начать обнаружение устройств. Если корневой концентратор хост-контроллера обнаружит подключенное устройство, то поток перечисления USB, отвечающий за топологию USB, будет пробужден и продолжится перечисление устройств.

Ввиду особенностей корневого концентратора и нисходящих концентраторов возможна ситуация, когда все подключенные USB-устройства не будут полностью настроены при возвращении функции инициализации хост-контроллера. Перечисление всех USB-устройств может занять несколько секунд, особенно при наличии одного или нескольких концентраторов между корневым концентратором и USB-устройствами.

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

В USBX доступны два уровня API:

- интерфейсы API стека узлов USB;
- интерфейсы API классов узлов USB.

Как правило, приложение USBX не должно вызывать функции API стека узлов USB. Большинство приложений обращается только к функциям API классов USB.

### <a name="usb-host-stack-apis"></a>Интерфейсы API стека узлов USB

Функции API стека узлов отвечают за регистрацию компонентов USBX (классов узлов и контроллеров узлов), конфигурацию устройств и запросы на передачу на доступные конечные точки устройств.

### <a name="usb-host-class-api"></a>API классов узлов USB

Интерфейсы API классов для каждого класса USB сильно различаются. Большинство популярных функций API для классов USB предоставляют такие возможности, как выключение и включение устройства, а также считывание или запись на устройстве.

### <a name="root-hub"></a>корневой концентратор;

У каждого экземпляра хост-контроллера есть один или несколько корневых концентраторов USB. Количество корневых концентраторов определяется структурой контроллера. Его можно получить путем считывания определенных регистров контроллера.

### <a name="hub-class"></a>Класс концентраторов

Класс концентраторов отвечает за управление концентраторами USB. Концентратор USB может быть изолированным или являться частью многофункционального устройства, такого как клавиатура или монитор. Концентратор может быть с собственным питанием или питанием от шины. Концентраторы с питанием от шины имеют до четырех нисходящих портов и допускают подключение только устройств с собственным питанием или питанием от шины с током до 100 мА. Концентраторы можно подключать каскадом. Можно подключить друг к другу до пяти концентраторов.

### <a name="usb-host-stack"></a>Стек узлов USB

Стек узлов USB — это основа USBX. У него три основные функции:

- управление топологией USB;
- привязка USB-устройства к одному или нескольким классам;
- предоставление API классам для опроса дескрипторов устройств и передачи данных по USB.

### <a name="topology-manager"></a>Диспетчер топологии

Поток топологии стека USB пробуждается при подключении нового устройства или при отключении устройства. Подключения устройств может принимать корневой или обычный концентратор. После подключения устройства к USB диспетчер топологии извлекает дескриптор устройства. Этот дескриптор будет содержать количество возможных конфигураций, доступных для этого устройства. Большинство устройств имеет только одну конфигурацию. Некоторые устройства могут функционировать по-разному в зависимости от доступной мощности порта, к которому они подключены. В этом случае у устройства будет несколько конфигураций, которые можно выбрать в зависимости от доступной мощности. Когда устройство настроено диспетчером топологии, ему разрешается потреблять мощность, указанную в его дескрипторе конфигурации.

## <a name="usb-class-binding"></a>Привязка классов USB

Если устройство настроено, то диспетчер топологии позволит диспетчеру классов продолжить обнаружение устройства, просмотрев дескрипторы интерфейса устройства. Устройство может иметь один или несколько дескрипторов интерфейса.

Интерфейс представляет функцию в устройстве. Например, динамик USB имеет три интерфейса: для потоковой передачи, для управления звуком и для управления различными кнопками динамика.

В диспетчере классов есть два механизма присоединения интерфейсов устройств к одному или нескольким классам. Он может использовать сочетание идентификаторов PID и VID (идентификатор продукта и идентификатор поставщика), найденных в дескрипторе интерфейса, или сочетание класса, подкласса и протокола.

Сочетание PID и VID допустимо для интерфейсов, для управления которыми невозможно использовать универсальный класс. Сочетание класса, подкласса и протокола используется интерфейсами, принадлежащими к классу, сертифицированному по USB-IF (например, принтер, концентратор, хранилище, аудиоустройство или HID-устройство).

Диспетчер классов содержит список зарегистрированных классов, полученный при инициализации USBX. Диспетчер классов будет вызывать каждый класс по одному, пока какой-либо класс не примет управление интерфейсом для этого устройства. Класс может управлять только одним интерфейсом. Например, для динамика USB диспетчер классов будет вызывать все классы для каждого из интерфейсов.

После того как класс принимает интерфейс, создается новый экземпляр этого класса. Затем диспетчер классов выполняет поиск альтернативного параметра по умолчанию для интерфейса. У устройства может быть один или несколько альтернативных параметров для каждого интерфейса. Альтернативный параметр 0 будет использоваться по умолчанию до тех пор, пока класс не решит изменить его.

Для альтернативного параметра по умолчанию диспетчер классов подключит все конечные точки, указанные в этом альтернативном параметре. Если подключение каждой конечной точки выполнено успешно, диспетчер классов завершит свою работу, вернувшись к классу, который завершит инициализацию интерфейса.

### <a name="usbx-apis"></a>Интерфейсы API USBX

Стек USB экспортирует определенное количество интерфейсов API для классов USB, предназначенных для выполнения опроса устройства и передачи данных по USB на определенных конечных точках. Эти функции API подробно описаны в данном справочном руководстве.

### <a name="host-controller"></a>Хост-контроллер

Драйвер хост-контроллера отвечает за управление контроллером USB определенного типа. Хост-контроллер USB может содержать несколько контроллеров. Например, определенный набор микросхем Intel для компьютеров содержит два контроллера UHCI. Некоторые контроллеры USB 2.0 содержат несколько экземпляров контроллера OHCI в дополнение к одному экземпляру контроллера EHCI.

Хост-контроллер будет управлять несколькими экземплярами одного контроллера. Для работы большинства хост-контроллеров USB 2.0 в процессе инициализации USBX потребуется инициализировать контроллер OCHI и контроллер EHCI.

Хост-контроллер отвечает за управление следующим:

- корневой концентратор;
- Управление питанием
- Конечные точки
- Передачи

### <a name="root-hub"></a>корневой концентратор;

Управление корневым концентратором отвечает за включение всех портов контроллера и определение наличия подключенных устройств. Эти функциональные возможности используется универсальным корневым концентратором USBX для опроса нисходящих портов контроллера.

### <a name="power-management"></a>Управление питанием

Управление питанием обеспечивает обработку сигналов приостановки и возобновления в совместном режиме, что влияет на все нисходящие порты контроллера одновременно или по отдельности, если контроллер предоставляет эту функцию.

### <a name="endpoints"></a>Конечные точки

Управление конечными точками обеспечивает создание или уничтожение физических конечных точек контроллера. Физические конечные точки — это сущности в памяти, которые анализируются контроллером, если контроллер поддерживает главный канал DMA, или записаны в контроллер. Физические конечные точки содержат сведения о транзакциях, выполняемых контроллером.

### <a name="transfers"></a>Передачи

Управление передачей данных предоставляет класс для выполнения транзакции на каждой из созданных конечных точек. Каждая логическая точка содержит компонент TRANSFER REQUEST для запросов на передачу USB. Структура TRANSFER REQUEST используется стеком для описания транзакции. Затем эта структура передается в стек и контроллер, который может разделить ее на несколько подтранзакций, в зависимости от возможностей контроллера.

## <a name="usb-device-framework"></a>Платформа USB-устройств

USB-устройство представляется деревом дескрипторов. Существуют шесть основных типов дескрипторов:

- дескрипторы устройства;
- дескрипторы конфигурации;
- дескрипторы интерфейса;
- дескрипторы конечной точки;
- дескрипторы строки;
- функциональные дескрипторы.

USB-устройство может иметь очень простое описание, как показано ниже.
![Простое USB-устройство](./media/usbx-host-stack/usb-device-simple.png)

На приведенном выше рисунке устройство имеет только одну конфигурацию. К этой конфигурации подключен один интерфейс, указывающий, что устройство имеет только одну функцию и одну конечную точку. К дескриптору устройства подключен дескриптор строки, обеспечивающий видимую идентификацию устройства.

Однако устройство может быть более сложным и выглядеть следующим образом.

![Сложное USB-устройство](./media/usbx-host-stack/usb-device-complex.png)

На приведенном выше рисунке у устройства два дескриптора конфигурации, подключенных к дескриптору устройства. Это устройство может указать, что у него есть два режима питания или что им можно управлять либо с помощью стандартных классов, либо с помощью собственных классов.

К первой конфигурации подключены два интерфейса, указывающие, что устройство имеет две логические функции. Первая функция содержит 3 дескриптора конечной точки и функциональный дескриптор. Функциональный дескриптор может использоваться классом, отвечающим за управление интерфейсом, для получения дополнительных сведений об этом интерфейсе, обычно не указываемых в универсальным дескрипторе.

### <a name="device-descriptors"></a>Дескрипторы устройства

Каждое USB-устройство имеет один дескриптор устройства. Этот дескриптор содержит идентификационные данные устройства, число поддерживаемых конфигураций и характеристики используемой по умолчанию конечной точки управления, используемой для настройки этого устройства.

| Offset | Поле              | Size | Значение    | Описание                             |
| ------ | ------------------ | ---- | -------- | --------------------------------------- |
| 0      | BLength            | 1    | Число   | Размер дескриптора в байтах |
| 1      | bDescriptorType    | 1    | Константа | Тип дескриптора устройства |
| 2      | bcdUSB             | 2    | BCD      | Номер выпуска спецификации USB в двоично-десятичном коде<br />Пример: номер 2.10 эквивалентен 0x210. В этом поле указывается выпуск спецификации USB, которой соответствует устройство и его дескрипторы. |
| 4      | bDeviceClass       | 1    | Класс    | Код класса (назначается USB-IF).<br />Если это поле сброшено в 0, то каждый интерфейс в конфигурации указывает сведения о собственном классе, и разные интерфейсы работают независимо друг от друга.<br />Если для этого поля задано значение от 1 до 0xFE, то устройство поддерживает различные спецификации классов в разных интерфейсах, и интерфейсы могут не работать независимо. Это значение идентифицирует определение класса, используемого для агрегатных интерфейсов.<br />Если для этого поля задано значение 0xFF, то класс устройства зависит от поставщика. |
| 5      | bDeviceSubClass    | 1    | SubClass | Код подкласса (назначается USB-IF).<br />Эти коды определяются значением поля bDeviceClass. Если поле bDeviceClass сброшено в 0, то это поле также должно быть сброшено в 0. Если для поля bDeviceClass не задано значение 0xFF, то все значения зарезервированы для назначения USB. |
| 6      | bDeviceProtocol    | 1    | Протокол | Код протокола (назначается USB-IF).<br />Эти коды определяются значениями полей bDeviceClass и bDeviceSubClass. Если устройство поддерживает зависящие от класса протоколы для каждого устройства, а не каждого интерфейса, то этот код определяет протоколы, используемые устройством в соответствии со спецификацией класса устройства. Если это поле сброшено в 0, то устройство не использует зависящие от класса протоколы для каждого устройства.<br />Однако оно может использовать зависящие от класса протоколы для каждого интерфейса.<br />Если для этого поля задано значение 0xFF, то устройство использует зависящий от поставщика протокол для каждого устройства. |
| 7      | bMaxPacketSize0    | 1    | Число   | Максимальный размер пакета для конечной точки 0 (допускаются только размеры в байтах: 8, 16, 32 или 64). |
| 8      | idVendor           | 2    | ID       | Идентификатор поставщика (назначается USB-IF). |
| 10     | idProduct          | 2    | ID       | Идентификатор продукта (назначается производителем). |
| 12     | bcdDevice          | 2    | BCD      | Номер выпуска устройства в двоично-десятичном формате. |
| 14     | iManufacturer      | 1    | Индекс    | Индекс дескриптора строки, описывающий производителя. |
| 15     | iProduct           | 1    | Индекс    | Индекс дескриптора строки, описывающий продукт. |
| 16     | iSerialNumbe       | 1    | Индекс    | Индекс дескриптора строки, описывающий серийный номер устройства. |
| 17     | bNumConfigurations | 1    | Число   | Количество возможных конфигураций. |

USBX определяет дескриптор USB-устройства следующим образом:

```c
typedef struct UX_DEVICE_DESCRIPTOR_STRUCT
{
    UINT      bLength;
    UINT      bDescriptorType;
    USHORT    bcdUSB;
    UINT      bDeviceClass;
    UINT      bDeviceSubClass;
    UINT      bDeviceProtocol;
    UINT      bMaxPacketSize0;
    USHORT    idVendor;
    USHORT    idProduct;
    USHORT    bcdDevice;
    UINT      iManufacturer;
    UINT      iProduct;
    UINT      iSerialNumber;
    UINT      bNumConfigurations;
} UX_DEVICE_DESCRIPTOR;
```

Дескриптор USB-устройства является частью контейнера устройства, как показано ниже.

```c
typedef struct UX_DEVICE_STRUCT
{
    ULONG ux_device_handle;
    ULONG ux_device_type;
    ULONG ux_device_state;
    ULONG ux_device_address;
    ULONG ux_device_speed;
    ULONG ux_device_port_location;
    ULONG ux_device_max_power;
    ULONG ux_device_power_source;
    UINT ux_device_current_configuration;

    TX_SEMAPHORE ux_device_protection_semaphore;
    struct UX_DEVICE_STRUCT *ux_device_parent; 
    struct UX_HOST_CLASS_STRUCT *ux_device_class; 
    VOID *ux_device_class_instance;
    struct UX_HCD_STRUCT *ux_device_hcd;
    struct UX_CONFIGURATION_STRUCT *ux_device_first_configuration; 
    struct UX_DEVICE_STRUCT *ux_device_next_device;
    struct UX_DEVICE_DESCRIPTOR_STRUCT ux_device_descriptor;
    struct UX_ENDPOINT_STRUCT ux_device_control_endpoint;
    struct UX_HUB_TT_STRUCT ux_device_hub_tt[UX_MAX_TT];
} UX_DEVICE;
```

- **ux_device_handle**: дескриптор устройства. Обычно это адрес экземпляра данной структуры для устройства.
- **ux_device_type**: устаревшее значение. Не используется.
- **ux_device_state**: состояние устройства, которое может иметь одно из следующих значений:
    - **UX_DEVICE_RESET**                0
    - **UX_DEVICE_ATTACHED**             1
    - **UX_DEVICE_ADDRESSED**            2
    - **UX_DEVICE_CONFIGURED**           3
    - **UX_DEVICE_SUSPENDED**            4
    - **UX_DEVICE_RESUMED**              5
    - **UX_DEVICE_SELF_POWERED_STATE**   6
    - **UX_DEVICE_SELF_POWERED_STATE**   7
    - **UX_DEVICE_REMOTE_WAKEUP**        8
    - **UX_DEVICE_BUS_RESET_COMPLETED**  9
    - **UX_DEVICE_REMOVED**              10
    - **UX_DEVICE_FORCE_DISCONNECT**     11
- **ux_device_address**: адрес устройства после того, как принята команда **SET_ADDRESS** (от 1 до 127).
- **ux_device_speed**: скорость устройства:
    - **UX_LOW_SPEED_DEVICE**      0
    - **UX_FULL_SPEED_DEVICE**     1
    - **UX_HIGH_SPEED_DEVICE**     2
- **ux_device_port_location**: индекс порта родительского устройства (корневого концентратора или концентратора).
- **ux_device_max_power**: максимальный ток в мА, который может получать устройство в выбранной конфигурации.
- **ux_device_power_source**: может иметь одно из двух следующих значений:
    - **UX_DEVICE_BUS_POWERED**     1
    - **UX_DEVICE_SELF_POWERED**    2
- **ux_device_current_configuration**: индекс текущей конфигурации, используемой этим устройством.
- **ux_device_parent**: указатель на контейнер родительского устройства этого устройства. Если указатель равен NULL, то родительским устройством является корневой концентратор контроллера.
- **ux_device_class**: указатель на тип класса, к которому принадлежит устройство.
- **ux_device_class_instance**: указатель на экземпляр класса, к которому принадлежит это устройство.
- **ux_device_hcd**: экземпляр хост-контроллера USB, к которому подключено это устройство.
- **ux_device_first_configuration**: указатель на первый контейнер конфигурации для этого устройства.
- **ux_device_next_device**: указатель на следующее устройство в списке устройств на любой из шин, обнаруженных USBX.
- **ux_device_descriptor**: дескриптор USB-устройства.
- **ux_device_control_endpoint**: дескриптор конечной точки управления по умолчанию, используемой этим устройством.
- **ux_device_hub_tt**: массив трансляторов транзакций (ТТ) для устройства.

### <a name="configuration-descriptors"></a>Дескрипторы конфигурации

Дескриптор конфигурации содержит сведения о конкретной конфигурации устройства. USB-устройство может содержать один или несколько дескрипторов конфигурации. Поле **bNumConfigurations** в дескрипторе устройства указывает число дескрипторов конфигурации. Дескриптор содержит поле **bConfigurationValue** со значением, которое при использовании в качестве параметра для запроса Set Configuration указывает устройству принять описанную конфигурацию.

Дескриптор описывает количество интерфейсов, предоставляемых конфигурацией. Каждый интерфейс представляет логическую функцию в устройстве и может работать независимо. Например, динамик USB может иметь три интерфейса: интерфейс для потоковой передачи, интерфейс для управления звуком и HID-интерфейс для управления кнопками динамика.

Когда узел выдает запрос GET_DESCRIPTOR для дескриптора конфигурации, возвращаются все соответствующие дескрипторы интерфейса и конечной точки.

| Offset | Поле               | Size | Значение    | Описание                       |
| ------ | ------------------- | ---- | -------- | --------------------------------- |
| 0      | bLength             | 1    | Число   | Размер дескриптора в байтах. |
| 1      | bDescriptorType     | 1    | Константа | CONFIGURATION                     |
| 2      | wTotalLength        | 2    | Число   | Общая длина данных, возвращаемых для этой конфигурации. Включает в себя совокупную длину всех дескрипторов (конфигурации, интерфейса, конечной точки, а также дескрипторов, относящихся к классу или поставщику), возвращаемых для этой конфигурации. |
| 4      | bNumInterfaces      | 1    | Число   | Число интерфейсов, поддерживаемых этой конфигурацией. |
| 5      | bConfigurationValue | 1    | Число   | Значение, используемое в качестве аргумента для запроса SET<br/>Configuration для выбора этой конфигурации. |
| 6      | iConfiguration      | 1    | Индекс    | Индекс дескриптора строки, описывающий эту конфигурацию. |
| 7      | bMAttributes        | 1    | Bitmap   | Характеристики конфигурации: D7 — питание от шины;<br />D6 — с собственным питанием;<br />D5 — удаленное пробуждение;<br />D4…0 — зарезервированы (сброшены в 0).<br />В конфигурации устройства, которая использует питание от шины и локальный источник питания, задается и параметр D7, и параметр D6. Фактический источник питания во время выполнения можно определить с помощью запроса устройства GET STATUS.<br />Если конфигурация устройства поддерживает удаленное пробуждение, то параметр D5 имеет значение 1. |
| 8      | MaxPower            | 1    | мА       | Максимальный ток потребления USB-устройства от шины в данной конфигурации, если устройство полностью работоспособно.<br />Указывается в единицах по 2 мА (например, 50 = 100 мА).<br />Примечание. В конфигурации устройства указывается тип питания: от шины или собственное.<br />Состояние устройства указывает, использует ли устройство собственное питание в данный момент. Если устройство отключается от внешнего источника питания, оно обновляет свое состояние, чтобы указать, что оно больше не использует собственное питание. |

USBX определяет дескриптор конфигурации USB следующим образом.

```c
typedef struct UX_CONFIGURATION_DESCRIPTOR_STRUCT
{
    UINT bLength;
    UINT bDescriptorType;
    USHORT wTotalLength;
    UINT bNumInterfaces;
    UINT bConfigurationValue;
    UINT iConfiguration;
    UINT bmAttributes;
    UINT MaxPower;
} UX_CONFIGURATION_DESCRIPTOR;
```

Дескриптор конфигурации USB является частью контейнера конфигурации, как показано ниже.

```c
typedef struct UX_CONFIGURATION_STRUCT
{
    ULONG ux_configuration_handle;
    ULONG ux_configuration_state;
    struct UX_CONFIGURATION_DESCRIPTOR_STRUCT ux_configuration_descriptor;
    struct UX_INTERFACE_STRUCT *ux_configuration_first_interface;
    struct UX_CONFIGURATION_STRUCT *ux_configuration_next_configuration;
    struct UX_DEVICE_STRUCT *ux_configuration_device;
} UX_CONFIGURATION;
```

- **ux_configuration_handle**: дескриптор конфигурации. Обычно это адрес экземпляра данной структуры для конфигурации.
- **ux_configuration_state**: состояние конфигурации.
- **ux_configuration_descriptor**: дескриптор USB-устройства.
- **ux_configuration_first_interface**: указатель на первый интерфейс для этой конфигурации.
- **ux_configuration_next_configuration**: указатель на следующую конфигурацию для того же устройства.
- **ux_configuration_device**: указатель на владельца устройства этой конфигурации.

### <a name="interface-descriptors"></a>Дескрипторы интерфейса

Дескриптор интерфейса описывает конкретный интерфейс в конфигурации. Интерфейс — это логическая функция в USB-устройстве. Конфигурация предоставляет один или несколько интерфейсов, каждый из которых содержит ноль или более дескрипторов конечных точек, описывающих уникальный набор конечных точек в конфигурации. Если конфигурация поддерживает более одного интерфейса, то дескрипторы конечных точек для определенного интерфейса соответствуют дескриптору интерфейса в данных, возвращенных запросом **GET_DESCRIPTOR** для указанной конфигурации.

Дескриптор интерфейса всегда возвращается как часть дескриптора конфигурации. Дескриптор интерфейса невозможно получить напрямую с помощью запроса GET_DESCRIPTOR.

Интерфейс может включать в себя альтернативные параметры, позволяющие изменить конечные точки и (или) их характеристики после настройки устройства. Параметр по умолчанию для интерфейса всегда является альтернативным параметром 0. Класс может изменить текущий альтернативный параметр, чтобы изменить поведение интерфейса и характеристики связанных конечных точек. Запрос SET_INTERFACE используется для выбора альтернативного параметра или возвращения к параметру по умолчанию.

Альтернативные параметры позволяют изменить часть конфигурации устройства, не влияя на работу других интерфейсов. Если в конфигурации есть альтернативные параметры для одного или нескольких интерфейсов, то для каждого параметра добавляется отдельный дескриптор интерфейса и связанные с ним конечные точки.

Если конфигурация устройства содержит один интерфейс с двумя альтернативными параметрами, то запрос GET_DESCRIPTOR для конфигурации вернет дескриптор конфигурации, затем дескриптор интерфейса с полями **bInterfaceNumber** и **bAlternateSetting**, для которых задано значение 0, а потом — дескрипторы конечных точек для этого параметра, за которым последует еще один дескриптор интерфейса и связанные с ним дескрипторы конечных точек. Второе поле дескриптора **bInterfaceNumber** также будет иметь значение 0, но поле **bAlternateSetting** второго дескриптора интерфейса будет иметь значение 1, указывающее, что этот альтернативный параметр относится к первому интерфейсу.

У интерфейса могут отсутствовать связанные конечные точки. В этом случае для него допустима только конечная точка управления по умолчанию.

Альтернативные параметры используются главным образом для изменения запрошенной пропускной способности для периодических конечных точек, связанных с интерфейсом. Например, интерфейс потокового динамика USB должен содержать первый альтернативный параметр с требованием пропускной способности "0" для своей изохронной конечной точки. Другие альтернативные параметры могут задавать другие требования к пропускной способности в зависимости от частоты потоковой передачи звука.

Дескриптор USB для интерфейса выглядит следующим образом.

| Offset | Поле              | Size | Значение     | Дескриптор                              |
| ------ | ------------------ | ---- | --------- | --------------------------------------- |
| 0      | bLength            | 1    | Число    | Размер дескриптора в байтах.       |
| 1      | bDescriptorType    | 1    | Константа  | Тип дескриптора INTERFACE.               |
| 2      | bInterfaceNumber   | 1    | Число    | Число интерфейсов. Отсчитываемое от нуля значение, определяющее индекс в массиве параллельных интерфейсов, поддерживаемых данной конфигурацией. |
| 3      | bAltenateSetting   | 1    | Число    | Значение, используемое для выбора альтернативного параметра для интерфейса, указанного в предыдущем поле. |
| 4      | bNumEndpoints      | 1    | Число    | Число конечных точек, используемых этим интерфейсом (за исключением конечной точки 0). Если это значение равно 0, то данный интерфейс использует только конечную точку 0. |
| 5      | bInterfaceClass    | 1    | Класс     | Код класса (назначается USB).<br />Если это поле сбрасывается в 0, то интерфейс не принадлежит ни к одному из классов устройств, описанных USB.<br />Если для этого поля задано значение 0xFF, то класс устройства зависит от поставщика.<br />Все остальные значения зарезервированы для назначения USB. |
| 6      | bInterfaceSubClass | 1    | SubClass  | Код подкласса (назначается USB).<br />Эти коды определяются значением поля bInterfaceClass. Если поле bInterfaceClass сброшено в 0, то это поле также должно быть сброшено в 0. Если для поля bInterfaceClass не задано значение 0xFF, то все значения зарезервированы для назначения USB. |
| 7      | bInterfaceProtocol | 1    | Протокол  | Код протокола (назначается USB). Эти коды определяются значениями полей bInterfaceClass и bInterfaceSubClass. Если интерфейс поддерживает зависящие от класса запросы, то этот код определяет протоколы, используемые устройством, как определено спецификацией класса устройств.<br />Если это поле сброшено в 0, то устройство не использует зависящие от класса протоколы для этого интерфейса. Если для этого поля задано значение 0xFF, то устройство использует зависящий от поставщика протокол для этого интерфейса. |
| 8      | iInterface         | 1    | Индекс     | Индекс дескриптора строки, описывающий этот интерфейс. |

USBX определяет дескриптор интерфейса USB следующим образом.

```c
typedef struct UX_INTERFACE_DESCRIPTOR_STRUCT
{
    UINT bLength;
    UINT bDescriptorType;
    UINT bInterfaceNumber;
    UINT bAlternateSetting;
    UINT bNumEndpoints;
    UINT bInterfaceClass
    UINT bInterfaceSubClass;
    UINT bInterfaceProtocol;
    UINT iInterface;
} UX_INTERFACE_DESCRIPTOR;
```

Дескриптор интерфейса USB является частью контейнера интерфейса, описанного ниже.

```c
typedef struct UX_INTERFACE_STRUCT
{
    ULONG ux_interface_handle;
    ULONG ux_interface_state;
    ULONG ux_interface_current_alternate_setting;
    struct UX_INTERFACE_DESCRIPTOR_STRUCT ux_interface_descriptor;
    struct UX_HOST_CLASS_STRUCT    *ux_interface_class;
    VOID    *ux_interface_class_instance;
    struct UX_ENDPOINT_STRUCT    *ux_interface_first_endpoint;
    struct UX_INTERFACE_STRUCT    *ux_interface_next_interface;
    struct UX_CONFIGURATION_STRUCT    *ux_interface_configuration;
} UX_INTERFACE;
```

- **ux_interface_handle**: дескриптор интерфейса. Обычно это адрес экземпляра данной структуры для интерфейса.
- **ux_interface_state**: состояние интерфейса.
- **ux_interface_descriptor**: дескриптор интерфейса USB.
- **ux_interface_class**: указатель на тип класса, к которому принадлежит этот интерфейс.
- **ux_device_class_instance**: указатель на экземпляр класса, к которому принадлежит этот интерфейс.
- **ux_interface_first_endpoint**: указатель на первую конечную точку, зарегистрированную с помощью этого интерфейса.
- **ux_interface_next_interface**: указатель на следующий интерфейс, связанный с конфигурацией.
- **ux_interface_configuration**: указатель на владельца конфигурации этого интерфейса.

### <a name="endpoint-descriptors"></a>Дескрипторы конечных точек

Каждая конечная точка, связанная с интерфейсом, имеет собственный дескриптор конечной точки. Этот дескриптор содержит сведения, необходимые стеку узлов, чтобы определить требования к пропускной способности каждой конечной точки, максимальный объем полезных данных, связанных с конечной точкой, ее периодичность и направление передачи данных. Дескриптор конечной точки всегда возвращается командой GET_DESCRIPTOR для конфигурации.

Конечная точка управления по умолчанию, связанная с дескриптором устройства, не считается конечной точкой, связанной с интерфейсом, и поэтому не возвращается в этом дескрипторе.

Когда программное обеспечение узла запрашивает изменение альтернативного параметра для интерфейса, все связанные конечные точки и их ресурсы USB изменяются в соответствии с новым альтернативным параметром.

За исключением конечных точек управления по умолчанию, конечные точки не могут совместно использоваться интерфейсами.

| Offset | Поле            | Size | Значение    | Описание                       |
| ------ | ---------------- | ---- | -------- | --------------------------------- |
| 0      | bLength          | 1    | Число   | Размер дескриптора в байтах. |
| 1      | bDescriptorType  | 1    | Константа | Тип дескриптора ENDPOINT. |
| 2      | bEndpointAddress | 1    | Конечная точка | Адрес конечной точки на USB-устройстве, описываемом этим дескриптором. Адрес кодируется следующим образом:<br />биты 3…0: номер конечной точки;<br />биты 6…4: зарезервированы (сброшены в 0);<br />бит 7: направление передачи, игнорируется для конечных точек управления:<br />0: конечная точка приема;<br />1: конечная точка передачи. |
| 3      | bmAttributes     | 1    | Bitmap   | Это поле описывает атрибуты конечной точки при ее настройке с помощью поля **bConfigurationValue**. Биты 1…0: тип передачи;<br />00: управление;<br />01: изохронная передача;<br />10: пакетная передача;<br />11: прерывание.<br />Если конечная точка не является изохронной, то биты 5…2 являются зарезервированными и должны быть равны 0. Если она изохронная, то эти биты они определяются следующим образом:<br />биты 3…2: тип синхронизации:<br />00: без синхронизации;<br />01: асинхронная;<br />02: адаптивная;<br />11: синхронная.<br />Биты 5…4: тип использования:<br />00: конечная точка данных;<br />01: конечная точка обратной связи;<br />10: конечная точка данных неявной обратной связи;<br />11: зарезервировано. |
| 4      | wMaxPacketSize   | 2    | Число   | Максимальный размер пакета, который эта конечная точка может отправить или получить, если выбрана эта конфигурация.<br />Для изохронных конечных точек это значение используется для резервирования времени шины в расписании, которое требуется для передачи полезных данных каждого микрокадра или кадра. Канал может постоянно использовать меньше пропускной способности, чем зарезервировано. При необходимости устройство сообщает о фактической использованной пропускной способности с помощью своих обычных механизмов, не определяемых USB.<br />Для всех конечных точек биты 10…0 задают максимальный размер пакета (в байтах).<br />Для высокоскоростных изохронных конечных точек и конечных точек прерывания:<br />биты 12…11 задают число дополнительных транзакций на микрокадр: 00 = нет (1 транзакция на микрокадр);<br />01: 1 дополнительная транзакция (2 на микрокадр);<br />10: 2 дополнительные транзакции (3 на микрокадр);<br />11: зарезервировано.<br />Биты 15…13 зарезервированы и должны иметь значение 0. |
| 6      | bInterval        | 1     | Число   | Числовой интервал опроса конечной точки при передаче данных.<br />Выражается в кадрах или микрокадрах, в зависимости от скорости работы устройства (например, 1 мс или 125 мкс).<br />Для изохронных конечных точек на максимальной скорости или высокоскоростных изохронных конечных точек это значение должно находиться в диапазоне от 1 до 16. Параметр **bInterval** используется в качестве порядка значения 2*bInterval–1. Например, **bInterval**, равный 4, означает период 8 (2*4–1).<br />Для конечных точек прерывания на максимальной или низкой скорости значение этого поля может быть в диапазоне от 1 до 255.<br />Для высокоскоростных конечных точек прерывания **bInterval** используется в качестве порядка значения 2*bInterval–1. Например, **bInterval**, равный 4, означает период 8 (24–1). Это значение должно быть в диапазоне от 1 до 16.<br />Для высокоскоростных конечных точек пакетной передачи или управления параметр **bInterval** указывает максимальную скорость передачи пакетов NAK. Значение 0 указывает, что конечная точка никогда не передает пакеты NAK. Другие значения означают не более одного пакета NAK на каждые **bInterval** микрокадров.<br />Это значение должно быть в диапазоне от 0 до 255. |

USBX определяет дескриптор конечной точки USB следующим образом.

```c
typedef struct UX_ENDPOINT_DESCRIPTOR_STRUCT
{
    UINT bLength;
    UINT bDescriptorType;
    UINT bEndpointAddress;
    UINT bmAttributes;
    USHORT wMaxPacketSize;
    UINT bInterval;
} UX_ENDPOINT_DESCRIPTOR;
```

Дескриптор конечной точки USB является частью контейнера конечной точки, который описан ниже.

```c
typedef struct UX_ENDPOINT_STRUCT {
    ULONG    ux_endpoint_handle;
    ULONG    ux_endpoint_state;
    VOID    *ux_endpoint_ed;
    struct UX_ENDPOINT_DESCRIPTOR_STRUCT    ux_endpoint_descriptor;
    struct UX_ENDPOINT_STRUCT    *ux_endpoint_next_endpoint;
    struct UX_INTERFACE_STRUCT    *ux_endpoint_interface;
    struct UX_DEVICE_STRUCT    *ux_endpoint_device;
    struct UX_TRANSFER REQUEST_STRUCT    ux_endpoint_transfer request;
} UX_ENDPOINT;

```

- **ux_endpoint_handle**: дескриптор конечной точки. Обычно это адрес экземпляра данной структуры для конечной точки.
- **ux_endpoint_state**: состояние конечной точки.
- **ux_endpoint_ed**: указатель на физическую конечную точку на уровне хост-контроллера.
- **ux_endpoint_descriptor**: дескриптор конечной точки USB.
- **ux_endpoint_next_endpoint**: указатель на следующую конечную точку, принадлежащую к тому же интерфейсу.
- **ux_endpoint_interface**: указатель на интерфейс, к которому принадлежит этот интерфейс конечной точки.
- **ux_endpoint_device**: указатель на контейнер родительского устройства.
- **запрос ux_endpoint_transfer**: запрос на передачу USB, используемый для отправки и получения данных устройства.

### <a name="string-descriptors"></a>Дескрипторы строк

Дескрипторы строк являются необязательными. Если устройство не поддерживает дескрипторы строк, то все ссылки на дескрипторы строк в дескрипторах устройства, конфигураций и интерфейсов должны быть сброшены в 0.

Дескрипторы строк используют кодирование Юникода, что обеспечивает поддержку нескольких кодировок. Строки в USB-устройстве могут поддерживать несколько языков. При запросе дескриптора строки инициатор запроса указывает требуемый язык с помощью идентификатора языка, определенного USB-IF. Список текущих определенных USB кодов LANGID можно найти в приложении USBX.
Индекс строки 0 для всех языков возвращает дескриптор строки, содержащий массив из двухбайтовых кодов LANGID, поддерживаемых устройством. Следует отметить, что строка в формате Юникода не заканчивается 0. Вместо этого размер массива строк вычисляется путем вычитания 2 из размера массива, содержащегося в первом байте дескриптора.

Дескриптор строки 0 USB кодируется следующим образом.

| Offset | Поле           | Size | Значение    | Описание                      |
| ------ | --------------- | ---- | -------- | -------------------------------- |
| 0      | bLength         | 1    | N+2      | Размер дескриптора в байтах |
| 1      | bDescriptorType | 1    | Константа | Тип дескриптора STRING.           |
| 2      | wLANGID[0]      | 2    | Число   | Код LANGID 0.                    |
| ...    | ...]            | ...  | ...      | ...                              |
| Нет      | wLANGID[n]      | 2    | Число   | Код LANGID n.                    |

Другие дескрипторы строк USB кодируются следующим образом.

| Offset | Поле           | Size | Значение    | Описание                      |
| ------ | --------------- | ---- | -------- | -------------------------------- |
| 0      | bLength         | 1    | Число   | Размер дескриптора в байтах |
| 1      | bDescriptorType | 1    | Константа | Тип дескриптора STRING.           |
| 2      | bString         | n    | Число   | Строка в кодировке Юникода.           |

USBX определяет дескриптор строки USB ненулевой длины следующим образом.

```c
typedef struct UX_STRING_DESCRIPTOR_STRUCT
{
    UINT bLength;
    UINT bDescriptorType;
    USHORT bString[1];
} UX_STRING_DESCRIPTOR;
```

### <a name="functional-descriptors"></a>Функциональные дескрипторы

Функциональные дескрипторы также называют дескрипторами, зависящими от класса. Обычно в них используются те же базовые структуры, что и в универсальных дескрипторах, и они позволяют предоставлять дополнительные сведения для класса. Например, в случае с динамиком USB зависящие от класса дескрипторы позволяют извлечь класс звука для каждого альтернативного параметра, соответствующего поддерживаемой частоте звука.

### <a name="usbx-device-descriptor-framework-in-memory"></a>Платформа дескрипторов устройств USBX в памяти

USBX хранит большинство дескрипторов устройства в памяти, а точнее — все дескрипторы, кроме дескрипторов строк и функциональных дескрипторов. На следующей схеме показано, как эти дескрипторы хранятся и как связаны между собой.

![Платформа дескрипторов устройств USBX в памяти](./media/usbx-host-stack/usbx-device-descriptor-framework.png)
