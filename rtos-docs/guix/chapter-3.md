---
title: Глава 3. Обзор функций GUIX
description: В этой главе приведен обзор функций высокопроизводительного продукта с пользовательским интерфейсом GUIX.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 2a53da048b18d35b6b15a4ad8d4138e1a2acd4e8
ms.sourcegitcommit: 95f4ae0842a486fec8f10d1480203695faa9592d
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2021
ms.locfileid: "111875258"
---
# <a name="chapter-3---functional-overview-of-guix"></a><span data-ttu-id="32aee-103">Глава 3. Обзор функций GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-103">Chapter 3 - Functional Overview of GUIX</span></span>

<span data-ttu-id="32aee-104">В этой главе приведен обзор функций высокопроизводительного продукта с пользовательским интерфейсом GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-104">This chapter contains a functional overview of the high-performance GUIX user interface product.</span></span> 

## <a name="execution-overview"></a><span data-ttu-id="32aee-105">Общие сведения о выполнении</span><span class="sxs-lookup"><span data-stu-id="32aee-105">Execution Overview</span></span>

<span data-ttu-id="32aee-106">В GUIX реализована управляемая событиями модель программирования.</span><span class="sxs-lookup"><span data-stu-id="32aee-106">GUIX implements an event driven programming model.</span></span> <span data-ttu-id="32aee-107">Это означает, что работа платформы GUIX преимущественно определяется поступлением событий, отправленных в очередь событий GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-107">This means that the GUIX framework is primarily driven by the receipt of events pushed into the GUIX event queue.</span></span> <span data-ttu-id="32aee-108">Обработка этих событий происходит в контексте потока GUIX, который представляет собой поток ThreadX, созданный во время инициализации системы GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-108">The processing of these events takes place in the context of the GUIX thread, which is a ThreadX thread created during GUIX system initialization.</span></span>

<span data-ttu-id="32aee-109">Приложения GUIX определяют пользовательский интерфейс путем вызова функций API GUIX для создания окон и дочерних мини-приложений, а также позволяют настроить внешний вид этих мини-приложений путем вызова дополнительных функций API, используемых для определения цветов, стилей, шрифтов и других атрибутов каждого окна или типа мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-109">GUIX applications define the user interface by calling GUIX API functions to create windows and child widgets, and customize the appearance of these widgets by calling additional API functions used to define colors, styles, fonts, and various other attributes of each window or widget type.</span></span> <span data-ttu-id="32aee-110">Если вы используете GUIX Studio для создания внешнего вида экранов пользовательского интерфейса, большую часть этой работы, связанной с вызовом функций API GUIX для создания представления, выполняет за вас приложение GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-110">If you are using GUIX Studio to create the appearance of your user-interface screens, much of this work of calling GUIX API functions to create your display is done for you by the GUIX Studio application.</span></span>

<span data-ttu-id="32aee-111">Приложения GUIX взаимодействуют с системным пользователем и внешней бизнес-логикой, обрабатывая события, полученные из очереди событий GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-111">GUIX applications interact with the system user and with external business logic by handling events retrieved from the GUIX event queue.</span></span>
<span data-ttu-id="32aee-112">Эти события обычно создаются с помощью мини-приложений GUIX, но они также могут создаваться внешними потоками.</span><span class="sxs-lookup"><span data-stu-id="32aee-112">These events are usually produced by GUIX widgets, but they can also be created by external threads.</span></span> <span data-ttu-id="32aee-113">При нажатии стандартной кнопки GUIX в родительское окно кнопки отправляется событие.</span><span class="sxs-lookup"><span data-stu-id="32aee-113">When a typical GUIX button is pushed, that button sends an event to the button’s parent window.</span></span> <span data-ttu-id="32aee-114">При нажатии этой кнопки приложение предоставляет обработчик события нажатия кнопки.</span><span class="sxs-lookup"><span data-stu-id="32aee-114">Your application program will act on that button push by providing a handler for the button push event.</span></span>

<span data-ttu-id="32aee-115">Дополнительные потоки GUIX часто создаются для таких компонентов, как драйверы ввода.</span><span class="sxs-lookup"><span data-stu-id="32aee-115">Additional GUIX threads are often created for things such as input drivers.</span></span> <span data-ttu-id="32aee-116">Типичный драйвер ввода на сенсорном экране выполняется как отдельный поток (внешний для основного потока GUIX).</span><span class="sxs-lookup"><span data-stu-id="32aee-116">A typical touch screen input driver is executed as a standalone thread external to the main GUIX thread.</span></span> <span data-ttu-id="32aee-117">Драйвер сенсорного ввода отправляет сенсорную информацию в поток GUIX путем отправления событий в очередь событий GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-117">The touch input driver sends touch information into the GUIX thread by sending events into the GUIX event queue.</span></span>

<span data-ttu-id="32aee-118">Так как для многих операций с пользовательскими интерфейсами, например для анимации, необходима точная информация о времени, в GUIX также реализован простой и удобный в использовании интерфейс таймера.</span><span class="sxs-lookup"><span data-stu-id="32aee-118">Since many user-interface operations such as animations require accurate timing information, GUIX also implements a simple and easy to use timer interface.</span></span> <span data-ttu-id="32aee-119">Этот интерфейс таймера создан на основе службы таймера ThreadX и настраивается автоматически при запуске системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-119">This timer interface is built upon the ThreadX timer service, and is configured automatically at system startup.</span></span>

<span data-ttu-id="32aee-120">Большая часть программного обеспечения GUIX не имеет каких-либо зависимостей оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-120">The vast majority of the GUIX software is independent of any hardware dependencies.</span></span> <span data-ttu-id="32aee-121">Для платформы необходимы драйверы ввода и графические драйверы оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-121">The framework does require hardware-specific input drivers and hardware-specific graphics drivers.</span></span> <span data-ttu-id="32aee-122">Сведения о реализации этих драйверов оборудования содержатся в главе 5.</span><span class="sxs-lookup"><span data-stu-id="32aee-122">The details of how these hardware specific drivers are implemented are deferred to chapter 5.</span></span>

## <a name="initialization"></a><span data-ttu-id="32aee-123">Инициализация</span><span class="sxs-lookup"><span data-stu-id="32aee-123">Initialization</span></span> 

<span data-ttu-id="32aee-124">Службу ***gx_system_initialize*** необходимо вызывать до вызова любой другой службы GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-124">The service ***gx_system_initialize*** must be called before any other GUIX service is called.</span></span> <span data-ttu-id="32aee-125">Инициализацию системы GUIX можно вызвать с помощью подпрограммы ***tx_application_define*** ThreadX (контекст инициализации) или с помощью потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-125">GUIX system initialization can be called from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="32aee-126">Функция ***gx_system_initialize*** создает очередь событий GUIX, инициализирует устройство таймера GUIX, создает главный системный поток GUIX и инициализирует различные структуры данных, поддерживаемые GUIX во время выполнения приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-126">The ***gx_system_initialize*** function creates the GUIX event queue, initializes the GUIX timer facility, creates the main GUIX system thread, and initializes various data structures maintained by GUIX during the execution of your application.</span></span>

<span data-ttu-id="32aee-127">После возвращения ***gx_system_initialize*** приложение готово для создания экранов, холстов, окон, мини-приложений, а также настройки свойств всех объектов GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-127">After ***gx_system_initialize*** returns, the application is ready to create displays, canvases, windows, widgets, and customize the properties of all GUIX objects.</span></span> <span data-ttu-id="32aee-128">Большую часть API для создания объектов GUIX можно вызывать с помощью ***tx_application_define*** или потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-128">Much of the GUIX object creation API can be called from ***tx_application_define*** or from application threads.</span></span>

## <a name="application-interface-calls"></a><span data-ttu-id="32aee-129">Вызовы интерфейса приложения</span><span class="sxs-lookup"><span data-stu-id="32aee-129">Application Interface Calls</span></span> 

<span data-ttu-id="32aee-130">Вызовы из приложения в большинстве случаев выполняются с помощью ***tx_application_define*** (контекст инициализации) или потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-130">Calls from the application are largely made from ***tx_application_define*** (initialization context) or from application threads.</span></span> <span data-ttu-id="32aee-131">Чтобы определить, какой контекст можно использовать для вызовов, ознакомьтесь с разделом о соответствующих разрешениях для каждого API GUIX в главе 4.</span><span class="sxs-lookup"><span data-stu-id="32aee-131">Please see the “Allowed From” section of each GUIX API described in Chapter 4 to determine what context it may be called from.</span></span>

<span data-ttu-id="32aee-132">В большинстве случаев обработка ресурсоемких действий выполняется с использованием внутреннего потока GUIX, включая обработку всех событий и операции рисования для мини-приложений и окон.</span><span class="sxs-lookup"><span data-stu-id="32aee-132">For the most part, processing intensive activities are deferred to the internal GUIX thread, including all event processing and widget/window drawing.</span></span>

<span data-ttu-id="32aee-133">Функции API GUIX можно вызывать из любого потока в любое время.</span><span class="sxs-lookup"><span data-stu-id="32aee-133">The GUIX API functions can be called from any thread at any time.</span></span>
<span data-ttu-id="32aee-134">Как правило, лучше использовать архитектуру, которая позволяет отделить критически важную бизнес-логику от логики пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="32aee-134">However it is usually considered to be better architecture to separate your time-critical business logic from your user interface logic.</span></span> <span data-ttu-id="32aee-135">Так как операции рисования с использованием пользовательского интерфейса иногда могут занимать много времени в зависимости от размера экрана и производительности ЦП, обычно нежелательно, чтобы критически важные потоки откладывались, ожидая завершения операции рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-135">Since the user interface drawing operations can sometimes take a long time depending on your display size and CPU performance, you normally would not want to have time-critical threads delayed waiting for a drawing operation to complete.</span></span>

## <a name="internal-guix-thread"></a><span data-ttu-id="32aee-136">Внутренний поток GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-136">Internal GUIX Thread</span></span> 

<span data-ttu-id="32aee-137">Как уже упоминалось, в GUIX есть внутренний поток, который выполняет основную часть обработки данных для графического пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="32aee-137">As mentioned, GUIX has an internal thread that performs the bulk of the GUI processing.</span></span> <span data-ttu-id="32aee-138">Этот поток создается программным обеспечением приложения путем вызова ***gx_system_initialize** _, а затем — _*_gx_system_start_\*\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-138">This thread is created by the application software by calling ***gx_system_initialize** _ followed by _*_gx_system_start_\*\*.</span></span>

<span data-ttu-id="32aee-139">Приоритет внутреннего потока GUIX определяется с помощью `#define GX_SYSTEM_THREAD_PRIORITY`.</span><span class="sxs-lookup"><span data-stu-id="32aee-139">The priority of the internal GUIX thread is determined by the `#define GX_SYSTEM_THREAD_PRIORITY`.</span></span> <span data-ttu-id="32aee-140">По умолчанию это значение равно 16 (средний приоритет), но его можно изменить, указав это значение в файле заголовка gx_port.h или gx_user.h и переопределив значение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="32aee-140">This value defaults to 16 (middle priority) but can be modified by specifying this value in the gx_port.h or gx_user.h header file, overriding the default value.</span></span>

<span data-ttu-id="32aee-141">Интервал времени потока GUIX аналогичным образом определяется с помощью параметра `#define GX_SYSTEM_THREAD_TIMESLICE`, значение которого по умолчанию равно 10 мс.</span><span class="sxs-lookup"><span data-stu-id="32aee-141">The GUIX thread time slice is similarly defined by the `#define GX_SYSTEM_THREAD_TIMESLICE`, which defaults to the value 10 ms.</span></span>

<span data-ttu-id="32aee-142">Размер стека системного потока определяется с помощью параметра `#define GX_THREAD_STACK_SIZE`, который находится в файле заголовка ***gx_port.h***, но его также можно переопределить, указав это значение в файле заголовка gx_user.h.</span><span class="sxs-lookup"><span data-stu-id="32aee-142">The stack sie of the system thread is determined by the `#define GX_THREAD_STACK_SIZE`, which is found in the ***gx_port.h*** header file, but can also be overridden by specifying this value in your gx_user.h header file.</span></span>

<span data-ttu-id="32aee-143">Цикл выполнения внутреннего потока GUIX состоит из трех действий.</span><span class="sxs-lookup"><span data-stu-id="32aee-143">The internal GUIX thread execution loop is composed of three actions.</span></span>
<span data-ttu-id="32aee-144">Сначала GUIX извлекает события из очереди событий GUIX и отправляет эти события для обработки с помощью окон и мини-приложений GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-144">First, GUIX retrieves events from the GUIX event queue and dispatches those events for processing by the GUIX windows and widgets.</span></span> <span data-ttu-id="32aee-145">Как правило, события отправляются в очередь событий GUIX с помощью периодических таймеров, устройств ввода, таких как сенсорный экран или клавиатура, а также с помощью мини-приложений GUIX, которые обрабатывают данные, введенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="32aee-145">Events are typically pushed into the GUIX event queue by periodic timers, input devices such as a touch screen or keypad, and by GUIX widgets themselves as they process user input.</span></span> <span data-ttu-id="32aee-146">Далее после обработки всех событий GUIX определяет, требуется ли обновление экрана. Если да, выполняется обработка для обновления графических данных дисплея, в основном путем вызова функций рисования для тех окон и мини-приложений, которые помечены как "грязные".</span><span class="sxs-lookup"><span data-stu-id="32aee-146">Next, after all events have been processed, GUIX determines if a screen refresh is needed, and if so performs the processing necessary to update the display graphics data, mainly by calling the drawing functions of those windows and widgets which have been marked as dirty.</span></span> <span data-ttu-id="32aee-147">Наконец, GUIX блокирует поток GUIX до тех пор, пока не поступят новые события ввода.</span><span class="sxs-lookup"><span data-stu-id="32aee-147">Finally, GUIX suspends the GUIX thread until a new input event or events arrive.</span></span>

## <a name="event-processing"></a><span data-ttu-id="32aee-148">Обработка событий</span><span class="sxs-lookup"><span data-stu-id="32aee-148">Event Processing</span></span> 

<span data-ttu-id="32aee-149">События сенсорного ввода или ввода с помощью пера обрабатываются путем определения самого верхнего окна или мини-приложения под пиксельной позицией сенсорного ввода или ввода с помощью пера и вызова соответствующей функции обработки событий окна или мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-149">Touch or pen input events are processed by determining the top-most window or widget beneath the touch or pen input pixel position and calling that window/widget’s event processing function.</span></span> <span data-ttu-id="32aee-150">Если мини-приложение распознает события ввода с помощью пера, оно обработает событие соответствующим образом для этого типа мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-150">If the widget understands pen input events, it will process the event as appropriate for that widget type.</span></span> <span data-ttu-id="32aee-151">В противном случае самое верхнее мини-приложение передаст событие сенсорного ввода или ввода с помощью пера родительскому элементу мини-приложения для обработки.</span><span class="sxs-lookup"><span data-stu-id="32aee-151">If not, the top-most widget will pass the touch or pen input event to the widget's parent for processing.</span></span> <span data-ttu-id="32aee-152">Такая передача события вверх по цепочке продолжается до тех пор, пока событие не будет обработано или не поступит в корневое окно, после чего оно отменяется.</span><span class="sxs-lookup"><span data-stu-id="32aee-152">This passing of the event up the chain continues until either the event is handled or the event arrives at the root window, in which case the event is discarded.</span></span>

<span data-ttu-id="32aee-153">События клавиатуры отправляются в окно или мини-приложение с фокусом ввода.</span><span class="sxs-lookup"><span data-stu-id="32aee-153">Keypad events are sent to the window/widget that has input focus.</span></span> <span data-ttu-id="32aee-154">Состояние фокуса ввода сохраняется с помощью компонента gx_system GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-154">Input focus status is maintained by the GUIX gx_system component.</span></span>

<span data-ttu-id="32aee-155">События таймера всегда отправляются в окно или мини-приложение, в которых есть таймер для обработки.</span><span class="sxs-lookup"><span data-stu-id="32aee-155">Timer events are always dispatched to the window or widget that owns the timer for processing.</span></span>

<span data-ttu-id="32aee-156">Внутренне созданные события, такие как события нажатия кнопки или изменения значения ползунка, всегда отправляются в родительский элемент мини-приложения, создающего событие.</span><span class="sxs-lookup"><span data-stu-id="32aee-156">Internally generated events, such as button click events or slider value change events, are always sent to the parent of the widget generating the event.</span></span> <span data-ttu-id="32aee-157">Если родительский элемент не обрабатывает событие, оно передается вверх по цепочке аналогично событиям сенсорного ввода или ввода с помощью пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-157">If the parent does not process the event, it is passed up the chain similar to touch or pen input events.</span></span>

## <a name="drawing"></a><span data-ttu-id="32aee-158">Рисование</span><span class="sxs-lookup"><span data-stu-id="32aee-158">Drawing</span></span> 

<span data-ttu-id="32aee-159">После завершения обработки событий внутренний поток GUIX определяет, требуется ли обновление данных дисплея. Если да, вызываются функции рисования для соответствующего окна и мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-159">Once all the event processing is complete, the GUIX internal thread determines if any display update is needed and if so the appropriate window/widget drawing functions are called.</span></span> <span data-ttu-id="32aee-160">После завершения рисования внутренний поток GUIX просто ждет в очереди событий следующего события GUIX для обработки.</span><span class="sxs-lookup"><span data-stu-id="32aee-160">When drawing is complete, the GUIX internal thread simply waits on its event queue for the next GUIX event to process.</span></span>

<span data-ttu-id="32aee-161">В GUIX реализована концепция *"грязных" областей*, которые необходимо перерисовать для каждого мини-приложения и холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-161">GUIX implements the concept of *dirty areas*, which are areas that need to be re-drawn, for each widget and canvas.</span></span> <span data-ttu-id="32aee-162">Мини-приложение может выполнять операцию рисования только в тех областях, которые ранее были помечены как "грязные".</span><span class="sxs-lookup"><span data-stu-id="32aee-162">A widget can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="32aee-163">При вызове функции рисования в мини-приложении все операции рисования обрезаются внутренне до ранее определенного "грязного" прямоугольника.</span><span class="sxs-lookup"><span data-stu-id="32aee-163">When a widget drawing function is called, all drawing operations are internally clipped to the previously defined dirty rectangle.</span></span>
<span data-ttu-id="32aee-164">Попытки рисования за пределами этой области игнорируются.</span><span class="sxs-lookup"><span data-stu-id="32aee-164">Attempts to draw outside of this area are ignored.</span></span>

<span data-ttu-id="32aee-165">Мини-приложения и окна помечаются как "грязные" путем вызова функции API ***gx_system_dirty_mark***.</span><span class="sxs-lookup"><span data-stu-id="32aee-165">Widgets and windows mark themselves as dirty by calling the API function ***gx_system_dirty_mark***.</span></span> <span data-ttu-id="32aee-166">Эта функция помечает все мини-приложение или окно, как требующее перерисовки.</span><span class="sxs-lookup"><span data-stu-id="32aee-166">This function marks the entire widget or window as needing to be redrawn.</span></span> <span data-ttu-id="32aee-167">Вторую функцию (***gx_system_dirty_partial_add***) можно вызвать в качестве альтернативы, чтобы пометить только часть окна или мини-приложения как "грязную".</span><span class="sxs-lookup"><span data-stu-id="32aee-167">A second function, ***gx_system_dirty_partial_add***, can be invoked as an alternative to mark only a portion of a window or widget as dirty.</span></span>

<span data-ttu-id="32aee-168">Эта модель пометки мини-приложений как "грязных", а также перерисовки этих мини-приложений только после обработки всех событий ввода называется *отложенным рисованием*.</span><span class="sxs-lookup"><span data-stu-id="32aee-168">This model of marking widgets as dirty and then redrawing those widgets only when all input events have been processed is referred to as *deferred drawing*.</span></span> <span data-ttu-id="32aee-169">Алгоритм отложенного рисования GUIX и обслуживание "грязных" списков предназначены для повышения эффективности операций рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-169">The GUIX deferred drawing algorithm and dirty list maintenance is designed to improve drawing efficiency.</span></span> <span data-ttu-id="32aee-170">Так как операции рисования обычно требуют больших затрат, GUIX делает все возможное для предотвращения ненужных операций рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-170">Since drawing operations are typically expensive, GUIX works hard to prevent unnecessary drawing.</span></span>

<span data-ttu-id="32aee-171">Рисование выполняется на *холсте* GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-171">Drawing is done to a GUIX *canvas*.</span></span> <span data-ttu-id="32aee-172">Холст — это область памяти для хранения графических данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-172">A canvas is a memory area reserved to hold graphics data.</span></span> <span data-ttu-id="32aee-173">Холст может (не) быть напрямую связан с аппаратным буфером кадров в зависимости от архитектуры системы и ограничений памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-173">A canvas may or may not be directly linked to the hardware frame buffer, depending on the system architecture and memory constraints.</span></span> <span data-ttu-id="32aee-174">Перед выполнением операции рисования холст необходимо сначала открыть, вызвав функцию API ***gx_canvas_drawing_initiate***.</span><span class="sxs-lookup"><span data-stu-id="32aee-174">Before any drawing can occur, a canvas must first be opened for drawing by calling the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="32aee-175">Этот API готовит холст для рисования и установки текущего *контекста рисования*.</span><span class="sxs-lookup"><span data-stu-id="32aee-175">This API prepares a canvas for drawing and established the current *drawing context*.</span></span> <span data-ttu-id="32aee-176">Когда GUIX выполняет системное обновление холста, холст открывается для операции рисования и контекста рисования, который устанавливается до вызова API рисования на уровне мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-176">When GUIX performs a system canvas refresh, the canvas is opened for drawing and the drawing context established before the widget-level drawing APIs are invoked.</span></span> <span data-ttu-id="32aee-177">Поэтому мини-приложениям не нужно инициировать операцию рисования на холсте в функции рисования мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-177">Therefore widgets do not need to initiate drawing on a canvas within the widget drawing function.</span></span>

<span data-ttu-id="32aee-178">Но если приложению необходимо немедленно выполнить операцию рисования на холсте за пределами потока стандартного алгоритма отложенного рисования GUIX, приложение должно напрямую вызвать ***gx_canvas_drawing_initiate*** перед вызовом любых других функций API рисования, а также вызвать ***gx_canvas_drawing_complete*** после завершения операции немедленного рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-178">However, if an application desires to perform immediate drawing to a canvas, outside the flow of the standard GUIX deferred drawing algorithm, the application must directly invoke the ***gx_canvas_drawing_initiate*** prior to calling any other drawing API functions, and must call ***gx_canvas_drawing_complete*** once the immediate drawing has been completed.</span></span>

## <a name="user-input"></a><span data-ttu-id="32aee-179">Ввод данных пользователем</span><span class="sxs-lookup"><span data-stu-id="32aee-179">User Input</span></span> 

<span data-ttu-id="32aee-180">GUIX поддерживает сенсорный экран, мышь и клавиатуру с предопределенными типами событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-180">GUIX supports touch screen, mouse, and keyboard devices with predefined event types.</span></span> <span data-ttu-id="32aee-181">Можно использовать дополнительные устройства ввода, определив пользовательские типы событий или сопоставив пользовательское устройство ввода с предопределенными типами событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-181">Additional input devices can be utilized by defining custom event types, or by mapping the custom input device to the predefined event types.</span></span>

<span data-ttu-id="32aee-182">Действия, связанные с этими устройствами, преобразуются в события, обрабатываемые внутренним потоком GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-182">Actions associated with these devices are translated into events that are processed by the internal GUIX thread.</span></span> <span data-ttu-id="32aee-183">Программное обеспечение на уровне драйверов, созданное для поддержки сенсорного экрана, должно подготовить и отослать в очередь событий GUIX события операций перемещения пера вниз, вверх и перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="32aee-183">Driver level software written to support a touch screen must prepare and send to the GUIX event queue events for pen-down, pen-up, and pen-drag operations.</span></span> <span data-ttu-id="32aee-184">Аналогичным образом драйвер ввода для клавиатуры должен создавать события ввода с помощью нажатия и отпускания клавиш.</span><span class="sxs-lookup"><span data-stu-id="32aee-184">Similarly a keypad input driver must generate events for key press and key release input.</span></span>

## <a name="modal-dialog-execution"></a><span data-ttu-id="32aee-185">Выполнение модального диалогового окна</span><span class="sxs-lookup"><span data-stu-id="32aee-185">Modal Dialog Execution</span></span> 

<span data-ttu-id="32aee-186">Выполнение модального диалогового окна означает предоставление пользователю окна, которое должно быть закрыто каким-либо образом, прежде чем другие окна или мини-приложения GUIX смогут получать данные, введенные пользователем.</span><span class="sxs-lookup"><span data-stu-id="32aee-186">Modal dialog execution refers to presenting a window to the user that must be closed in some way before any other GUIX windows or widgets can receive user input.</span></span> <span data-ttu-id="32aee-187">Модальные диалоговые окна захватывают все данные, введенные пользователем, во время отображения диалогового окна, независимо от расположения событий сенсорного ввода или ввода с помощью мыши относительно оси x, y.</span><span class="sxs-lookup"><span data-stu-id="32aee-187">Modal dialogs capture all user input while the dialog window is displayed, regardless of the x,y position of touch or mouse input events.</span></span>

<span data-ttu-id="32aee-188">Модальные диалоговые окна запускаются программным обеспечением приложения путем создания окна обычным способом с помощью вызова ***gx_window_create***, а затем вызова функции API GUIX ***gx_window_execute.***</span><span class="sxs-lookup"><span data-stu-id="32aee-188">Modal dialogs are triggered by the application software by first creating the window in the normal way by calling ***gx_window_create***, and then calling the GUIX API function ***gx_window_execute.***</span></span>

<span data-ttu-id="32aee-189">При вызове функции ***gx_window_execute*** GUIX входит в локальный цикл обработки события.</span><span class="sxs-lookup"><span data-stu-id="32aee-189">When the ***gx_window_execute*** function is called, GUIX enters a local event processing loop.</span></span> <span data-ttu-id="32aee-190">Функция ***gx_window_execute*** не возвращается к вызывающему объекту до тех пор, пока диалоговое окно не закроется с помощью либо ввода данных пользователем, либо вызова ***gx_window_close***.</span><span class="sxs-lookup"><span data-stu-id="32aee-190">The ***gx_window_execute*** function does not return to the caller until the dialog window is closed, either by user input or by calling ***gx_window_close***.</span></span> <span data-ttu-id="32aee-191">По этой причине очень важно вызывать функцию ***gx_window_execute*** только из внутреннего потока GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-191">For this reason, it is very important never to call the ***gx_window_execute*** function from any thread other than the GUIX internal thread.</span></span>

## <a name="periodic-processing"></a><span data-ttu-id="32aee-192">Периодическая обработка</span><span class="sxs-lookup"><span data-stu-id="32aee-192">Periodic Processing</span></span> 

<span data-ttu-id="32aee-193">Чтобы обеспечить необходимые эффекты отображения, анимацию спрайта и поддержку периодических запросов приложения, в GUIX используется один таймер ThreadX.</span><span class="sxs-lookup"><span data-stu-id="32aee-193">In order to provide display effects, sprite animation, and support for application periodic requests, GUIX uses one ThreadX timer.</span></span> <span data-ttu-id="32aee-194">Этот единственный таймер используется для выполнения всех операций GUIX, связанных со временем.</span><span class="sxs-lookup"><span data-stu-id="32aee-194">This single timer is used to drive all GUIX time-related needs.</span></span> <span data-ttu-id="32aee-195">По умолчанию для параметра частоты внутренней обработки данных таймера GUIX задано значение 20 мс с помощью константы **GX_SYSTEM_TIMER_MS**, которая определена в **_gx_api.h_**, если эта константа не определена ранее в заголовке gx_port.h или gx_user.h.</span><span class="sxs-lookup"><span data-stu-id="32aee-195">By default, the frequency for the GUIX internal timer processing is set to 20ms via the constant **GX_SYSTEM_TIMER_MS**, which is defined in **_gx_api.h_**, unless the constant is previously defined in gx_port.h or gx_user.h header.</span></span> <span data-ttu-id="32aee-196">Частоту по умолчанию можно изменить в приложении с помощью параметра компиляции при создании библиотеки GUIX или путем явного переопределения в ***gx_user.h***.</span><span class="sxs-lookup"><span data-stu-id="32aee-196">The default frequency may be changed by the application via a compilation option when building the GUIX library or by explicitly redefining it in ***gx_user.h***.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-197">Обратите внимание, что частота таймера GUIX выражена в тактах таймера ОСРВ и определяется константой **GX_SYSTEM_TIMER_TICKS**.</span><span class="sxs-lookup"><span data-stu-id="32aee-197">Note that the GUIX timer frequency is expressed in RTOS timer ticks, and is defined by the constant **GX_SYSTEM_TIMER_TICKS**.</span></span> <span data-ttu-id="32aee-198">Значение **GX_SYSTEM_TIMER_TICKS** вычисляется с помощью **GX_SYSTEM_TIMER_MS** и **TX_TIMER_TICKS_PER_SECOND**.</span><span class="sxs-lookup"><span data-stu-id="32aee-198">The value of **GX_SYSTEM_TIMER_TICKS** is calculated using **GX_SYSTEM_TIMER_MS** and **TX_TIMER_TICKS_PER_SECOND**.</span></span> <span data-ttu-id="32aee-199">Пользователь может повторно определить любое из этих значений в \***gx_port.h** _ или _ \*_gx_user.h_\*\*, чтобы настроить частоту и разрешение таймера GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-199">The user can re-define any of these values in the ***gx_port.h** _ or _ *_gx_user.h_** to adjust the GUIX timer frequency and resolution.</span></span>

## <a name="display-driver"></a><span data-ttu-id="32aee-200">Драйвер дисплея</span><span class="sxs-lookup"><span data-stu-id="32aee-200">Display Driver</span></span> 

<span data-ttu-id="32aee-201">Драйверы дисплея предоставляют набор функций рисования для основного кода GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-201">Display drivers are responsible for providing a set of drawing functions to the core GUIX code.</span></span> <span data-ttu-id="32aee-202">Реализация каждой из этих функций рисования определяется драйвером. Для реализации используется аппаратное ускорение, если это возможно.</span><span class="sxs-lookup"><span data-stu-id="32aee-202">The implementation of each of these drawing functions is determined by the driver, and when possible the implementation will leverage hardware acceleration support.</span></span> <span data-ttu-id="32aee-203">Обычно функция рисования записывает пиксельные данные в буфер памяти, который может быть физическим буфером кадров или вторичным буфером в зависимости от архитектуры драйвера.</span><span class="sxs-lookup"><span data-stu-id="32aee-203">In general the drawing function works by writing pixel data to a memory buffer, which may be the physical frame buffer or it may be a secondary buffer depending on the driver architecture.</span></span> <span data-ttu-id="32aee-204">Во многих драйверах реализована двойная буферизация с помощью двух буферов кадров. Эти буферы переключаются путем вызова функции переключения буфера.</span><span class="sxs-lookup"><span data-stu-id="32aee-204">Many drivers implement double buffering using two frame buffers, and these buffers are toggled by invoking the buffer toggle function.</span></span> <span data-ttu-id="32aee-205">GUIX вызывает эти функции внутренне в нужное время.</span><span class="sxs-lookup"><span data-stu-id="32aee-205">GUIX calls these functions internally at the appropriate times.</span></span> <span data-ttu-id="32aee-206">Для систем с ограниченным объемом памяти функции рисования могут записывать данные только в один буфер кадров памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-206">For memory constrained systems, the drawing functions may only write to a single memory frame buffer.</span></span>

<span data-ttu-id="32aee-207">GUIX предоставляет реализации программного обеспечения по умолчанию для каждой низкоуровневой функции рисования на каждом поддерживаемом уровне глубины цвета и формата.</span><span class="sxs-lookup"><span data-stu-id="32aee-207">GUIX provides default software implementations of each low-level drawing function at every support color depth and format.</span></span> <span data-ttu-id="32aee-208">Эти функции вызываются с помощью указателей функций, которые хранятся в структуре **GX_DISPLAY**.</span><span class="sxs-lookup"><span data-stu-id="32aee-208">These functions are invoked via function pointers maintained within the **GX_DISPLAY** structure.</span></span> <span data-ttu-id="32aee-209">При создании драйверов оборудования, как правило, они перезаписывают некоторые из этих указателей функций функциями, которые относятся к целевому оборудованию.</span><span class="sxs-lookup"><span data-stu-id="32aee-209">When hardware-specific drivers are created, they typically will overwrite some number of these function pointers with functions that are specific to the target hardware.</span></span>

<span data-ttu-id="32aee-210">Типичный аппаратный драйвер дисплея реализуется путем создания драйвера дисплея GUIX по умолчанию для необходимых глубины цвета и формата.</span><span class="sxs-lookup"><span data-stu-id="32aee-210">A typical hardware display driver is implemented by first creating the default GUIX display driver for the required color depth and format.</span></span>
<span data-ttu-id="32aee-211">Затем аппаратный драйвер заменяет эти функции, которые необходимо оптимизировать или настроить для конкретной реализации оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-211">Then the hardware driver will replace those functions that need to be optimized or customized for the particular hardware implementation.</span></span>

<span data-ttu-id="32aee-212">GUIX поддерживает пиксельные цветовые форматы в диапазоне от 1 бит/пкс (монохромный) до 32 бит/пкс (a:r:g:b).</span><span class="sxs-lookup"><span data-stu-id="32aee-212">GUIX support pixel color formats ranging from 1-bpp monochrome to 32-bpp a:r:g:b format.</span></span> <span data-ttu-id="32aee-213">GUIX также поддерживает множество вариантов в рамках каждой широкой категории глубины цвета, например порядок байтов r:g:b и b:g:r, форматы упакованных пикселей и пикселей с сопоставлением слов, а также альфа-каналы.</span><span class="sxs-lookup"><span data-stu-id="32aee-213">GUIX also supports many variations within each broad color-depth category, such as r:g:b versus b:g:r byte order, packed pixel versus word-aligned pixel formats, and alpha channels.</span></span> <span data-ttu-id="32aee-214">Сейчас поддерживается 25 различных форматов цвета, но этот список пополняется, так как поставщики оборудования предоставляют новые варианты.</span><span class="sxs-lookup"><span data-stu-id="32aee-214">There are currently 25 distinct color formats supported, but this list grows as hardware vendors deliver new variations.</span></span>

## <a name="display-memory-architectures"></a><span data-ttu-id="32aee-215">Архитектуры памяти для дисплея</span><span class="sxs-lookup"><span data-stu-id="32aee-215">Display Memory Architectures</span></span>

<span data-ttu-id="32aee-216">Различные аппаратные целевые объекты и дисплеи используют различные архитектуры памяти дисплея в зависимости от ограничений для памяти на основе требований относительно целевых объектов и функций приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-216">Various hardware targets and displays utilize a variety of different display memory architectures, depending on the memory constraints of the target and the functionality requirements of the application.</span></span> <span data-ttu-id="32aee-217">Мы рассмотрим некоторые используемые архитектуры памяти и кратко опишем каждую из них.</span><span class="sxs-lookup"><span data-stu-id="32aee-217">We will outline some of the common memory architectures here with a brief description of each.</span></span>

<span data-ttu-id="32aee-218">Модель 1. Нет буфера кадров, графические данные хранятся во внешнем GRAM:</span><span class="sxs-lookup"><span data-stu-id="32aee-218">Model 1) No frame buffer, graphics data held in external GRAM:</span></span>

![Нет буфера кадров, графические данные хранятся во внешнем GRAM](./media/guix/user-guide/no-frame-buffer.png)

<span data-ttu-id="32aee-220">В приведенной выше модели нет памяти для буфера кадров в модуле локальной памяти для ЦП.</span><span class="sxs-lookup"><span data-stu-id="32aee-220">In the model above, no memory for a frame buffer exists in memory local to the CPU.</span></span> <span data-ttu-id="32aee-221">Все графические данные хранятся во внешнем GRAM, встроенном в сам дисплей.</span><span class="sxs-lookup"><span data-stu-id="32aee-221">All graphics data is stored in an external GRAM which is incorporated into the display itself.</span></span> <span data-ttu-id="32aee-222">Интерфейс внешнего GRAM может быть параллельным или последовательным.</span><span class="sxs-lookup"><span data-stu-id="32aee-222">The interface to the external GRAM can be parallel or serial.</span></span> <span data-ttu-id="32aee-223">Этот тип архитектуры имеет очень низкий уровень затрат. Однако при обновлении графических данных могут происходить прерывания операций.</span><span class="sxs-lookup"><span data-stu-id="32aee-223">This type of architecture is very low cost; however it can exhibit unwanted tearing effect when the graphics data is updated.</span></span>

<span data-ttu-id="32aee-224">Модель 2. Один локальный буфер кадров:</span><span class="sxs-lookup"><span data-stu-id="32aee-224">Model 2) One local frame buffer:</span></span>

![Один локальный буфер кадров](./media/guix/user-guide/one-local-frame-buffer.png)

<span data-ttu-id="32aee-226">В этой модели память для графических данных выделяется из ОЗУ, которое напрямую доступно для ЦП.</span><span class="sxs-lookup"><span data-stu-id="32aee-226">In this model, memory for the graphics data is allocated from a random-access memory that is directly accessible the CPU.</span></span> <span data-ttu-id="32aee-227">Для повторной передачи графических данных (вместе с сигналами времени) из локальной памяти на дисплей необходимо наличие выделенного оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-227">Dedicated hardware must be present to repeatedly transmit the graphics data (along with timing signals) from the local memory to the display.</span></span> <span data-ttu-id="32aee-228">Эта модель отличается от модели 1 тем, что графическая память является блоком локальной памяти SRAM или DRAM, доступной для ЦП.</span><span class="sxs-lookup"><span data-stu-id="32aee-228">This model differs from model 1 in that the graphics memory is a block of the local SRAM or DRAM available to the CPU.</span></span> <span data-ttu-id="32aee-229">Это может быть та же память, в которой используются переменные стека и программы.</span><span class="sxs-lookup"><span data-stu-id="32aee-229">This may be the same memory in which stack and program variables live.</span></span>

<span data-ttu-id="32aee-230">Модель 3. Локальный буфер кадров и внешнее устройство GRAM:</span><span class="sxs-lookup"><span data-stu-id="32aee-230">Model 3) Local frame buffer + external GRAM:</span></span>

![Локальный буфер кадров и внешнее устройство GRAM](./media/guix/user-guide/local-frame-buffer-external-gram.png)

<span data-ttu-id="32aee-232">Модель 3 — это сочетание первых двух моделей.</span><span class="sxs-lookup"><span data-stu-id="32aee-232">Model 3 is a combination of the first two.</span></span> <span data-ttu-id="32aee-233">В этой модели достаточно локальной памяти для одного буфера кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-233">In this model, sufficient local memory exists to hold one frame buffer.</span></span> <span data-ttu-id="32aee-234">Кроме того, устройство отображения предоставляет внешнее устройство GRAM и автоматически обновляется с помощью данных GRAM.</span><span class="sxs-lookup"><span data-stu-id="32aee-234">In addition, the display device provides an external GRAM and automatically refreshes itself using the data provided in the GRAM.</span></span> <span data-ttu-id="32aee-235">В этой архитектуре повышена эффективность обновления, так как можно передать измененную часть локального буфера кадров во внешнее устройство GRAM с помощью одного блока, часто — с использованием каналов DMA.</span><span class="sxs-lookup"><span data-stu-id="32aee-235">This architecture benefits from improved update efficiency because we can transfer the modified portion of the local frame buffer to the external GRAM in one block transfer, often utilizing onboard DMA channels.</span></span> <span data-ttu-id="32aee-236">Эта модель также позволяет устранить прерывания выполнения операций и мерцание, которые могут наблюдаться в одной из предыдущих двух моделей, так как только заполненное графическое содержимое копируется во внешнее устройство GRAM.</span><span class="sxs-lookup"><span data-stu-id="32aee-236">This model also eliminates the tearing and flicker that can be present in either of the first two models, because only completed graphics contents is copied to the external GRAM.</span></span>

<span data-ttu-id="32aee-237">Модель 4. "Пинг-понговые" буферы кадров:</span><span class="sxs-lookup"><span data-stu-id="32aee-237">Model 4) Ping-pong frame buffers:</span></span>

!["Пинг-понговые" буферы кадров](./media/guix/user-guide/ping-pong-frame-buffers.png)

<span data-ttu-id="32aee-239">В модели 4 достаточно памяти для двух локальных буферов кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-239">In model 4, sufficient memory is present to provide two local frame buffers.</span></span> <span data-ttu-id="32aee-240">В этом случае GUIX использует один буфер кадров в качестве активного, а другой — в качестве рабочего.</span><span class="sxs-lookup"><span data-stu-id="32aee-240">In this case, GUIX treats one frame buffer as the active frame buffer, and the other as the working frame buffer.</span></span> <span data-ttu-id="32aee-241">Для выполнения операции обновления отображения или операции рисования используется рабочий буфер.</span><span class="sxs-lookup"><span data-stu-id="32aee-241">When a display update or drawing operation is in progress, it takes place in the working buffer.</span></span> <span data-ttu-id="32aee-242">По завершении операции рисования буферы переключаются: рабочий буфер переключается в режим активного буфера, а активный буфер — в режим рабочего буфера.</span><span class="sxs-lookup"><span data-stu-id="32aee-242">When the drawing operation completes, the buffers are toggled, and the working buffer becomes the active buffer and the active buffer becomes the working buffer.</span></span> <span data-ttu-id="32aee-243">Эта модель также позволяет устранить мерцание отображения и прерывание выполнения операций, которые могут наблюдаться при использовании системы с одним буфером.</span><span class="sxs-lookup"><span data-stu-id="32aee-243">This model also eliminates screen flicker and tearing that can be observed in a single buffered system.</span></span>

<span data-ttu-id="32aee-244">Модель 5. "Пинг-понговые" буферы с использованием компоновки холстов:</span><span class="sxs-lookup"><span data-stu-id="32aee-244">Model 5) Ping-pong buffers with canvas compositing:</span></span>

!["Пинг-понговые" буферы с использованием компоновки холстов](./media/guix/user-guide/ping-pong-buffers-canvas-composting.png)

<span data-ttu-id="32aee-246">В модели 5 можно создать любое количество холстов с учетом ограничений доступной памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-246">In model 5, any number of canvases can be created, up to the limits of available memory.</span></span> <span data-ttu-id="32aee-247">Холсты можно накладывать друг на друга или смешивать в соответствии с настройками приложения, чтобы создать составной холст.</span><span class="sxs-lookup"><span data-stu-id="32aee-247">The canvases can be overlaid or blended together as defined by the application to create the canvas composite.</span></span> <span data-ttu-id="32aee-248">Если после операции обновления экрана создан составной элемент, активные и рабочие составные буферы переключаются в режим, идентичный стандартной архитектуре "пинг-понговых" буферов.</span><span class="sxs-lookup"><span data-stu-id="32aee-248">When a new composite is created after a screen refresh operation, the active and working composite buffers are toggled in an operation identical to the standard ping-pong buffer architecture.</span></span> <span data-ttu-id="32aee-249">В модели 5 добавляется возможность выполнения операций исчезания и смешения отображения экрана. При этом выполняется смешение холстов в составной элемент окончательных выходных данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-249">Model 5 adds the ability to perform screen fade and blending operations by blending the canvases into the final output composite.</span></span>

<span data-ttu-id="32aee-250">Модель 6. Компоновка холстов с использованием внешнего устройства GRAM:</span><span class="sxs-lookup"><span data-stu-id="32aee-250">Model 6) Canvas compositing with external GRAM:</span></span>

![Компоновка холстов с использованием внешнего устройства GRAM](./media/guix/user-guide/canvas-compositing-external-gram.png)

<span data-ttu-id="32aee-252">Модель 6 незначительно отличается от модели 5. Для нее требуется только один составной буфер, который передается во внешнее устройство GRAM.</span><span class="sxs-lookup"><span data-stu-id="32aee-252">Model 6 is a slight variation on Model 5, in which only one composite buffer is required and the composite buffer is then transferred to external GRAM.</span></span> <span data-ttu-id="32aee-253">Эта модель также поддерживает полное смешение отображений экрана и их наложение друг на друга.</span><span class="sxs-lookup"><span data-stu-id="32aee-253">This model also supports full screen blending and overlays.</span></span>

## <a name="string-encoding"></a><span data-ttu-id="32aee-254">Кодирование строк</span><span class="sxs-lookup"><span data-stu-id="32aee-254">String Encoding</span></span> 

<span data-ttu-id="32aee-255">GUIX по умолчанию поддерживает кодирование строк в формате UTF8.</span><span class="sxs-lookup"><span data-stu-id="32aee-255">GUIX by default supports UTF8 format string encoding.</span></span> <span data-ttu-id="32aee-256">Поддержку кодирования строк в формате UTF8 можно отключить, определив **GX_DISABLE_UTF8_SUPPORT** в файле заголовка ***gx_user.h***.</span><span class="sxs-lookup"><span data-stu-id="32aee-256">Support for UTF8 string encoding can be disabled by defining **GX_DISABLE_UTF8_SUPPORT** in the ***gx_user.h*** header file.</span></span> <span data-ttu-id="32aee-257">Если кодирование в формате UTF8 отключено, GUIX использует внутренним образом только стандартное 8-разрядное кодирование ASCII и кодировку символов кодовой страницы Latin-1.</span><span class="sxs-lookup"><span data-stu-id="32aee-257">If UTF8 encoding is disabled, GUIX will internally use only standard 8-bit ASCII plus Latin-1 code page character encoding.</span></span> <span data-ttu-id="32aee-258">В результате отключения кодирования строк в формате UTF8 используется немного меньший объем занимаемой памяти библиотеки GUIX и незначительно ускоряются операции среды выполнения для функций обработки строк и отрисовки текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-258">Disabling UTF8 string encoding results in a slightly smaller GUIX library footprint and slightly faster runtime execution of string handling and text drawing functions.</span></span>

<span data-ttu-id="32aee-259">Кодирование строк в формате UTF8 имеет следующие признаки:</span><span class="sxs-lookup"><span data-stu-id="32aee-259">UTF8 string encoding has the following traits:</span></span>

  - <span data-ttu-id="32aee-260">Для строк ASCII необходимо не больше дискового пространства, чем для стандартного 7-разрядного кодирования ASCII.</span><span class="sxs-lookup"><span data-stu-id="32aee-260">ASCII strings take no more storage space than standard 7-bit ASCII encoding.</span></span>

  - <span data-ttu-id="32aee-261">Большинство строковых функций ANSI-C поддерживают кодирование строк в формате UTF8 без модификации.</span><span class="sxs-lookup"><span data-stu-id="32aee-261">Most ANSI-C string functions work with UTF8 string encoding without modification.</span></span>

<span data-ttu-id="32aee-262">С помощью кодирования строк UTF8 можно представить любые активные кодировки, в том числе Кандзи.</span><span class="sxs-lookup"><span data-stu-id="32aee-262">All active character sets in the world, including Kanji character sets, can be represented using UTF8 string encoding.</span></span>

### <a name="static-and-dynamic-strings"></a><span data-ttu-id="32aee-263">Статические и динамические строки</span><span class="sxs-lookup"><span data-stu-id="32aee-263">Static and Dynamic Strings</span></span> 

<span data-ttu-id="32aee-264">Строки, назначенные для мини-приложений GUIX, которые поддерживают отображение текста, могут быть статически определенными строковыми константами (обычно помещаются в постоянное хранилище в качестве таблицы строк GUIX, как описано ниже) или динамически определенными строками (строки, созданные во время выполнения с помощью таких служб, как ***sprintf** _ или _*_gx_utility_ltoa_\*\*).</span><span class="sxs-lookup"><span data-stu-id="32aee-264">The strings assigned to your GUIX widgets which support text display can be statically defined string constants, which are normally placed in constant storage as part of the GUIX String table described below, and dynamically defined strings, which are strings generated at runtime using services such as ***sprintf** _ or _*_gx_utility_ltoa_\*\*.</span></span>

<span data-ttu-id="32aee-265">Примерами динамических строк может быть значение, отображаемое в виде числа в мини-приложении для запросов GUIX, или строка даты и времени, динамически форматируемая в зависимости от расположения пользователя и настроек формата.</span><span class="sxs-lookup"><span data-stu-id="32aee-265">Examples of dynamic strings might include a value displayed as a number within a GUIX prompt widget, or a “time / date” string which is dynamically formatted based on the user’s location and format preferences.</span></span> <span data-ttu-id="32aee-266">При создании строк в среде выполнения, которые будут назначены мини-приложениям GUIX (например, **GX_PROMPT** или **GX_TEXT_BUTTON**), необходимо либо статически выделить хранилище для этих строк, созданных в среде выполнения (т. е.</span><span class="sxs-lookup"><span data-stu-id="32aee-266">If you create strings at runtime which will be assigned to GUIX widgets such as **GX_PROMPT** or **GX_TEXT_BUTTON widgets**, you must choose to either statically allocate the storage for these runtime generated strings (i.e</span></span>
<span data-ttu-id="32aee-267">глобальных массивов символов), либо определить и установить функцию выделения динамической памяти, а также использовать стиль **GX_STYLE_TEXT_COPY**. При этом мини-приложения получают команду создать частную копию назначенных текстовых строк.</span><span class="sxs-lookup"><span data-stu-id="32aee-267">global character arrays), or you can define and install a dynamic memory allocator function and use the **GX_STYLE_TEXT_COPY** style, which instructs those widgets to create a private copy of text strings assigned.</span></span>

<span data-ttu-id="32aee-268">Использование временного хранилища (например, автоматического массива символов) для хранения динамически созданной строки и последующего назначения этой строки мини-приложению, не имеющему стиля **GX_STYLE_TEXT_COPY**, считается ошибкой программирования.</span><span class="sxs-lookup"><span data-stu-id="32aee-268">It is a programming error to use temporary storage, such as an automatic character array, to hold a dynamically generated string and then assign this string to a widget that does not have the **GX_STYLE_TEXT_COPY** style.</span></span> <span data-ttu-id="32aee-269">Если этот стиль не включен, мини-приложение просто копирует соответствующий указатель строки. При этом данные строк должны быть статически выделены. В противном случае указатель строки мини-приложения указывает на лишние данные, что приводят к непредсказуемым результатам.</span><span class="sxs-lookup"><span data-stu-id="32aee-269">When this style is not enabled, the widget simply copies the provided string pointer, and the string data must be statically allocated or the widget string pointer will likely end up pointing at garbage data producing unpredictable results.</span></span>

### <a name="passing-gx_string-arguments"></a><span data-ttu-id="32aee-270">Передача аргументов GX_STRING</span><span class="sxs-lookup"><span data-stu-id="32aee-270">Passing GX_STRING arguments</span></span> 

<span data-ttu-id="32aee-271">Функции API GUIX, которые принимают параметр GX_STRING, всегда проверяют, соответствует ли длина строки, которую указывает поле **GX_STRING.gx_string_ptr**, значению поля **GX_STRING.gx_string_length**.</span><span class="sxs-lookup"><span data-stu-id="32aee-271">The GUIX API functions which accept a GX_STRING parameter always verify that the length of the string pointed to by the **GX_STRING.gx_string_ptr** field match the value of the **GX_STRING.gx_string_length** field.</span></span> <span data-ttu-id="32aee-272">Если два поля не согласованы, возвращается ошибка **GX_INVALID_STRING_LENGTH**, а вызванный API возвращается обратно, не принимая назначение строки.</span><span class="sxs-lookup"><span data-stu-id="32aee-272">If the two fields are not consistent, a **GX_INVALID_STRING_LENGTH** error is returned and the API called returns without accepting the string assignment.</span></span>

<span data-ttu-id="32aee-273">Из соображений безопасности в программном обеспечении GUIX никогда внутренне не используются стандартные строковые функции C, такие как ***strlen** _ или _*_strcpy_\*\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-273">For safety considerations the GUIX software never internally uses the standard C string functions such as ***strlen** _ or _*_strcpy_\*\*.</span></span> <span data-ttu-id="32aee-274">Известно, что эти функции подвержены атакам злоумышленников во время динамического получения данных строк, что часто происходит в подключенных приложениях.</span><span class="sxs-lookup"><span data-stu-id="32aee-274">These functions have been known to be susceptible to malicious attacks when string data is acquired dynamically which is often the case with connected applications.</span></span>

<span data-ttu-id="32aee-275">В выпусках библиотеки GUIX, предшествующих выпуску 5.6, определены функции API, которые принимали `GX_CONST GX_CHAR *text` в качестве параметра.</span><span class="sxs-lookup"><span data-stu-id="32aee-275">GUIX library releases prior to release 5.6 defined API functions which accepted (`GX_CONST GX_CHAR *text`) as a parameter.</span></span> <span data-ttu-id="32aee-276">Эти функции (по-прежнему поддерживаются для обратной совместимости) устарели и заменены предпочтительными функциями API, которые принимают `GX_CONST GX_STRING *string` в качестве входного параметра.</span><span class="sxs-lookup"><span data-stu-id="32aee-276">These functions, while still supported for backwards compatibility, have been obsoleted and replaced by the preferred API functions which accept (`GX_CONST GX_STRING *string`) as an input parameter.</span></span>

<span data-ttu-id="32aee-277">По умолчанию включается нерекомендуемый API обработки текста, что позволяет успешно выполнять сборку всех ранее написанных приложений с использованием последних обновлений для библиотеки GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-277">By default, the deprecated text handling API is enabled allowing all previously written applications to build cleanly with the latest updates to the GUIX library.</span></span> <span data-ttu-id="32aee-278">Чтобы отключить нерекомендуемый API обработки текста, необходимо добавить определение **GX_DISABLE_DEPRECATED_STRING_API** в файл заголовка **_gx_user.h_ *_. Все новые приложения должны определить _* GX_DISABLE_DEPRECATED_STRING_API** и использовать только функции API замены.</span><span class="sxs-lookup"><span data-stu-id="32aee-278">To disable the the deprecated text handling API, the definition **GX_DISABLE_DEPRECATED_STRING_API** should be added to the **_gx_user.h_*_ header file. All new applications should define _\* GX_DISABLE_DEPRECATED_STRING_API*\* and should use only the replacement API functions.</span></span> <span data-ttu-id="32aee-279">Во всех выходных файлах, созданных в GUIX Studio для выпуска библиотеки GUIX версии 5.6 или более поздней, используются только функции API для замены.</span><span class="sxs-lookup"><span data-stu-id="32aee-279">All output files generated by GUIX Studio for GUIX library version release 5.6 or later will utilize only the replacement API functions.</span></span>

<span data-ttu-id="32aee-280">В указанной ниже таблице перечислены имена устаревших и новых функций API для замены.</span><span class="sxs-lookup"><span data-stu-id="32aee-280">The following table lists the deprecated and newly defined replacement API function names:</span></span>

| <span data-ttu-id="32aee-281">**Имя нерекомендуемой функции**</span><span class="sxs-lookup"><span data-stu-id="32aee-281">**Deprecated Function Name**</span></span>              | <span data-ttu-id="32aee-282">**Заменено на**</span><span class="sxs-lookup"><span data-stu-id="32aee-282">**Replaced With**</span></span>                              |
| ------------------------------------------ | ----------------------------------------------- |
| <span data-ttu-id="32aee-283">gx_binres_language_table_load</span><span class="sxs-lookup"><span data-stu-id="32aee-283">gx_binres_language_table_load</span></span>          | <span data-ttu-id="32aee-284">gx_binres_language_table_load_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-284">gx_binres_language_table_load_ext</span></span>          |
| <span data-ttu-id="32aee-285">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-285">gx_canvas_rotated_text_draw</span></span>            | <span data-ttu-id="32aee-286">gx_canvas_rotated_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-286">gx_canvas_rotated_text_draw_ext</span></span>            |
| <span data-ttu-id="32aee-287">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-287">gx_canvas_text_draw</span></span>                     | <span data-ttu-id="32aee-288">gx_canvas_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-288">gx_canvas_text_draw_ext</span></span>                     |
| <span data-ttu-id="32aee-289">gx_context_string_get</span><span class="sxs-lookup"><span data-stu-id="32aee-289">gx_context_string_get</span></span>                   | <span data-ttu-id="32aee-290">gx_context_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-290">gx_context_string_get_ext</span></span>                   |
| <span data-ttu-id="32aee-291">gx_display_language_table_get</span><span class="sxs-lookup"><span data-stu-id="32aee-291">gx_display_language_table_get</span></span>          | <span data-ttu-id="32aee-292">gx_display_language_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-292">gx_display_language_table_get_ext</span></span>          |
| <span data-ttu-id="32aee-293">gx_display_language_table_set</span><span class="sxs-lookup"><span data-stu-id="32aee-293">gx_display_language_table_set</span></span>          | <span data-ttu-id="32aee-294">gx_display_language_table_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-294">gx_display_language_table_set_ext</span></span>          |
| <span data-ttu-id="32aee-295">gx_display_string_get</span><span class="sxs-lookup"><span data-stu-id="32aee-295">gx_display_string_get</span></span>                   | <span data-ttu-id="32aee-296">gx_display_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-296">gx_display_string_get_ext</span></span>                   |
| <span data-ttu-id="32aee-297">gx_display_string_table_get</span><span class="sxs-lookup"><span data-stu-id="32aee-297">gx_display_string_table_get</span></span>            | <span data-ttu-id="32aee-298">gx_display_string_table_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-298">gx_display_string_table_get_ext</span></span>            |
| <span data-ttu-id="32aee-299">gx_multi_line_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-299">gx_multi_line_text_button_text_set</span></span>   | <span data-ttu-id="32aee-300">gx_multi_line_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-300">gx_multi_line_text_button_text_set_ext</span></span>   |
| <span data-ttu-id="32aee-301">gx_multi_line_text_input_char_insert</span><span class="sxs-lookup"><span data-stu-id="32aee-301">gx_multi_line_text_input_char_insert</span></span> | <span data-ttu-id="32aee-302">gx_multi_line_text_input_char_insert_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-302">gx_multi_line_text_input_char_insert_ext</span></span> |
| <span data-ttu-id="32aee-303">gx_multi_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-303">gx_multi_line_text_input_text_set</span></span>    | <span data-ttu-id="32aee-304">gx_multi_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-304">gx_multi_line_text_input_text_set_ext</span></span>    |
| <span data-ttu-id="32aee-305">gx_multi_line_text_view_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-305">gx_multi_line_text_view_text_set</span></span>     | <span data-ttu-id="32aee-306">gx_multi_line_text_view_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-306">gx_multi_line_text_view_text_set_ext</span></span>     |
| <span data-ttu-id="32aee-307">gx_prompt_text_get</span><span class="sxs-lookup"><span data-stu-id="32aee-307">gx_prompt_text_get</span></span>                      | <span data-ttu-id="32aee-308">gx_prompt_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-308">gx_prompt_text_get_ext</span></span>                      |
| <span data-ttu-id="32aee-309">gx_prompt_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-309">gx_prompt_text_set</span></span>                      | <span data-ttu-id="32aee-310">gx_prompt_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-310">gx_prompt_text_set_ext</span></span>                      |
| <span data-ttu-id="32aee-311">gx_single_line_text_input_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-311">gx_single_line_text_input_text_set</span></span>   | <span data-ttu-id="32aee-312">gx_single_line_text_input_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-312">gx_single_line_text_input_text_set_ext</span></span>   |
| <span data-ttu-id="32aee-313">gx_system_string_width_get</span><span class="sxs-lookup"><span data-stu-id="32aee-313">gx_system_string_width_get</span></span>             | <span data-ttu-id="32aee-314">gx_system_string_width_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-314">gx_system_string_width_get_ext</span></span>             |
| <span data-ttu-id="32aee-315">gx_system_version_string_get</span><span class="sxs-lookup"><span data-stu-id="32aee-315">gx_system_version_string_get</span></span>           | <span data-ttu-id="32aee-316">gx_system_version_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-316">gx_system_version_string_get_ext</span></span>           |
| <span data-ttu-id="32aee-317">gx_text_button_text_get</span><span class="sxs-lookup"><span data-stu-id="32aee-317">gx_text_button_text_get</span></span>                | <span data-ttu-id="32aee-318">gx_text_button_text_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-318">gx_text_button_text_get_ext</span></span>                |
| <span data-ttu-id="32aee-319">gx_text_button_text_set</span><span class="sxs-lookup"><span data-stu-id="32aee-319">gx_text_button_text_set</span></span>                | <span data-ttu-id="32aee-320">gx_text_button_text_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-320">gx_text_button_text_set_ext</span></span>                |
| <span data-ttu-id="32aee-321">gx_text_scroll_wheel_callback_set</span><span class="sxs-lookup"><span data-stu-id="32aee-321">gx_text_scroll_wheel_callback_set</span></span>     | <span data-ttu-id="32aee-322">gx_text_scroll_wheel_callback_set_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-322">gx_text_scroll_wheel_callback_set_ext</span></span>     |
| <span data-ttu-id="32aee-323">gx_utility_string_to_alphamap</span><span class="sxs-lookup"><span data-stu-id="32aee-323">gx_utility_string_to_alphamap</span></span>          | <span data-ttu-id="32aee-324">gx_utility_string_to_alphamap_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-324">gx_utility_string_to_alphamap_ext</span></span>          |
| <span data-ttu-id="32aee-325">gx_widget_string_get</span><span class="sxs-lookup"><span data-stu-id="32aee-325">gx_widget_string_get</span></span>                    | <span data-ttu-id="32aee-326">gx_widget_string_get_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-326">gx_widget_string_get_ext</span></span>                    |
| <span data-ttu-id="32aee-327">gx_widget_text_blend</span><span class="sxs-lookup"><span data-stu-id="32aee-327">gx_widget_text_blend</span></span>                    | <span data-ttu-id="32aee-328">gx_widget_text_blend_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-328">gx_widget_text_blend_ext</span></span>                    |
| <span data-ttu-id="32aee-329">gx_widget_text_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-329">gx_widget_text_draw</span></span>                     | <span data-ttu-id="32aee-330">gx_widget_text_draw_ext</span><span class="sxs-lookup"><span data-stu-id="32aee-330">gx_widget_text_draw_ext</span></span>                     |

### <a name="guix-string-table"></a><span data-ttu-id="32aee-331">Таблица строк GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-331">GUIX String Table</span></span> 

<span data-ttu-id="32aee-332">Таблица строк и ресурсы строк GUIX регистрируются с использованием экземпляра дисплея GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-332">The GUIX string table and string resources are registered with a GUIX display instance.</span></span>

<span data-ttu-id="32aee-333">Для каждого дисплея в системе с несколькими дисплеями предусмотрена собственная строковая таблица и можно использовать собственный выбранный язык. Другие типы ресурсов GUIX (цвета, шрифты и пиксельные карты) также хранятся в компоненте дисплея GUIX, так как эти типы ресурсов уникальны для каждого формата цвета и глубины цвета отображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-333">Each display in a multi-display system has its own string table, and each display can run in its own selected language.The other GUIX resource types (colors, fonts, and pixelmaps) are also maintained by the GUIX Display component, since these resource types are specific to each display color format and color depth.</span></span>

<span data-ttu-id="32aee-334">Хотя таблицу строк приложения можно создать вручную, чаще всего таблица строк отображения определяется с помощью приложения GUIX Studio как часть файла ресурсов проекта.</span><span class="sxs-lookup"><span data-stu-id="32aee-334">While you can manually create your application string table, most often the display string table is defined by the GUIX Studio application as part of your project resource file.</span></span> <span data-ttu-id="32aee-335">Доступные языки также определяются в файле заголовка ресурса.</span><span class="sxs-lookup"><span data-stu-id="32aee-335">The available languages are also defined in the resource header file.</span></span> <span data-ttu-id="32aee-336">Таблица строк отображения — это таблица с несколькими столбцами, содержащая указатели на строки приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-336">The display string table is a multi-column table of pointers to application strings.</span></span> <span data-ttu-id="32aee-337">Каждый столбец таблицы строк представляет один язык, поддерживаемый приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-337">Each column of the string table represents one language supported by the application.</span></span>
<span data-ttu-id="32aee-338">Если приложение поддерживает только один язык, например английский, в таблице строк будет только один столбец.</span><span class="sxs-lookup"><span data-stu-id="32aee-338">If your application supports only one language, for example English, then your string table will have only one column.</span></span> <span data-ttu-id="32aee-339">Поддержку других языков можно также добавить в любое время, не изменяя программное обеспечение приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-339">Still, you can add support for additional languages at any time without modifying your application software.</span></span>

<span data-ttu-id="32aee-340">Активная таблица строк назначается путем вызова функции API ***gx_display_string_table_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-340">The active string table is assigned by calling the ***gx_display_string_table_set*** API function.</span></span> <span data-ttu-id="32aee-341">Эта функция вызывается автоматически с помощью созданного в GUIX Studio кода запуска, но ее также можно вызвать напрямую с помощью приложения, чтобы изменить активную таблицу строк.</span><span class="sxs-lookup"><span data-stu-id="32aee-341">This function is called automatically by the GUIX Studio generated startup code, but can also be called directly by the application to change the active string table.</span></span>

<span data-ttu-id="32aee-342">Активный язык назначается путем вызова функции API ***gx_display_active_language_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-342">The active language is assigned by calling the ***gx_display_active_language_set*** API function.</span></span> <span data-ttu-id="32aee-343">Эта функция определяет, какой столбец таблицы строк отображения является активным.</span><span class="sxs-lookup"><span data-stu-id="32aee-343">This function determines which column of the display string table is active.</span></span>

<span data-ttu-id="32aee-344">При вызове этой функции во все видимые мини-приложения GUIX отправляется событие **GX_EVENT_LANGUAGE_CHANGE**, что позволяет обновить их для отображения новых активных данных строк.</span><span class="sxs-lookup"><span data-stu-id="32aee-344">When this function is invoked, a **GX_EVENT_LANGUAGE_CHANGE** event is sent to all visible GUIX widgets, allowing them to update to display the newly active string data.</span></span>

<span data-ttu-id="32aee-345">Мини-приложения и программное обеспечение приложений разрешают статически определенные строки, используя значения идентификаторов строк и функции API ***gx_display_string_get_ext*** или ***gx_widget_string_get_ext***.</span><span class="sxs-lookup"><span data-stu-id="32aee-345">Widgets and application software resolve statically defined strings using string ID values and the ***gx_display_string_get_ext*** or ***gx_widget_string_get_ext*** API functions.</span></span> <span data-ttu-id="32aee-346">Эти функции возвращают элемент **GX_STRING**, связанный с соответствующим идентификатором строки и текущим активным языком.</span><span class="sxs-lookup"><span data-stu-id="32aee-346">These functions return the **GX_STRING** associated with a given string ID and the currently active language.</span></span>

### <a name="bi-directional-text-display"></a><span data-ttu-id="32aee-347">Двунаправленное отображение текста</span><span class="sxs-lookup"><span data-stu-id="32aee-347">Bi-directional Text Display</span></span> 

<span data-ttu-id="32aee-348">GUIX предусматривает две стратегии поддержки двунаправленного отображения текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-348">GUIX provide two strategies for bi-directional text support.</span></span>

<span data-ttu-id="32aee-349">Первая возможность — изменение порядка двунаправленного текста с помощью приложения GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-349">One option is to do bidi text reordering within the GUIX Studio application.</span></span> <span data-ttu-id="32aee-350">При использовании этой возможности GUIX Studio создает двунаправленный текст в выходном файле, используя соответствующий порядок отображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-350">Using this option GUIX Studio is responsible for generating bidi text to the output file in its display order.</span></span> <span data-ttu-id="32aee-351">Это решение никак не влияет на производительность среды выполнения, и для него не требуются никакие добавления в библиотеку среды выполнения GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-351">This solution has zero impact on the runtime performance and does not require any additions to the GUIX runtime library.</span></span> <span data-ttu-id="32aee-352">Чтобы с помощью GUIX Studio создать двунаправленные текстовые строки в порядке отображения, следует установить флажок **Generate Bidi Text in Display Order** (Создать двунаправленный текст в порядке отображения) в диалоговом окне конфигурации языков GUIX Studio:</span><span class="sxs-lookup"><span data-stu-id="32aee-352">To allow GUIX Studio to generate displayorder bidi text strings, you should select the **Generate Bidi Text in Display Order** checkbox in the GUIX Studio language configuration dialog:</span></span>

![Настройка языков](./media/guix/user-guide/configure-languages.png)

<span data-ttu-id="32aee-354">При выборе этих параметров в созданном файле ресурсов будут содержаться двунаправленные строки, созданные в порядке отображения. При этом в библиотеке среды выполнения GUIX не требуется выполнять дополнительную обработку.</span><span class="sxs-lookup"><span data-stu-id="32aee-354">With these options selected, the generated resource file will contain Bidi strings generated in display order, and no extra processing is required within the GUIX runtime library.</span></span>

<span data-ttu-id="32aee-355">Вторая возможность заключается в изменении порядка двунаправленного текста в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-355">The second option is to do bidi text reordering at runtime.</span></span> <span data-ttu-id="32aee-356">Эта возможность поддерживается для приложений, которым необходимо обрабатывать двунаправленные текстовые строки, определенные динамически и не созданные приложением GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-356">This option is supported for those applications that must handle bidi text string that are dynamically defined, and not generated by the GUIX Studio application.</span></span> <span data-ttu-id="32aee-357">В этом случае библиотека среды выполнения GUIX изменяет порядок двунаправленного текста перед рисованием каждой текстовой строки.</span><span class="sxs-lookup"><span data-stu-id="32aee-357">In this case the GUIX runtime library is responsible for reordering the bidi text before drawing each text string.</span></span> <span data-ttu-id="32aee-358">Это решение может сказаться на производительности среды выполнения и операциях памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-358">This solution has a runtime performance and memory impact.</span></span> <span data-ttu-id="32aee-359">Для процесса изменения порядка двунаправленного текста должен быть доступным достаточный объем динамической памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-359">Sufficient dynamic memory must be available for bidi text reordering process.</span></span> <span data-ttu-id="32aee-360">Для этого решения необходимо определить условный элемент GX_DYNAMIC_BIDI_TEXT_SUPPORT при создании библиотеки GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-360">This solution requires that the conditional GX_DYNAMIC_BIDI_TEXT_SUPPORT be defined when building the GUIX library.</span></span> <span data-ttu-id="32aee-361">Для включения или отключения поддержки двунаправленного текста в среде выполнения используются две функции API: ***gx_system_bidi_text_enable*** и ***gx_system_bidi_text_disable***.</span><span class="sxs-lookup"><span data-stu-id="32aee-361">Two API functions ***gx_system_bidi_text_enable*** and ***gx_system_bidi_text_disable*** are provided to enable/disable bidi text support at runtime.</span></span>

<span data-ttu-id="32aee-362">Для создания двунаправленного текста в порядке отображения не следует использовать обе возможности **GX_DYNAMIC_BIDI_TEXT_SUPPORT** и настраивать GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-362">You should not use both **GX_DYNAMIC_BIDI_TEXT_SUPPORT** and configure GUIX Studio to generate Bidi text in display order.</span></span> <span data-ttu-id="32aee-363">Для обработки двунаправленной текстовой строки необходимо выбрать какую-то одну стратегию из двух.</span><span class="sxs-lookup"><span data-stu-id="32aee-363">You must select one strategy or the other for bidi text string handling.</span></span>

## <a name="memory-usage"></a><span data-ttu-id="32aee-364">Использование памяти</span><span class="sxs-lookup"><span data-stu-id="32aee-364">Memory Usage</span></span> 

<span data-ttu-id="32aee-365">GUIX размещается в памяти вместе с приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-365">GUIX resides along with the application program.</span></span> <span data-ttu-id="32aee-366">В результате использование статической памяти (или фиксированной памяти) в GUIX зависит от используемых средств разработки (например, компилятора, компоновщика и указателя).</span><span class="sxs-lookup"><span data-stu-id="32aee-366">As a result, the static memory (or fixed memory) usage of GUIX is determined by the development tools; e.g., the compiler, linker, and locator.</span></span> <span data-ttu-id="32aee-367">Использование динамической памяти (или памяти во время выполнения) контролируется непосредственно приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-367">Dynamic memory (or run-time memory) usage is under direct control of the application.</span></span>

### <a name="static-memory-usage"></a><span data-ttu-id="32aee-368">Использование статической памяти</span><span class="sxs-lookup"><span data-stu-id="32aee-368">Static Memory Usage</span></span> 

<span data-ttu-id="32aee-369">Большинство средств разработки разделяют представление программы приложения на пять основных областей: *инструкция*, *константа*, *инициализированные данные*, *неинициализированные данные* и *стек потоков GUIX*.</span><span class="sxs-lookup"><span data-stu-id="32aee-369">Most of the development tools divide the application program image into five basic areas: *instruction*, *constant*, *initialized data*, *uninitialized data*, and the *GUIX thread stack*.</span></span>  <span data-ttu-id="32aee-370">На рисунке ниже показана одна возможная структура этих областей памяти:</span><span class="sxs-lookup"><span data-stu-id="32aee-370">The figure below demonstrates one possible layout of these memory areas:</span></span>

![Организация памяти](./media/guix/user-guide/memory-area-example.png)

<span data-ttu-id="32aee-372">Важно учитывать, что это только пример.</span><span class="sxs-lookup"><span data-stu-id="32aee-372">It is important to understand that this only an example.</span></span> <span data-ttu-id="32aee-373">Структура фактической статической памяти зависит от используемых процессора, средств разработки, базового оборудования и самого приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-373">The actual static memory layout is specific to the processor, development tools, underlying hardware, and the application itself.</span></span>

<span data-ttu-id="32aee-374">В области инструкций содержатся все инструкции процессора для программы.</span><span class="sxs-lookup"><span data-stu-id="32aee-374">The instruction area contains all of the program’s processor instructions.</span></span> <span data-ttu-id="32aee-375">Эта область часто расположена в ПЗУ.</span><span class="sxs-lookup"><span data-stu-id="32aee-375">This area is often located in ROM.</span></span>

<span data-ttu-id="32aee-376">Область констант содержит различные скомпилированные константы, которые в GUIX имеют параметры по умолчанию и все ресурсы приложения (изображения, строки, шрифты и цвета).</span><span class="sxs-lookup"><span data-stu-id="32aee-376">The constant area contains various compiled constants, which in GUIX contains default settings and all application resources (images, strings, fonts, and colors).</span></span> <span data-ttu-id="32aee-377">Кроме того, эта область содержит начальную копию области инициализированных данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-377">In addition, this area contains the “initial copy” of the initialized data area.</span></span> <span data-ttu-id="32aee-378">В процессе инициализации в компиляторе эта часть области констант используется для настройки глобальных инициализированных данных в ОЗУ.</span><span class="sxs-lookup"><span data-stu-id="32aee-378">During the compiler’s initialization process, this portion of the constant area is used to set up the global initialized data in RAM.</span></span> <span data-ttu-id="32aee-379">Область констант обычно является самой большой, следует за областью инструкций и часто размещается в ПЗУ.</span><span class="sxs-lookup"><span data-stu-id="32aee-379">The constant area is typically the largest and usually follows the instruction area and is often located in ROM.</span></span>

<span data-ttu-id="32aee-380">Для пиксельных карт и шрифтов GUIX обычно требуются большие объемы постоянного хранилища данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-380">GUIX pixelmaps and fonts typically require large amounts of constant data storage.</span></span> <span data-ttu-id="32aee-381">Эти области с большим объемом статических данных обычно хранятся в ПЗУ или FLASH.</span><span class="sxs-lookup"><span data-stu-id="32aee-381">These large static data areas are normally kept in ROM or FLASH.</span></span>

<span data-ttu-id="32aee-382">Стек потока GUIX определяется в области неинициализированных данных (как глобальная переменная) в файле ***gx_system.h*** следующим образом:</span><span class="sxs-lookup"><span data-stu-id="32aee-382">The GUIX thread stack is defined within the uninitialized data area (as a global variable) in ***gx_system.h*** file as follows:</span></span>

```C
_gx_system_thread_stack[GX_THREAD_STACK_SIZE];
```

<span data-ttu-id="32aee-383">Элемент **GX_THREAD_STACK_SIZE** определен в **_gx_port.h_**, но может быть переопределен в приложении путем определения этого символа в файле заголовка ***gx_user.h*** или с помощью параметров проекта либо параметров командной строки.</span><span class="sxs-lookup"><span data-stu-id="32aee-383">**GX_THREAD_STACK_SIZE** is defined in **_gx_port.h_**, but may be overridden by the application by defining this symbol in the ***gx_user.h*** header file or via project options or command line parameters.</span></span> <span data-ttu-id="32aee-384">Размер стека должен быть достаточным для обработки самых сложных событий и вложенных вызовов рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-384">The stack size must be large enough to handle the worst case event handling and nested drawing calls.</span></span>

### <a name="dynamic-memory-usage"></a><span data-ttu-id="32aee-385">Использование динамической памяти</span><span class="sxs-lookup"><span data-stu-id="32aee-385">Dynamic Memory Usage</span></span> 

<span data-ttu-id="32aee-386">Как упоминалось ранее, использование динамической памяти контролируется непосредственно приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-386">As mentioned before, dynamic memory usage is under direct control of the application.</span></span> <span data-ttu-id="32aee-387">Блоки управления и память, связанные с холстами и т. д., можно разместить в любом месте в целевой области памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-387">Control blocks and memory associated with canvases, etc. can be placed anywhere in the target’s memory space.</span></span> <span data-ttu-id="32aee-388">Это важная возможность, так как она упрощает использование различных типов физической памяти во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-388">This is an important feature because it facilitates easy utilization of different types of physical memory – at run-time.</span></span>

<span data-ttu-id="32aee-389">Например, предположим, что целевое аппаратное окружение использует как быстродействующую, так и медленнодействующую память.</span><span class="sxs-lookup"><span data-stu-id="32aee-389">For example, suppose a target hardware environment has both fast memory and slow memory.</span></span> <span data-ttu-id="32aee-390">Если приложению требуется дополнительная производительность для рисования, память холста можно поместить в область быстродействующей памяти, чтобы повысить производительность.</span><span class="sxs-lookup"><span data-stu-id="32aee-390">If the application needs extra performance for drawing, the canvas memory can be explicitly placed in the high-speed memory area for best performance.</span></span>

<span data-ttu-id="32aee-391">Для нескольких необязательных служб и возможностей GUIX требуется механизм распределения динамической памяти среды выполнения, который обычно называется кучей.</span><span class="sxs-lookup"><span data-stu-id="32aee-391">Several optional GUIX services and features require a runtime dynamic memory allocation mechanism, commonly referred to as a heap.</span></span> <span data-ttu-id="32aee-392">Эти службы и возможности являются необязательными, и многие приложения GUIX не используют кучу и не определяют механизм распределения памяти среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-392">These services and features are completely optional, and many GUIX applications do not use any heap and do not define a runtime memory allocation mechanism.</span></span>

<span data-ttu-id="32aee-393">Если планируется использовать службы, для которых требуется распределение памяти среды выполнения, необходимо установить функции, которые GUIX будет вызывать, когда понадобится динамически распределить или освободить память.</span><span class="sxs-lookup"><span data-stu-id="32aee-393">If you will be using services which require runtime memory allocation, you must install functions which GUIX will call when memory must be dynamically allocated or freed.</span></span> <span data-ttu-id="32aee-394">Эти функции можно реализовать по своему усмотрению. Даже в данном случае расположение пула динамической памяти контролируется приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-394">You can implement these functions as you prefer, so that even in this case the location of the dynamic memory pool is under application control.</span></span> <span data-ttu-id="32aee-395">Для установки поддержки распределения динамической памяти приложению необходимо вызвать службу API ***gx_system_memory_allocator_set*** во время запуска программы, чтобы определить службы распределения и освобождения памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-395">To install support for dynamic memory allocation, the application should invoke the API service ***gx_system_memory_allocator_set*** during program startup to define your memory allocation and memory free services.</span></span> <span data-ttu-id="32aee-396">Полный пример см. в документации по этому API.</span><span class="sxs-lookup"><span data-stu-id="32aee-396">Refer to the documentation of this API for a complete example.</span></span>

<span data-ttu-id="32aee-397">К службам GUIX, для которых необходимо использовать службу распределения и отмены распределения памяти, относятся:</span><span class="sxs-lookup"><span data-stu-id="32aee-397">GUIX services which require a runtime memory allocation and de-allocation service include:</span></span>

  - <span data-ttu-id="32aee-398">загрузка двоичных ресурсов из внешнего хранилища в среду выполнения GUIX;</span><span class="sxs-lookup"><span data-stu-id="32aee-398">Loading binary resources from external storage into the GUIX runtime environment.</span></span>

  - <span data-ttu-id="32aee-399">декодер изображений JPEG для среды выполнения программного обеспечения;</span><span class="sxs-lookup"><span data-stu-id="32aee-399">The software runtime jpeg image decoder.</span></span>

  - <span data-ttu-id="32aee-400">декодер изображений PNG для среды выполнения программного обеспечения;</span><span class="sxs-lookup"><span data-stu-id="32aee-400">The software runtime png image decoder.</span></span>

  - <span data-ttu-id="32aee-401">использование текстовых мини-приложений с GX_STYLE_TEXT_COPY;</span><span class="sxs-lookup"><span data-stu-id="32aee-401">Using text widgets with GX_STYLE_TEXT_COPY.</span></span>

  - <span data-ttu-id="32aee-402">служебные функции изменения размера и поворота пиксельной карты для среды выполнения;</span><span class="sxs-lookup"><span data-stu-id="32aee-402">Runtime pixemap resize and rotation utility functions.</span></span>
  - <span data-ttu-id="32aee-403">выделение блока управления экраном и мини-приложением для среды выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-403">Runtime screen and widget control block allocation.</span></span>

<span data-ttu-id="32aee-404">В небольших приложениях ресурсы GUIX обычно компилируются и статически связываются как часть образа приложения. При этом установка двоичных ресурсов не требуется.</span><span class="sxs-lookup"><span data-stu-id="32aee-404">For smaller applications, GUIX resources are usually compiled and statically linked as part of the application image, and binary resource installation is not required.</span></span> <span data-ttu-id="32aee-405">Двоичные ресурсы позволяют приложению устанавливать в среде выполнения ресурсы (шрифты, изображения, языки), загруженные из определенного места хранения, например из устройства флэш-памяти или с помощью URL-адреса.</span><span class="sxs-lookup"><span data-stu-id="32aee-405">Binary resources allow an application to install resources (fonts, images, languages) at runtime loaded from some storage location, such as a flash drive or a URL.</span></span>

<span data-ttu-id="32aee-406">Декодеры JPEG и PNG для среды выполнения являются дополнительными компонентами.</span><span class="sxs-lookup"><span data-stu-id="32aee-406">The runtime jpeg and png decoders are optional components.</span></span> <span data-ttu-id="32aee-407">Большинство приложений GUIX позволяют средству GUIX Studio предварительно декодировать все необходимые файлы изображений и хранить их как собственные ресурсы данных пиксельных карт GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-407">Most GUIX applications allow the GUIX Studio tool to pre-decode all required image files, and store them as proprietary GUIX Pixemap data resources.</span></span> <span data-ttu-id="32aee-408">Эти службы обеспечивают полноту возможностей приложений, которым требуется преобразование изображений JPEG и (или) PNG в формат пиксельных карт во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-408">These services are provided for completeness for those applications that require runtime conversion of jpeg and/or PNG images to pixelmap format.</span></span>

<span data-ttu-id="32aee-409">**GX_STYLE_TEXT_COPY** позволяет пользователю указать, что в конкретном мини-приложении или мини-приложениях будет храниться собственная частная копия динамически назначенного текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-409">**GX_STYLE_TEXT_COPY** allows the user to specify that a particular widget or widgets will keep it’s own private copy of dynamically assigned text.</span></span> <span data-ttu-id="32aee-410">Перед использованием этого параметра необходимо установить механизм распределения памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-410">Using this option requires that the memory allocation mechanism be installed prior to use.</span></span> <span data-ttu-id="32aee-411">Если этот флаг стиля **<span class="underline">не</span>** указан при создании мини-приложения текстового типа, приложение должно выделить статические области хранения для всех динамически созданных и назначенных текстовых строк.</span><span class="sxs-lookup"><span data-stu-id="32aee-411">If this style flag is **<span class="underline">not</span>** provided when a text type widget is created, the application must allocate static storage areas for all dynamically created and assigned text strings.</span></span> <span data-ttu-id="32aee-412">В этом случае автоматические переменные не следует использовать для хранения данных строк, созданных в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-412">Automatic variables should not be used in this case to hold runtime generated string data.</span></span> <span data-ttu-id="32aee-413">Если включен стиль **GX_STYLE_TEXT_COPY**, для хранения строковых данных, назначенных мини-приложениям GUIX, можно использовать автоматические переменные, так как каждое мини-приложение создает собственную копию назначенного текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-413">If the **GX_STYLE_TEXT_COPY** style is enabled, automatic variables may be used to hold string data assigned to GUIX widgets, since each widget will create its own copy of the assigned text.</span></span>

<span data-ttu-id="32aee-414">Служебные функции изменения размера и поворота пиксельных карт возвращают полученную преобразованную пиксельную карту как новую пиксельную карту, доступную для приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-414">Pixelmap resize and rotation utility functions return the resulting translated pixelmap as a new pixelmap available to the application.</span></span>
<span data-ttu-id="32aee-415">Для хранения блоков данных пиксельных карт, созданных в среде выполнения (если соответствующие службы используются), необходим достаточный объем динамической памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-415">Sufficient dynamic memory must be available to hold these runtime generated pixelmap data blocks if these services are used.</span></span>

<span data-ttu-id="32aee-416">Наконец, блоки управления для экранов и мини-приложений GUIX можно выделить статически или динамически.</span><span class="sxs-lookup"><span data-stu-id="32aee-416">Finally, the control blocks for the GUIX screens and widgets can be statically or dynamically allocated.</span></span> <span data-ttu-id="32aee-417">Как правило, в небольших приложениях все экраны приложения создаются во время запуска программы, а также используются статически выделенные блоки управления.</span><span class="sxs-lookup"><span data-stu-id="32aee-417">For smaller applications, it is common to create all application screens during program startup and use statically allocated control blocks.</span></span> <span data-ttu-id="32aee-418">В больших приложениях, как правило, элементы управления экрана и дочерних мини-приложений создаются динамически по мере необходимости.</span><span class="sxs-lookup"><span data-stu-id="32aee-418">For large applications, it is common to create the screen and child widget controls dynamically on an as-needed bases.</span></span> <span data-ttu-id="32aee-419">Динамически выделенные блоки управления указываются путем установки флажка **Runtime Allocate** (Выделить во время выполнения) в представлении свойств GUIX Studio или путем передачи флага стиля **GX_STYLE_DYNAMICALLY_ALLOCATED** при создании мини-приложения с помощью стандартного API.</span><span class="sxs-lookup"><span data-stu-id="32aee-419">Dynamically allocated control blocks are specified by selecting the **Runtime Allocate** checkbox in the GUIX Studio properties view, or by passing in the style flag **GX_STYLE_DYNAMICALLY_ALLOCATED** when creating a widget via the standard API.</span></span> <span data-ttu-id="32aee-420">Для использования динамически выделенных блоков управления мини-приложений требуется определить службы распределения и отмены распределения памяти, как описано выше.</span><span class="sxs-lookup"><span data-stu-id="32aee-420">Using dynamically allocated widget control blocks requires that memory allocation and deallocation services are defined as described above.</span></span>

## <a name="guix-components"></a><span data-ttu-id="32aee-421">Компоненты GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-421">GUIX Components</span></span> 

<span data-ttu-id="32aee-422">API GUIX разделяются на несколько базовых групп, которые соответствуют фундаментальным компонентам системы GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-422">The GUIX APIs are divided and organized into several basic groups which correspond to fundamental components of the GUIX system.</span></span> <span data-ttu-id="32aee-423">К основным компонентам относятся:</span><span class="sxs-lookup"><span data-stu-id="32aee-423">The fundamental components include:</span></span>

| <span data-ttu-id="32aee-424">Компоненты</span><span class="sxs-lookup"><span data-stu-id="32aee-424">Components</span></span>  | <span data-ttu-id="32aee-425">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-425">Description</span></span>  |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="32aee-426">GX_SYSTEM</span><span class="sxs-lookup"><span data-stu-id="32aee-426">GX_SYSTEM</span></span>  | <span data-ttu-id="32aee-427">Системный компонент GUIX, отвечающий за инициализацию, события, таймеры, таблицы строк и управление видимой иерархией мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-427">The GUIX system component, responsible for initialization, events, timers, string tables, and visible widget hierarchy management.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="32aee-428">GX_CANVAS</span><span class="sxs-lookup"><span data-stu-id="32aee-428">GX_CANVAS</span></span>  | <span data-ttu-id="32aee-429">Область рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-429">A drawing area.</span></span> <span data-ttu-id="32aee-430">Холст может быть тонкой абстракцией аппаратного буфера кадров или чистым холстом памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-430">A Canvas can be a thin abstraction of the hardware frame buffer, or it might also be a pure memory canvas.</span></span> <span data-ttu-id="32aee-431">Тип холста определяется параметрами, передаваемыми в функцию API gx_canvas_create.</span><span class="sxs-lookup"><span data-stu-id="32aee-431">The canvas type is determined by parameters passed to the gx_canvas_create API function.</span></span>                                                                                                                                                                                   |
| <span data-ttu-id="32aee-432">GX_CONTEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-432">GX_CONTEXT</span></span> | <span data-ttu-id="32aee-433">Компонент контекста рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-433">The drawing context component.</span></span> <span data-ttu-id="32aee-434">Контекст рисования содержит сведения об экране, холсте, кисти и области обрезки для текущих операций рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-434">The drawing context contains information about the screen, canvas, and brush, and clipping area for the current drawing operations.</span></span>                                                                                                                                                                                                                                      |
| <span data-ttu-id="32aee-435">GX_DISPLAY</span><span class="sxs-lookup"><span data-stu-id="32aee-435">GX_DISPLAY</span></span> | <span data-ttu-id="32aee-436">Предоставляет API и реализации на уровне драйверов, позволяющие приложению и мини-приложениям GUIX выполнять рисование на холсте.</span><span class="sxs-lookup"><span data-stu-id="32aee-436">Provides the APIs and driver-level implementations to allow your application and the GUIX widgets to perform drawing on a canvas.</span></span> <span data-ttu-id="32aee-437">GX_DISPLAY реализован для соответствующего преобразования графики на каждом холсте с помощью необходимого цветового формата холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-437">GX_DISPLAY is implemented to correctly render graphics on each canvas using that canvas’ required color format.</span></span> <span data-ttu-id="32aee-438">Компонент GX_DISPLAY также управляет ресурсами (цветами, шрифтами и пиксельными картами) для мини-приложений при рисовании на холстах, связанных с каждым дисплеем.</span><span class="sxs-lookup"><span data-stu-id="32aee-438">The GX_DISPLAY component also manages the resources (colors, fonts, and pixelmaps) available to widgets drawing to canvases linked to each display.</span></span> |
| <span data-ttu-id="32aee-439">GX_WIDGET</span><span class="sxs-lookup"><span data-stu-id="32aee-439">GX_WIDGET</span></span>  | <span data-ttu-id="32aee-440">Базовый видимый объект мини-приложения и связанные API.</span><span class="sxs-lookup"><span data-stu-id="32aee-440">The basic visible widget object and associated APIs.</span></span> <span data-ttu-id="32aee-441">Все типы мини-приложений GUIX созданы на основе базового типа GX_WIDGET или являются его производными.</span><span class="sxs-lookup"><span data-stu-id="32aee-441">All GUIX widget types are based on or derived from the basic GX_WIDGET type.</span></span>                                                                                                                                                                                                                                                                      |
| <span data-ttu-id="32aee-442">GX_UTILITY</span><span class="sxs-lookup"><span data-stu-id="32aee-442">GX_UTILITY</span></span> | <span data-ttu-id="32aee-443">В эту группу входят служебные функции для работы с прямоугольниками, функции для преобразования строк и не соответствующие стандарту ANSI математические функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-443">Utility functions for working with rectangles, functions for string conversion, and non-ANSI mathematical functions are included in this group.</span></span>                                                                                                                                                                                                                                                         |

<span data-ttu-id="32aee-444">Помимо этих основных компонентов GUIX содержит API, уникальные для каждого типа мини-приложения в библиотеке.</span><span class="sxs-lookup"><span data-stu-id="32aee-444">In addition to these basic components, GUIX includes APIs unique to each type of widget provided in the library.</span></span> <span data-ttu-id="32aee-445">Эти API описаны в главе 4 этого руководства пользователя ("Описание служб GUIX").</span><span class="sxs-lookup"><span data-stu-id="32aee-445">These APIs are described in Chapter 4 of this User Guide, “Description of GUIX Services”.</span></span>

## <a name="guix-system-component"></a><span data-ttu-id="32aee-446">Системный компонент GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-446">GUIX System Component</span></span>

<span data-ttu-id="32aee-447">Системный компонент GUIX предоставляет несколько глобальных служб для приложения пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="32aee-447">The GUIX system component provides several services that are global to the UI application.</span></span> <span data-ttu-id="32aee-448">К этим службам относятся службы *инициализации, управления событиями, управления отображением, управления ресурсами, управления таймером* и *управления мини-приложениями*.</span><span class="sxs-lookup"><span data-stu-id="32aee-448">These services include: *initialization, event management, display management, resource management, timer management,* and *widget management*.</span></span> <span data-ttu-id="32aee-449">Каждая служба важна для организации работы элементов программы приложения. Эти службы более подробно описаны в указанных ниже подразделах.</span><span class="sxs-lookup"><span data-stu-id="32aee-449">Each service is essential to the organization of your application program, and these services are described in more detail in the following sub-sections.</span></span>

### <a name="initialization"></a><span data-ttu-id="32aee-450">Инициализация</span><span class="sxs-lookup"><span data-stu-id="32aee-450">Initialization</span></span> 

<span data-ttu-id="32aee-451">Инициализация GUIX выполняется в приложении путем вызова службы ***gx_system_initialize***, которая может быть вызвана приложением из подпрограммы ***tx_application_define*** ThreadX (контекст инициализации) или из потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-451">GUIX initialization is accomplished by the application calling the service ***gx_system_initialize***, which may be called by the application from the ThreadX ***tx_application_define*** routine (initialization context) or from application threads.</span></span> <span data-ttu-id="32aee-452">Функция ***gx_system_initialize*** инициализирует все глобальные структуры данных GUIX и создает системный мьютекс, очередь событий, таймер и поток GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-452">The ***gx_system_initialize*** function initializes all global GUIX data structures and creates the GUIX system mutex, event queue, timer, and thread.</span></span> <span data-ttu-id="32aee-453">После возвращения ***gx_system_initialize*** приложение может использовать GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-453">Once ***gx_system_initialize*** returns, the application can use GUIX.</span></span>

### <a name="thread-processing"></a><span data-ttu-id="32aee-454">Обработка потоков</span><span class="sxs-lookup"><span data-stu-id="32aee-454">Thread Processing</span></span> 

<span data-ttu-id="32aee-455">Внутренний поток GUIX, созданный во время инициализации, выполняет большую часть операций обработки в GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-455">The internal GUIX thread – created during initialization – is responsible for most of the processing in GUIX.</span></span> <span data-ttu-id="32aee-456">При обработке в этом потоке сначала завершается любая дополнительная инициализация, необходимая для базового драйвера дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-456">The processing in this thread first completes any additional initialization required by the underlying display driver.</span></span> <span data-ttu-id="32aee-457">После завершения этой процедуры поток GUIX входит в цикл, в котором сначала обрабатываются все события в очереди событий GUIX, а затем при необходимости обновляется экран.</span><span class="sxs-lookup"><span data-stu-id="32aee-457">Once this is complete, the GUIX thread enters a loop which first processes all events present in the GUIX event queue and then refreshes the screen if required.</span></span> <span data-ttu-id="32aee-458">При обновлении экрана выполняются необходимые функции рисования GUIX, исходя из того, что является видимым и помечено как "грязный" элемент, который необходимо перерисовать.</span><span class="sxs-lookup"><span data-stu-id="32aee-458">The screen refresh executes the necessary GUIX drawing functions, based on what is visible and has been marked as dirty meaning it needs to be redrawn.</span></span> <span data-ttu-id="32aee-459">Если событий нет и обновление дисплея не требуется, поток GUIX приостанавливает работу, ожидая прибытия следующего события GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-459">When there are no events and nothing left to refresh on the display, the GUIX thread will suspend, waiting for the next GUIX event to arrive.</span></span>

### <a name="rtos-binding"></a><span data-ttu-id="32aee-460">Привязка ОСРВ</span><span class="sxs-lookup"><span data-stu-id="32aee-460">RTOS Binding</span></span> 

<span data-ttu-id="32aee-461">Для системного компонента GUIX по умолчанию настроено использование операционной системы ThreadX в режиме реального времени для таких служб, как службы потоков, службы очередей событий и службы таймера.</span><span class="sxs-lookup"><span data-stu-id="32aee-461">The GUIX system component is by default configured to utilize the ThreadX real time operating system for services such as thread services, event queue services, and timer services.</span></span> <span data-ttu-id="32aee-462">GUIX можно легко перенести в другие операционные системы с помощью директивы препроцессора GX_DISABLE_THREADX_BINDING и путем повторной сборки библиотеки GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-462">GUIX can easily be ported to other operating systems by using the preprocessor directive GX_DISABLE_THREADX_BINDING and re-building the GUIX library.</span></span> <span data-ttu-id="32aee-463">В этом случае зависимости ThreadX удаляются из исходного кода GUIX, что позволяет разработчику приложения реализовать необходимые службы операционной системы с помощью ОСРВ целевой системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-463">This removes the ThreadX dependencies from the GUIX source code, and allows the application developer to implement the required operating system services using whatever RTOS is provided by the target system.</span></span> <span data-ttu-id="32aee-464">[Приложение F. Службы привязки ОСРВ для GUIX](appendix-f.md) содержит описание служб, которые необходимо реализовать для переноса GUIX в операционную систему, отличную от операционной системы ThreadX.</span><span class="sxs-lookup"><span data-stu-id="32aee-464">[Appendix F - GUIX RTOS Binding Services](appendix-f.md) describes the services that need to be implemented to port GUIX to an operating system other than the ThreadX operating system.</span></span>

### <a name="multithread-safety"></a><span data-ttu-id="32aee-465">Безопасность многопоточности</span><span class="sxs-lookup"><span data-stu-id="32aee-465">Multithread Safety</span></span> 

<span data-ttu-id="32aee-466">API GUIX доступен из контекста потока GUIX, а также других потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-466">The GUIX API is available from the GUIX thread context as well as other application threads.</span></span> <span data-ttu-id="32aee-467">Потоки приложения могут взаимодействовать с потоком GUIX через доступ к общим переменным, а также отправляя и получая данные событий и используя функции API GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-467">Application threads can interact with the GUIX thread by sending and receiving events, by access to shared variables, and through use of the GUIX API functions.</span></span> <span data-ttu-id="32aee-468">GUIX использует внутренний мьютекс ThreadX для защиты ресурсов с несколькими потоками.</span><span class="sxs-lookup"><span data-stu-id="32aee-468">GUIX uses an internal ThreadX mutex for multi-thread resource protection.</span></span> <span data-ttu-id="32aee-469">Кроме того, GUIX предотвращает изменение внутренней структуры видимых мини-приложений после начала операции обновления экрана.</span><span class="sxs-lookup"><span data-stu-id="32aee-469">In addition, GUIX prevents the internal structure of visible widgets from being modified once a screen refresh operation has begun.</span></span> <span data-ttu-id="32aee-470">API, которые могут изменить дерево видимых объектов, блокируются во время выполнения операций рисования и запускаются после завершения обновления экрана.</span><span class="sxs-lookup"><span data-stu-id="32aee-470">APIs which would modify the tree of visible objects are blocked while drawing operations are in progress, and released once the screen refresh is complete.</span></span>

### <a name="system-timers"></a><span data-ttu-id="32aee-471">Системные таймеры</span><span class="sxs-lookup"><span data-stu-id="32aee-471">System Timers</span></span> 

<span data-ttu-id="32aee-472">GUIX предоставляет для приложения периодические таймеры, которые часто используются для периодического обновления данных, отображаемых в окнах GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-472">GUIX provides the application with periodic timers, which are often used for periodic update of data displayed in GUIX windows.</span></span> <span data-ttu-id="32aee-473">Для этого используется периодический таймер ThreadX, который также позволяет реализовать эффекты GUIX на уровне системы, такие как исчезание или появление экрана и т. д.</span><span class="sxs-lookup"><span data-stu-id="32aee-473">This is accomplished via a ThreadX periodic timer, which is also used to perform GUIX system-level effects like screen fade in/out, etc.</span></span>

<span data-ttu-id="32aee-474">Приложение может создавать таймеры и использовать то же средство таймера, которое используется внутренним образом в GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-474">The application can create timers and utilize the same timer facility that is used internally by GUIX.</span></span> <span data-ttu-id="32aee-475">Разумеется, приложение может также создавать и использовать таймеры ThreadX, если это необходимо.</span><span class="sxs-lookup"><span data-stu-id="32aee-475">Of course the application can also directly create and use ThreadX timers if required.</span></span> <span data-ttu-id="32aee-476">Преимущество таймеров GUIX заключается в том, что они очень просты в использовании и предварительно настроены для работы в управляемой событиями системе обработки данных GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-476">The advantage of the GUIX timers is that they are very easy to use and are pre-configured to work within the GUIX event-driven processing system.</span></span>

<span data-ttu-id="32aee-477">Чтобы создать и запустить таймер GUIX, приложение должно вызвать функцию ***gx_system_timer_start***.</span><span class="sxs-lookup"><span data-stu-id="32aee-477">To create and start a GUIX timer, the application should invoke the function ***gx_system_timer_start***.</span></span> <span data-ttu-id="32aee-478">Параметры этой функции включают в себя указатель на вызывающее мини-приложение, идентификатор таймера (позволяющий одному мини-приложению запустить много таймеров), а также начальное значение и значение перепланирования времени ожидания.</span><span class="sxs-lookup"><span data-stu-id="32aee-478">The parameters to this function include a pointer to the calling widget, the timer id (allowing one widget to start many timers), and the initial and reschedule timeout values.</span></span> <span data-ttu-id="32aee-479">Если значение перепланирования времени ожидания равно 0, таймер выполняется только один раз и удаляется из списка активных таймеров по истечении срока его действия.</span><span class="sxs-lookup"><span data-stu-id="32aee-479">If the reschedule timeout value is 0, the timer will only run one time and will delete itself from the active timer list once it expires.</span></span>

<span data-ttu-id="32aee-480">После запуска таймер GUIX отправляет события GX_EVENT_TIMEOUT владельцу таймера один раз или периодически — в зависимости от значения перепланирования таймера.</span><span class="sxs-lookup"><span data-stu-id="32aee-480">Once started, the GUIX timer will send GX_EVENT_TIMEOUT events to the timer owner, either once or periodically depending on the timer reschedule value.</span></span> <span data-ttu-id="32aee-481">Таймер GUIX можно остановить, вызвав функцию API ***gx_system_timer_stop***.</span><span class="sxs-lookup"><span data-stu-id="32aee-481">A GUIX timer can be stopped by calling the API function ***gx_system_timer_stop***.</span></span>

### <a name="pen-speed-configuration"></a><span data-ttu-id="32aee-482">Конфигурация скорости пера</span><span class="sxs-lookup"><span data-stu-id="32aee-482">Pen Speed Configuration</span></span> 

<span data-ttu-id="32aee-483">Системный компонент GUIX содержит сведения о конфигурации, связанные с отслеживанием скорости пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-483">The GUIX system component holds configuration information related to pen speed tracking.</span></span> <span data-ttu-id="32aee-484">GUIX внутренним образом создает события **GX_EVENT_VERTICAL_FLICK** и **GX_EVENT_HORIZONTAL_FLICK** в зависимости от скорости и расстояния событий PEN_DOWN, созданных драйвером сенсорного ввода, если таковые имеются.</span><span class="sxs-lookup"><span data-stu-id="32aee-484">GUIX internally generated **GX_EVENT_VERTICAL_FLICK** and **GX_EVENT_HORIZONTAL_FLICK** events based on the speed and distance of PEN_DOWN events generated by the touch input driver, if any.</span></span> <span data-ttu-id="32aee-485">Приложение может настроить минимальные расстояние и скорость, необходимые для активации этих созданных внутренним образом событий, используя функцию API **_gx_system_pen_configure_**.</span><span class="sxs-lookup"><span data-stu-id="32aee-485">The application can configure the minimum distance and speed required to trigger these internally generated events using the **_gx_system_pen_configure_** API function.</span></span>

### <a name="screen-stack"></a><span data-ttu-id="32aee-486">Стек экрана</span><span class="sxs-lookup"><span data-stu-id="32aee-486">Screen Stack</span></span> 

<span data-ttu-id="32aee-487">Системный компонент GUIX предоставляет службы, связанные со стеком экрана GUIX, который является дополнительной возможностью, поддерживающей виртуальный стек мини-приложения для отправки, извлечения и получения экранов приложением в среде выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-487">The GUIX system component provides services related to the GUIX screen stack, which is an optional functionality supporting a virtual widget stack onto which screens can be pushed, popped, and retrieved at runtime by the application.</span></span> <span data-ttu-id="32aee-488">Стек экрана используется для управления сложными системами меню, когда маршрут, по которому пользователь может перейти в различные состояния в системе меню, варьируется.</span><span class="sxs-lookup"><span data-stu-id="32aee-488">The screen stack is useful for managing complex menu systems, wherein the route by which the user may arrive at various states in the menu system is varied.</span></span> <span data-ttu-id="32aee-489">К предыдущему состоянию в системе меню можно легко вернуться, сначала отправив предыдущее состояние экрана, а затем отобразив новый экран и разрешив новому экрану извлечь предыдущее состояние из стека экрана при закрытом текущем экране.</span><span class="sxs-lookup"><span data-stu-id="32aee-489">Returning to the previous state in the menu system can be easily done by first pushing the previous screen state, then displaying the new screen, and allowing the new screen to pop the previous state from the screen stack when the current screen is dismissed.</span></span>

### <a name="clipboard-maintenance"></a><span data-ttu-id="32aee-490">Обслуживание буфера обмена</span><span class="sxs-lookup"><span data-stu-id="32aee-490">Clipboard Maintenance</span></span> 

<span data-ttu-id="32aee-491">GUIX поддерживает буфер обмена для копирования и вставки текста во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="32aee-491">GUIX supports a clipboard for copying and pasting text during runtime execution.</span></span> <span data-ttu-id="32aee-492">Эта поддержка предоставляется системным компонентом GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-492">This support is provided by the GUIX System component.</span></span>

### <a name="dirty-list-maintenance"></a><span data-ttu-id="32aee-493">Поддержка "грязных" списков</span><span class="sxs-lookup"><span data-stu-id="32aee-493">Dirty List Maintenance</span></span> 

<span data-ttu-id="32aee-494">GUIX поддерживает список "грязных" мини-приложений (видимые мини-приложения, которые необходимо перерисовать из-за изменений состояния, или мини-приложения, ставшие вновь видимыми).</span><span class="sxs-lookup"><span data-stu-id="32aee-494">GUIX maintains a list of dirty widgets, meaning widgets that are visible and need to be redrawn due to status changes or being made newly visible.</span></span> <span data-ttu-id="32aee-495">Этот "грязный" список улучшает производительность рисования, позволяя GUIX выполнить операцию обновления холста для отображения всех текущих изменений состояния пользовательского интерфейса вместо обновления холста при каждом изменении пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="32aee-495">This dirty list improves drawing performance by allowing GUIX to do one canvas refresh operation to reflect all current changes to the UI status, rather than doing a canvas refresh as each UI change is made.</span></span>
<span data-ttu-id="32aee-496">Этот "грязный" список также поддерживается системным компонентом GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-496">This dirty list is also maintained by the GUIX system component.</span></span>

### <a name="animation-control-block-pool"></a><span data-ttu-id="32aee-497">Пул блоков управления анимацией</span><span class="sxs-lookup"><span data-stu-id="32aee-497">Animation Control Block Pool</span></span> 

<span data-ttu-id="32aee-498">Приложениям часто необходимо выполнять несколько последовательностей анимации и, как правило, в параллельном режиме.</span><span class="sxs-lookup"><span data-stu-id="32aee-498">Applications often desire to execute multiple animation sequences, often in parallel.</span></span> <span data-ttu-id="32aee-499">GUIX поддерживает пул блоков управления анимацией, которые приложение может выделить и использовать.</span><span class="sxs-lookup"><span data-stu-id="32aee-499">GUIX maintains a pool of animation control blocks from which the application can allocate and use.</span></span> <span data-ttu-id="32aee-500">Это устраняет в приложении необходимость статического определения этих блоков управления и позволяет повторно использовать их в разное время, вместо того чтобы определять уникальный блок управления для каждой анимации, которая определяется приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-500">This frees the application from statically defining these control blocks and allows them to be reused at different times, rather than defining a unique animation control block for every animation that the application might define.</span></span> <span data-ttu-id="32aee-501">Пул блоков управления анимацией также поддерживается системным компонентом GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-501">The animation control block pool is also maintained by the GUIX system component.</span></span>

### <a name="system-error-handling"></a><span data-ttu-id="32aee-502">Обработка системных ошибок</span><span class="sxs-lookup"><span data-stu-id="32aee-502">System Error Handling</span></span> 

<span data-ttu-id="32aee-503">Обработчик системных ошибок GUIX предназначен для того, чтобы помочь приложению найти внутренние системные ошибки в GUIX, которые сложнее определить с точки зрения API.</span><span class="sxs-lookup"><span data-stu-id="32aee-503">The GUIX system error handler is intended to assist the application in finding internal system errors in GUIX that might be more difficult to determine from the API perspective.</span></span> <span data-ttu-id="32aee-504">При возникновении системной ошибки в GUIX вызывается внутренняя функция ***_gx_system_error_process***.</span><span class="sxs-lookup"><span data-stu-id="32aee-504">Whenever a system error occurs inside of GUIX the internal ***_gx_system_error_process*** function is called.</span></span> <span data-ttu-id="32aee-505">Эта функция сохраняет указанный код ошибки и увеличивает общее количество обнаруженных системных ошибок.</span><span class="sxs-lookup"><span data-stu-id="32aee-505">This function saves the error code provided and increments the total number of system errors detected.</span></span> <span data-ttu-id="32aee-506">Переменные системных ошибок определены следующим образом:</span><span class="sxs-lookup"><span data-stu-id="32aee-506">The system error variables are defined as follows:</span></span>

<span data-ttu-id="32aee-507">UINT **_gx_system_last_error**;</span><span class="sxs-lookup"><span data-stu-id="32aee-507">UINT **_gx_system_last_error**;</span></span>

<span data-ttu-id="32aee-508">ULONG **_gx_system_error_count**;</span><span class="sxs-lookup"><span data-stu-id="32aee-508">ULONG **_gx_system_error_count**;</span></span>

<span data-ttu-id="32aee-509">Если приложение GUIX работает некорректно, необходимо проверить переменную количества ошибок в отладчике.</span><span class="sxs-lookup"><span data-stu-id="32aee-509">If the GUIX application is behaving strangely, it is useful to look at the error count variable in the debugger.</span></span> <span data-ttu-id="32aee-510">Если этот параметр настроен, устранить проблему можно, задав точку останова в функции ***_gx_system_error_process*** и проверив, откуда и когда выполнялся соответствующий вызов.</span><span class="sxs-lookup"><span data-stu-id="32aee-510">If it is set, a good way to troubleshoot the problem is to set a breakpoint in the ***_gx_system_error_process*** function and see when/where it is being called from.</span></span>

## <a name="guix-canvas-component"></a><span data-ttu-id="32aee-511">Компонент холста GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-511">GUIX Canvas Component</span></span>

<span data-ttu-id="32aee-512">Компонент холста отвечает за обработку всех данных, связанных с холстом.</span><span class="sxs-lookup"><span data-stu-id="32aee-512">The canvas component is responsible for all canvas related processing.</span></span> <span data-ttu-id="32aee-513">Холст по сути является виртуальным буфером кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-513">A canvas is effectively a virtual frame buffer.</span></span> <span data-ttu-id="32aee-514">Чтобы создать графические выходные данные, приложению необходимо создать по крайней мере один холст.</span><span class="sxs-lookup"><span data-stu-id="32aee-514">Your application must create at least one canvas in order to produce graphical output.</span></span>
<span data-ttu-id="32aee-515">Как правило, для каждого физического дисплея, поддерживаемого системой, создается по крайней мере один холст.</span><span class="sxs-lookup"><span data-stu-id="32aee-515">Typically, you would create at least one canvas for each physical display supported by your system.</span></span>

<span data-ttu-id="32aee-516">Все операции рисования GUIX выполняются на холсте.</span><span class="sxs-lookup"><span data-stu-id="32aee-516">All GUIX drawing takes place on a canvas.</span></span> <span data-ttu-id="32aee-517">В более простых системах или системах с ограниченной памятью обычно используется только один холст, который может быть напрямую связан с видимым буфером кадров. В системах с большим объемом памяти и повышенными графическими требованиями может понадобиться несколько холстов.</span><span class="sxs-lookup"><span data-stu-id="32aee-517">In simpler or memory constrained systems, there will likely be only one canvas which might be directly linked to the visible frame buffer, whereas systems with more memory and more advanced graphics requirements might require multiple canvases.</span></span> <span data-ttu-id="32aee-518">Использование нескольких холстов для одного дисплея позволяет применять такие функции, как эффект исчезания или появления экрана и окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-518">Making multiple canvases available for one display enables features such as screen and window fade-in and fade-out effects.</span></span>
<span data-ttu-id="32aee-519">Используется один из двух основных типов холстов: простой или управляемый.</span><span class="sxs-lookup"><span data-stu-id="32aee-519">Canvases can be one of two main types, simple or managed.</span></span>

<span data-ttu-id="32aee-520">Простой холст — это область рисования за пределами экрана, используемая приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-520">A simple canvas is an off-screen drawing area used by the application.</span></span>
<span data-ttu-id="32aee-521">GUIX ничего не выполняет напрямую на простом холсте, но приложение может использовать простой холст для отображения сложного рисунка в буфере за пределами экрана, а затем использовать этот буфер для обновления видимого холста при необходимости.</span><span class="sxs-lookup"><span data-stu-id="32aee-521">GUIX does nothing directly with a simple canvas, but the application can use a simple canvas to render complex drawing to an off-screen buffer, and then use this off-screen buffer to refresh the visible canvas when needed.</span></span>

<span data-ttu-id="32aee-522">Управляемый холст автоматически отображается в аппаратном буфере кадров с помощью GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-522">A managed canvas is automatically displayed within the hardware frame buffer by GUIX.</span></span> <span data-ttu-id="32aee-523">Управляемый холст добавляется при создании составного холста для систем с достаточным объемом памяти для поддержки нескольких управляемых холстов.</span><span class="sxs-lookup"><span data-stu-id="32aee-523">A managed canvas is included in building a composite canvas for those systems with enough memory to support multiple managed canvases.</span></span> <span data-ttu-id="32aee-524">Управляемые холсты имеют Z-порядок, который поддерживается GUIX. На всех управляемых холстах применяется возможность обрезания представлений.</span><span class="sxs-lookup"><span data-stu-id="32aee-524">Managed canvases have a Z-order maintained by GUIX, and view clipping is enforced on all managed canvases.</span></span>

<span data-ttu-id="32aee-525">Холст отличается от буфера кадров тем, что он является более универсальным.</span><span class="sxs-lookup"><span data-stu-id="32aee-525">A canvas differs from a frame buffer in that it is more generic.</span></span> <span data-ttu-id="32aee-526">В системах с ограниченным объемом памяти может использоваться только один холст, а память для этого холста может быть памятью видимого буфера кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-526">In memory constrained systems, there may be only one canvas and the memory for this canvas might be the visible frame buffer memory.</span></span> <span data-ttu-id="32aee-527">Но в более сложных системах, поддерживающих более сложные графические наложения и несколько холстов, для управляемых холстов выделяются собственные области памяти, которые отличаются от памяти аппаратного буфера кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-527">However, for more complex systems supporting more advanced graphical overlays and multiple canvases, the managed canvases are each allocated their own memory areas which are distinct from the hardware frame buffer memory.</span></span>
<span data-ttu-id="32aee-528">Эти управляемые холсты преобразовываются в видимый буфер кадров во время операции обновления буфера кадров или переключения режима.</span><span class="sxs-lookup"><span data-stu-id="32aee-528">These managed canvases are rendered into the visible frame buffer during the frame buffer refresh or toggle operation.</span></span>

<span data-ttu-id="32aee-529">Для оборудования, поддерживающего несколько графических слоев, например несколько наложенных буферов кадров, приложение может привязать один или несколько холстов к аппаратным графическим слоям с помощью API ***gx_canvas_hardware_layer_bind***.</span><span class="sxs-lookup"><span data-stu-id="32aee-529">For hardware supporting multiple graphics layers, i.e. multiple overlayed frame buffers, the application can bind one or more canvases to the hardware graphics layers using the ***gx_canvas_hardware_layer_bind*** API.</span></span> <span data-ttu-id="32aee-530">Эта служба информирует холст о том, что он связан с конкретным аппаратным графическим слоем. После связывания холст попытается использовать аппаратную поддержку для обеспечения видимости холста (т. е.</span><span class="sxs-lookup"><span data-stu-id="32aee-530">This service informs the canvas that it is linked to a particular hardware graphics layer, and once linked this canvas will attempt to utilize hardware support for canvas visibility (i.e</span></span> <span data-ttu-id="32aee-531">gx_canvas_show, gx_canvas_hide), альфа-смешения холстов (т. е. ***gx_canvas_alpha_set***) и смещения холста в пределах дисплея (***gx_canvas_offset_set***).</span><span class="sxs-lookup"><span data-stu-id="32aee-531">gx_canvas_show, gx_canvas_hide), canvas alpha blending (i.e. ***gx_canvas_alpha_set***) and canvas offset within the display (***gx_canvas_offset_set***).</span></span>

<span data-ttu-id="32aee-532">Для архитектур, отличных от простейшей организации с одним холстом или одним буфером кадров, размер холста определяется приложением и может отличаться от фиксированного размера буфера кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-532">For architectures other than the simplest single canvas/single frame buffer organization, the size of a canvas is determined by the application and may be different than the fixed size of a frame buffer.</span></span>
<span data-ttu-id="32aee-533">Кроме того, для этого может использоваться смещение, выбранное приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-533">It may also be at an offset selected by the application.</span></span> <span data-ttu-id="32aee-534">Другие сведения, например сведения о Z-порядке, сохраняются на холсте.</span><span class="sxs-lookup"><span data-stu-id="32aee-534">Other information, such as Z-order is maintained within the canvas.</span></span> <span data-ttu-id="32aee-535">После завершения рисования на холсте содержимое холста передается на физический дисплей с помощью драйвера дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-535">When the canvas drawing is complete, the contents of the canvas are transferred to the physical display by the display driver.</span></span> <span data-ttu-id="32aee-536">В некоторых системах, в которых недостаточно памяти для отдельных областей памяти холста и буфера кадров, обновление холста выполняется непосредственно на физическом дисплее с помощью драйвера дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-536">In some systems that don’t have enough memory for a separate canvas and frame buffer memory areas, the canvas update is actually made directly to the physical display via the display driver.</span></span>

### <a name="canvas-creation"></a><span data-ttu-id="32aee-537">Создание холста</span><span class="sxs-lookup"><span data-stu-id="32aee-537">Canvas Creation</span></span> 

<span data-ttu-id="32aee-538">Объект холста можно создать во время инициализации или в любое время при выполнении потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-538">A canvas object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="32aee-539">Количество объектов холста, которые может создать приложение, не ограничено.</span><span class="sxs-lookup"><span data-stu-id="32aee-539">There is no limit on the number of canvas objects that can be created by an application.</span></span> <span data-ttu-id="32aee-540">Тем не менее большинство приложений создает только один объект холста для всех операций рисования GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-540">Most applications, however, will create only one canvas object for all GUIX drawing.</span></span>

### <a name="canvas-control-block"></a><span data-ttu-id="32aee-541">Блок управления холстом</span><span class="sxs-lookup"><span data-stu-id="32aee-541">Canvas Control Block</span></span> 

<span data-ttu-id="32aee-542">Характеристики каждого объекта холста находятся в блоке управления **GX_CANVAS** и определены в **_gx_api.h_**.</span><span class="sxs-lookup"><span data-stu-id="32aee-542">The characteristics of each canvas object are found in its control block **GX_CANVAS** and is defined in **_gx_api.h_**.</span></span> <span data-ttu-id="32aee-543">Память, необходимая для объекта холста, предоставляется приложением и может находиться в любом месте в памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-543">The memory required for a canvas object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="32aee-544">Однако чаще всего блок управления объектами холста и область рисования становятся глобальной структурой путем их определения вне области какой-либо функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-544">However, it is most common to make the canvas object control block and the drawing area a global structure by defining them outside the scope of any function.</span></span>

### <a name="canvas-alpha-channel"></a><span data-ttu-id="32aee-545">Альфа-канал холста</span><span class="sxs-lookup"><span data-stu-id="32aee-545">Canvas Alpha Channel</span></span>

<span data-ttu-id="32aee-546">GUIX поддерживает альфа-смешение цветов переднего плана и фона на многих уровнях (включая альфа-канал растрового изображения, который определяет коэффициент смешения на пиксель, альфа-кисть, которая определяет коэффициент смешения для кисти (16 бит/пкс и глубину цвета более высокого уровня), а также альфа-холст, который определяет коэффициент смешения для холста наложения).</span><span class="sxs-lookup"><span data-stu-id="32aee-546">GUIX supports alpha-blending of foreground and background colors on many levels, including bitmap alpha channel which specifies a blending ratio per pixel, brush alpha which specifies the blending ratio for a brush at 16 bpp and higher color depths, and canvas alpha which specifies the blending ratio for an overlay canvas.</span></span>

<span data-ttu-id="32aee-547">Альфа-фактор холста используется при наличии нескольких холстов, объединенных для отображения в буфере кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-547">The alpha value of a canvas is used when there are multiple canvases which are composited together for display within the frame buffer.</span></span> <span data-ttu-id="32aee-548">Если используется Z-порядок холста, когда холст находится над другими холстами, можно задать альфа-фактор холста для смешения холста с теми холстами, которые находятся за ним.</span><span class="sxs-lookup"><span data-stu-id="32aee-548">If the canvas Z-order is such that a canvas is above other canvases, then the canvas alpha value can be set to blend the canvas with those that lie behind.</span></span> <span data-ttu-id="32aee-549">Быстро изменяя альфа-фактор холста, можно создать эффекты "исчезания" экрана, но его можно также использовать различными способами.</span><span class="sxs-lookup"><span data-stu-id="32aee-549">Rapidly modifying the alpha value of a canvas is used to provide “fade in” screen transition effects, but the canvas alpha can be used in many ways.</span></span>

<span data-ttu-id="32aee-550">Если холст привязан к аппаратному графическому слою с использованием gx_canvas_hardware_layer_bind(), GUIX попытается выполнить альфа-смешение холстов с помощью аппаратной поддержки, минимизируя нагрузку на программное обеспечение, связанную со смешением холста наложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-550">If a canvas is bound to a hardware graphics layer using gx_canvas_hardware_layer_bind(), GUIX will attempt to implement canvas alpha blending utilizing hardware support, minimizing the software overhead associated with blending an overlay canvas.</span></span>

<span data-ttu-id="32aee-551">Альфа-факторы могут иметь значение в диапазоне от 0 до 255, где значение 0 означает, что пиксель является полностью прозрачным, а значения больше 0 означают увеличение альфа-фактора холста и понижение уровня прозрачности (поддерживается только для драйверов экрана с 16 бит/пкс и выше, если не предоставляется аппаратная поддержка для смешения холстов).</span><span class="sxs-lookup"><span data-stu-id="32aee-551">Alpha values range from 0 through 255, where a value of 0 means the pixel is fully transparent and values greater than 0 are increasing less transparent canvas alpha value can only be supported for screen drivers running at 16-bpp and higher unless hardware assistance for canvas blending is provided.</span></span>

### <a name="canvas-offset"></a><span data-ttu-id="32aee-552">Смещение холста</span><span class="sxs-lookup"><span data-stu-id="32aee-552">Canvas Offset</span></span> 

<span data-ttu-id="32aee-553">Холст может быть смещен в видимом буфере кадров путем вызова службы API ***gx_canvas_offset_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-553">A canvas can be offset within the visible frame buffer by invoking the ***gx_canvas_offset_set*** API service.</span></span> <span data-ttu-id="32aee-554">Смещения холстов позволяют реализовать анимации спрайта.</span><span class="sxs-lookup"><span data-stu-id="32aee-554">Canvas offsets are usually used to implement sprite animations.</span></span> <span data-ttu-id="32aee-555">Если холст связан с аппаратным графическим слоем с помощью вызова функции API ***gx_canvas_hardware_layer_bind***, GUIX попытается изменить смещение холста, используя аппаратную поддержку, чтобы уменьшить нагрузку на программное обеспечение, связанную со сдвигом позиции холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-555">If a canvas is bound to a hardware graphics layer by invoking the ***gx_canvas_hardware_layer_bind*** API function, GUIX will attempt to implement canvas offset changes utilizing hardware support, minimizing the software overhead associated with shifting the canvas position.</span></span>

### <a name="canvas-drawing"></a><span data-ttu-id="32aee-556">Рисование на холсте</span><span class="sxs-lookup"><span data-stu-id="32aee-556">Canvas Drawing</span></span> 

<span data-ttu-id="32aee-557">Компонент холста GUIX предоставляет приложению полный API для рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-557">The GUIX canvas component provides a full drawing API to the application.</span></span> <span data-ttu-id="32aee-558">Перед вызовом API рисования, таких как ***gx_canvas_line_draw*** или ***gx_canvas_pixelmap_draw***, необходимо открыть целевой холст для рисования путем вызова функции API ***gx_canvas_drawing_initiate***.</span><span class="sxs-lookup"><span data-stu-id="32aee-558">Before the drawing APIs such as ***gx_canvas_line_draw*** or ***gx_canvas_pixelmap_draw*** can be invoked, the target canvas must be opened for drawing by invoking the ***gx_canvas_drawing_initiate*** API function.</span></span> <span data-ttu-id="32aee-559">Эта функция готовит холст для рисования и создает ***контекст рисования***.</span><span class="sxs-lookup"><span data-stu-id="32aee-559">This function prepares a canvas for drawing and creates a ***drawing context***.</span></span>

<span data-ttu-id="32aee-560">API рисования, которые визуализируются на холсте, например ***gx_canvas_line_draw** _ или _*_gx_canvas_text_draw_\*_, используют параметры в текущей кисти контекста рисования для определения стиля линий, ширины и цветов.</span><span class="sxs-lookup"><span data-stu-id="32aee-560">The drawing APIs that render to the canvas, such as ***gx_canvas_line_draw** _ or _*_gx_canvas_text_draw_\*_, use parameters found in the current drawing context brush to define the line style, width, and colors.</span></span> <span data-ttu-id="32aee-561">Эти параметры кисти можно изменить путем вызова _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_ и аналогичных функций API после установки контекста рисования с помощью вызова _\*_gx_canvas_drawing_initiate_\*\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-561">These brush parameters are modified by calling the _*_gx_context_brush_define_*_, _\*_gx_context_brush_set_\*\*, \***gx_context_brush_style_set**_, and similar API functions after a drawing context has been established by calling _\*_gx_canvas_drawing_initiate_\*\*.</span></span>

<span data-ttu-id="32aee-562">Когда GUIX вызывает функции рисования окна и мини-приложения в рамках операции отложенного обновления холста, целевой холст открывается для рисования перед вызовом функций рисования для мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-562">When GUIX invokes the window and widget drawing functions as part of a deferred canvas refresh operation, the target canvas is opened for drawing prior to calling the widget drawing function(s).</span></span> <span data-ttu-id="32aee-563">Поэтому для стандартных функций рисования мини-приложения не нужно открывать целевой холст, так как это уже выполнено.</span><span class="sxs-lookup"><span data-stu-id="32aee-563">Therefore the standard widget drawing functions are not required to open the target canvas, this has been done for them.</span></span>

<span data-ttu-id="32aee-564">В некоторых случаях приложению может потребоваться немедленно выполнить рисование на холсте.</span><span class="sxs-lookup"><span data-stu-id="32aee-564">In some cases the application may want to force immediate drawing to a canvas.</span></span> <span data-ttu-id="32aee-565">В этом случае приложение может выполнить указанные ниже действия.</span><span class="sxs-lookup"><span data-stu-id="32aee-565">In this case, the application can perform the following steps.</span></span>

1. <span data-ttu-id="32aee-566">Вызовите функцию API ***gx_canvas_drawing_initiate***, передав целевой холст и прямоугольник на холсте, на котором приложение выполняет операцию рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-566">Call the ***gx_canvas_drawing_initiate*** API function, passing in the target canvas and rectangle within that canvas on which the application wants to draw.</span></span> 

2. <span data-ttu-id="32aee-567">Вызовите любое количество API рисования холста, чтобы выполнить нужную операцию рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-567">Call any number of canvas drawing APIs to accomplish the desired drawing.</span></span>

3. <span data-ttu-id="32aee-568">Вызовите функцию API ***gx_canvas_drawing_complete***, чтобы сообщить о завершении рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-568">Call the ***gx_canvas_drawing_complete*** API function to signal that drawing has been completed.</span></span> <span data-ttu-id="32aee-569">При этом холст записывается в видимый буфер кадров и (или) активируется операция переключения буфера в зависимости от архитектуры системной памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-569">This flushes the canvas to the visible frame buffer and/or triggers a buffer toggle operation, depending on the system memory architecture.</span></span>

### <a name="drawing-apis"></a><span data-ttu-id="32aee-570">API рисования</span><span class="sxs-lookup"><span data-stu-id="32aee-570">Drawing APIs</span></span> 

<span data-ttu-id="32aee-571">Существует несколько основных примитивов рисования, которые необходимы GUIX для рисования всех визуальных элементов на экране.</span><span class="sxs-lookup"><span data-stu-id="32aee-571">There are several principal drawing primitives that are required by GUIX to draw all the visual elements on the screen.</span></span> <span data-ttu-id="32aee-572">Эти API рисования также могут быть вызваны программным обеспечением приложения, как правило, в рамках выполнения пользовательской функции рисования мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-572">These drawing APIs can also be invoked by application software, usually as part of a custom widget drawing function.</span></span> <span data-ttu-id="32aee-573">Эти API рисования на холсте GUIX выполняют проверку параметров и операции обрезки, а затем передают координаты обрезанного рисунка драйверу дисплея для реализации рисования на основе оборудования и цветного формата.</span><span class="sxs-lookup"><span data-stu-id="32aee-573">These GUIX canvas drawing APIs perform parameter validation and clipping, and then pass the clipped drawing coordinates down to the display driver for hardware and color-format specific drawing implementations.</span></span> <span data-ttu-id="32aee-574">Эти функции API рисования определяются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="32aee-574">These drawing API functions are defined as follows.</span></span>

- <span data-ttu-id="32aee-575">gx_canvas_alpha_set</span><span class="sxs-lookup"><span data-stu-id="32aee-575">gx_canvas_alpha_set</span></span>
- <span data-ttu-id="32aee-576">gx_canvas_arc_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-576">gx_canvas_arc_draw</span></span>
- <span data-ttu-id="32aee-577">gx_canvas_block_move</span><span class="sxs-lookup"><span data-stu-id="32aee-577">gx_canvas_block_move</span></span>
- <span data-ttu-id="32aee-578">gx_canvas_circle_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-578">gx_canvas_circle_draw</span></span>
- <span data-ttu-id="32aee-579">gx_canvas_ellipse_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-579">gx_canvas_ellipse_draw</span></span>
- <span data-ttu-id="32aee-580">gx_canvas_glyphs_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-580">gx_canvas_glyphs_draw</span></span>
- <span data-ttu-id="32aee-581">gx_canvas_hardware_layer_bind</span><span class="sxs-lookup"><span data-stu-id="32aee-581">gx_canvas_hardware_layer_bind</span></span>
- <span data-ttu-id="32aee-582">gx_canvas_hide</span><span class="sxs-lookup"><span data-stu-id="32aee-582">gx_canvas_hide</span></span>
- <span data-ttu-id="32aee-583">gx_canvas_line_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-583">gx_canvas_line_draw</span></span>
- <span data-ttu-id="32aee-584">gx_canvas_offset_set</span><span class="sxs-lookup"><span data-stu-id="32aee-584">gx_canvas_offset_set</span></span>
- <span data-ttu-id="32aee-585">gx_canvas_pie_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-585">gx_canvas_pie_draw</span></span>
- <span data-ttu-id="32aee-586">gx_canvas_pixel_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-586">gx_canvas_pixel_draw</span></span>
- <span data-ttu-id="32aee-587">gx_canvas_pixelmap_blend</span><span class="sxs-lookup"><span data-stu-id="32aee-587">gx_canvas_pixelmap_blend</span></span>
- <span data-ttu-id="32aee-588">gx_canvas_pixelmap_rotate</span><span class="sxs-lookup"><span data-stu-id="32aee-588">gx_canvas_pixelmap_rotate</span></span>
- <span data-ttu-id="32aee-589">gx_canvas_pixelmap_tile</span><span class="sxs-lookup"><span data-stu-id="32aee-589">gx_canvas_pixelmap_tile</span></span>
- <span data-ttu-id="32aee-590">gx_canvas_polygon_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-590">gx_canvas_polygon_draw</span></span>
- <span data-ttu-id="32aee-591">gx_canvas_rectangle_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-591">gx_canvas_rectangle_draw</span></span>
- <span data-ttu-id="32aee-592">gx_canvas_rotated_text_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-592">gx_canvas_rotated_text_draw</span></span>
- <span data-ttu-id="32aee-593">gx_canvas_shift</span><span class="sxs-lookup"><span data-stu-id="32aee-593">gx_canvas_shift</span></span>
- <span data-ttu-id="32aee-594">gx_canvas_show</span><span class="sxs-lookup"><span data-stu-id="32aee-594">gx_canvas_show</span></span>
- <span data-ttu-id="32aee-595">gx_canvas_text_draw</span><span class="sxs-lookup"><span data-stu-id="32aee-595">gx_canvas_text_draw</span></span>

<span data-ttu-id="32aee-596">API рисования вызывается с помощью API холста GUIX, а все операции рисования выполняются с помощью функций API gx_canvas_\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-596">The drawing API is invoked via the GUIX Canvas API, and all drawing is done using gx_canvas_\* API functions.</span></span> <span data-ttu-id="32aee-597">Рисование выполняется с помощью текущей кисти в текущем контексте рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-597">Drawing is done using the current brush in the current drawing context.</span></span> <span data-ttu-id="32aee-598">Для любой указанной выше функции рисования фигур можно создать контур, выполнить сплошную заливку цветом или выполнить заполнение пиксельной картой в соответствии с определением текущей кисти.</span><span class="sxs-lookup"><span data-stu-id="32aee-598">Any of the shape drawing functions above can be outlined, solid color filled, or pixelmap filled as defined by the current brush.</span></span> <span data-ttu-id="32aee-599">Для изменения ширины, цвета или заливки контура фигуры используйте функции API gx_context_brush_\*, чтобы определить кисть в текущем контексте рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-599">To modify the shape outline width, color, or fill, use the gx_context_brush_\* API functions to define the brush within the current drawing context.</span></span>

<span data-ttu-id="32aee-600">Указанные выше API рисования на уровне приложения не выполняют фактическое рисование на холсте. Вместо этого они проверяют параметры вызывающего элемента перед вызовом функции рисования на уровне драйвера дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-600">The above application level drawing APIs don’t do actual drawing to the canvas, but instead verify the caller’s parameters before invoking the display driver level drawing function.</span></span> <span data-ttu-id="32aee-601">Функция рисования на уровне драйвера по сути записывает пиксельные данные в память холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-601">The driver level drawing function actually writes pixel data into the canvas memory.</span></span>

<span data-ttu-id="32aee-602">GUIX предоставляет стоковые или универсальные функции рисования драйверов дисплея для различной глубины цвета, включая 1, 2, 4, 8, 16, 24 и 32 бит на пиксель (бит/пкс).</span><span class="sxs-lookup"><span data-stu-id="32aee-602">GUIX provides stock or generic display driver drawing functions for various color depths, including 1, 2, 4, 8, 16, 24, and 32 bits per pixel (bpp).</span></span> <span data-ttu-id="32aee-603">В некоторых случаях реализация программного рисования по умолчанию заменяется реализациями с аппаратным ускорением для тех аппаратных целевых объектов, которые предоставляют ускоритель для двухмерного рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-603">In some cases, the default software drawing implementation is replaced by hardware-accelerated implementations for those hardware targets that provide a 2D drawing accelerator.</span></span>

### <a name="color-depth"></a><span data-ttu-id="32aee-604">Глубина цвета</span><span class="sxs-lookup"><span data-stu-id="32aee-604">Color Depth</span></span> 

<span data-ttu-id="32aee-605">GUIX поддерживает глубину цвета до 32 бит/пкс, а также монохромную шкалу и оттенки серого.</span><span class="sxs-lookup"><span data-stu-id="32aee-605">GUIX supports color depths up to 32-bpp as well as monochrome and grayscale.</span></span> <span data-ttu-id="32aee-606">Тип поддержки глубины цвета в основном определяется возможностями базового физического дисплея, а также влияет на необходимый объем памяти для области рисования холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-606">The type of color depth support largely determined by the capabilities of the underlying physical display and also has an impact on how much memory is required for the canvas drawing area.</span></span> <span data-ttu-id="32aee-607">Ниже приведен список поддержки глубины цвета, а также краткое описание вариаций в рамках данной глубины цвета.</span><span class="sxs-lookup"><span data-stu-id="32aee-607">The following is a list of color depth support along with a brief description of the variations within that color depth.</span></span>

| <span data-ttu-id="32aee-608">Формат&nbsp;цвета</span><span class="sxs-lookup"><span data-stu-id="32aee-608">Color&nbsp;Format</span></span>       | <span data-ttu-id="32aee-609">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-609">Description</span></span>                                                                                                   |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="32aee-610">1-битный, монохромный</span><span class="sxs-lookup"><span data-stu-id="32aee-610">1-bit monochrome</span></span>   | <span data-ttu-id="32aee-611">Формат упаковки — 1 бит на пиксель.</span><span class="sxs-lookup"><span data-stu-id="32aee-611">1-bit per pixel packed format.</span></span>                                                                                                   |
| <span data-ttu-id="32aee-612">2-битный, оттенки серого</span><span class="sxs-lookup"><span data-stu-id="32aee-612">2-bit grayscale</span></span>    | <span data-ttu-id="32aee-613">4 уровня серого, упаковка — четыре пикселя на байт.</span><span class="sxs-lookup"><span data-stu-id="32aee-613">4 gray levels, packed four pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="32aee-614">4-битный, оттенки серого</span><span class="sxs-lookup"><span data-stu-id="32aee-614">4-bit grayscale</span></span>    | <span data-ttu-id="32aee-615">16 уровней серого, упаковка — два пикселя на байт.</span><span class="sxs-lookup"><span data-stu-id="32aee-615">16 gray levels, packed two pixels per byte.</span></span>                                                                                      |
| <span data-ttu-id="32aee-616">4-битный цвет</span><span class="sxs-lookup"><span data-stu-id="32aee-616">4-bit color</span></span>        | <span data-ttu-id="32aee-617">Плоская организация памяти в формате VGA.</span><span class="sxs-lookup"><span data-stu-id="32aee-617">A VGA format planar memory organization.</span></span>                                                                                         |
| <span data-ttu-id="32aee-618">8-битный, оттенки серого</span><span class="sxs-lookup"><span data-stu-id="32aee-618">8-bit grayscale</span></span>    | <span data-ttu-id="32aee-619">256 уровней серого</span><span class="sxs-lookup"><span data-stu-id="32aee-619">256 gray levels</span></span>                                                                                                                  |
| <span data-ttu-id="32aee-620">8-битный режим палитры</span><span class="sxs-lookup"><span data-stu-id="32aee-620">8-bit palette mode</span></span> | <span data-ttu-id="32aee-621">1 байт на пиксель, используется в качестве индекса палитры</span><span class="sxs-lookup"><span data-stu-id="32aee-621">1 byte per pixel used as palette index</span></span>                                                                                           |
| <span data-ttu-id="32aee-622">8-битный режим r:g:b</span><span class="sxs-lookup"><span data-stu-id="32aee-622">8-bit r:g:b mode</span></span>   | <span data-ttu-id="32aee-623">Реже используемый формат 2:3:2 r:g:b.</span><span class="sxs-lookup"><span data-stu-id="32aee-623">A less commonly used 2:3:2 r:g:b format.</span></span>                                                                                         |
| <span data-ttu-id="32aee-624">16-разрядный</span><span class="sxs-lookup"><span data-stu-id="32aee-624">16-bit</span></span>             | <span data-ttu-id="32aee-625">Для каждого пикселя требуется два байта.</span><span class="sxs-lookup"><span data-stu-id="32aee-625">Each pixel requires two bytes.</span></span> <span data-ttu-id="32aee-626">Порядок байтов может быть r:g:b или b:g:r.</span><span class="sxs-lookup"><span data-stu-id="32aee-626">Can be r:g:b or b:g:r byte order.</span></span> <span data-ttu-id="32aee-627">Обычно используется структура 5:6:5, но также может использоваться структура 5:5:5 или 4:4:4:4 a:r:g:b.</span><span class="sxs-lookup"><span data-stu-id="32aee-627">Normally 5:6:5 structure, but can also be 5:5:5 structure or 4:4:4:4 a:r:g:b structure.</span></span> |
| <span data-ttu-id="32aee-628">24-битный</span><span class="sxs-lookup"><span data-stu-id="32aee-628">24-bit</span></span>             | <span data-ttu-id="32aee-629">Для каждого пикселя требуется 3 (упакованный формат) или 4 (распакованный формат) байта.</span><span class="sxs-lookup"><span data-stu-id="32aee-629">Each pixel requires 3 (packed format) or 4 (unpacked format) bytes.</span></span> <span data-ttu-id="32aee-630">Может использоваться порядок байтов r:g:b или b:g:r в соответствии с требованиями оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-630">Can be in r:g:b or b:g:r byte order as required by hardware.</span></span> |
| <span data-ttu-id="32aee-631">32-разрядная система</span><span class="sxs-lookup"><span data-stu-id="32aee-631">32-bit</span></span>             | <span data-ttu-id="32aee-632">Для каждого пикселя требуется 4 байта и альфа-канал.</span><span class="sxs-lookup"><span data-stu-id="32aee-632">Each pixel requires 4 bytes with an alpha channel.</span></span> <span data-ttu-id="32aee-633">Может использоваться порядок байтов a:r:g:b или b:g:r:a, определяется оборудованием.</span><span class="sxs-lookup"><span data-stu-id="32aee-633">Can be a:r:g:b or b:g:r:a byte order and determined by hardware.</span></span>              |

### <a name="mouse-support"></a><span data-ttu-id="32aee-634">Поддержка мыши</span><span class="sxs-lookup"><span data-stu-id="32aee-634">Mouse Support</span></span> 

<span data-ttu-id="32aee-635">GUIX поддерживает рисование курсором мыши на любом холсте.</span><span class="sxs-lookup"><span data-stu-id="32aee-635">GUIX supports drawing a mouse cursor on any desired canvas.</span></span> <span data-ttu-id="32aee-636">Курсором мыши можно рисовать, используя программное обеспечение или поддержку аппаратного наложения курсора.</span><span class="sxs-lookup"><span data-stu-id="32aee-636">The mouse cursor can be drawing in software or might be supported by hardware cursor overlay.</span></span> <span data-ttu-id="32aee-637">В любом случае при рисовании программным или аппаратным курсором мыши используется один и тот же API, предоставляемый приложению, связанному с поддержкой курсора мыши.</span><span class="sxs-lookup"><span data-stu-id="32aee-637">In either case, the API provided to the application related to mouse cursor support is the same whether using software or hardware mouse cursor drawing.</span></span>

<span data-ttu-id="32aee-638">Поддержка мыши GUIX включена только в том случае, если элемент `#define GX_MOUSE_SUPPORT` определен в файле заголовка gx_user.h перед сборкой библиотеки GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-638">GUIX mouse support is only enabled if the `#define GX_MOUSE_SUPPORT` is defined in the gx_user.h header file before building the GUIX library.</span></span>

<span data-ttu-id="32aee-639">Приложение должно определить курсор мыши и гиперобъект с помощью функции API ***gx_canvas_mouse_define***.</span><span class="sxs-lookup"><span data-stu-id="32aee-639">The application must define the mouse cursor and hotspot using the ***gx_canvas_mouse_define*** API function.</span></span> <span data-ttu-id="32aee-640">Этот API принимает указатель для холста, на котором должно быть нарисовано изображение курсора, а также указатель для структуры **GX_MOUSE_CURSOR_INFO**, что определяет изображение курсора мыши и гиперобъект изображения мыши относительно левого верхнего угла изображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-640">This API accepts a pointer to the canvas on which the cursor image should be drawn, and a pointer to a **GX_MOUSE_CURSOR_INFO** structure, which defines the mouse cursor image and hotspot of the mouse image relative the image top-left corner.</span></span>

## <a name="guix-display-component"></a><span data-ttu-id="32aee-641">Компонент дисплея GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-641">GUIX Display Component</span></span> 

<span data-ttu-id="32aee-642">Компонент дисплея является фундаментальным в GUIX, так как он управляет обработкой данных всех объектов дисплея, которые содержат холсты, мини-приложения и окна (несколько или по одному).</span><span class="sxs-lookup"><span data-stu-id="32aee-642">The display component is fundamental in GUIX, since it manages the processing of all display objects, which in themselves contain one or more canvases, widgets, and windows.</span></span> <span data-ttu-id="32aee-643">Компонент дисплея также взаимодействует с базовым аппаратным драйвером экрана, связанным с каждым дисплеем, с помощью ряда указателей функций.</span><span class="sxs-lookup"><span data-stu-id="32aee-643">The display component also interacts with the underlying hardware screen driver associated with each display through a series of function pointers.</span></span>

### <a name="display-creation"></a><span data-ttu-id="32aee-644">Создание дисплея</span><span class="sxs-lookup"><span data-stu-id="32aee-644">Display Creation</span></span> 

<span data-ttu-id="32aee-645">Объект дисплея можно создать во время инициализации или в любое время при выполнении потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-645">A display object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="32aee-646">Обычно приложение создает один объект дисплея для управления каждым физическим экраном.</span><span class="sxs-lookup"><span data-stu-id="32aee-646">Typically an application creates one display object to manage each physical screen.</span></span> <span data-ttu-id="32aee-647">Если GUIX Studio используется для определения приложения и физических дисплеев, необходимо использовать функцию API gx_studio_display_configure для создания и инициализации каждого из дисплеев.</span><span class="sxs-lookup"><span data-stu-id="32aee-647">If you have used GUIX Studio to define your application and the physical displays available, you will use the gx_studio_display_configure API function to create and initialize each of your displays.</span></span>

### <a name="display-control-block"></a><span data-ttu-id="32aee-648">Блок управления для дисплея</span><span class="sxs-lookup"><span data-stu-id="32aee-648">Display Control Block</span></span> 

<span data-ttu-id="32aee-649">Характеристики каждого объекта дисплея находятся в блоке управления ***GX_DISPLAY** _ и определены в _*_gx_api.h_\*\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-649">The characteristics of each display object are found in its control block ***GX_DISPLAY** _ and are defined in _*_gx_api.h_\*\*.</span></span> <span data-ttu-id="32aee-650">Память, необходимая для объекта дисплея, предоставляется приложением и может находиться в любом месте в памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-650">The memory required for a display object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="32aee-651">Однако чаще всего блок управления дисплеем становится глобальной структурой путем его определения вне области какой-либо функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-651">However, it is most common to make the display control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="resource-management"></a><span data-ttu-id="32aee-652">Управление ресурсами</span><span class="sxs-lookup"><span data-stu-id="32aee-652">Resource Management</span></span> 

<span data-ttu-id="32aee-653">Ресурсы — это компоненты пользовательского интерфейса, необходимые для приложения, но они не являются кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-653">Resources are UI components that are needed by the application, but they are not application code.</span></span> <span data-ttu-id="32aee-654">Ресурсы — это данные приложений, которые обычно определяются статически.</span><span class="sxs-lookup"><span data-stu-id="32aee-654">Resources are application data and are usually statically defined.</span></span> <span data-ttu-id="32aee-655">К типам ресурсов относятся пиксельные карты, шрифты, цвета и строки.</span><span class="sxs-lookup"><span data-stu-id="32aee-655">Resource types include pixelmaps, fonts, colors, and strings.</span></span> <span data-ttu-id="32aee-656">Эти ресурсы можно изменить в любое время (как правило, не изменяя программное обеспечение приложения).</span><span class="sxs-lookup"><span data-stu-id="32aee-656">These resources can be changed at any time, usually without changing any application software.</span></span> <span data-ttu-id="32aee-657">Важно хранить ресурсы и ссылки на ресурсы отдельно от программного обеспечения приложения. Это позволяет изменять внешний вид пользовательского интерфейса без изменения кода приложения, так как при изменениях программного обеспечения приложения обычно необходимы повторное тестирование и проверки этого программного обеспечения.</span><span class="sxs-lookup"><span data-stu-id="32aee-657">It is important to keep the storage of and references to resources separated from the application software to allow changing UI appearance without changing application code since changes to the application software usually require the associated re-testing and verification of that software.</span></span>

<span data-ttu-id="32aee-658">Модуль ***дисплея*** GUIX предоставляет средства управления для всех ресурсов, зависящих от глубины цвета и формата дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-658">The GUIX ***display*** module provides resource management facilities for all resources that are dependent on the color depth and format of the display.</span></span> <span data-ttu-id="32aee-659">Эти средства также обеспечивают поддержку активной таблицы пиксельных карт, активных таблиц шрифтов и активных таблиц цветов.</span><span class="sxs-lookup"><span data-stu-id="32aee-659">These facilities include maintaining the active pixelmap table, active font table, and active color table.</span></span> <span data-ttu-id="32aee-660">Ресурс таблицы строк сохраняется в системном модуле GUIX, так как обычно не требуется изменять ресурсы строк в зависимости от глубины цвета и формата.</span><span class="sxs-lookup"><span data-stu-id="32aee-660">The string table resource is maintained by the GUIX system module, since string resources do not normally need to be changed based on color depth and format.</span></span>

<span data-ttu-id="32aee-661">Программное обеспечение приложения ссылается на ресурсы, используя идентификатор ресурса, который является индексом для соответствующей таблицы ресурсов.</span><span class="sxs-lookup"><span data-stu-id="32aee-661">The application software references resources by their resource Id, which is an index into the corresponding resource table.</span></span> <span data-ttu-id="32aee-662">Это позволяет изменять таблицу. Например, таблица цветов может быть изменена, если для продукта переключить режим работы с дневного на ночной. Но значения идентификатора цвета остаются прежними.</span><span class="sxs-lookup"><span data-stu-id="32aee-662">This allows the table to be changed, for example the color table might be changed when a product changes from “day mode” to “night mode”, but the color ID values to remain the same.</span></span>

<span data-ttu-id="32aee-663">Ресурсы приложения записываются в файл ресурсов (или набор файлов ресурсов) с помощью приложения GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-663">Your application resources are written to a resource file (or set of resource files) by the GUIX Studio application.</span></span> <span data-ttu-id="32aee-664">Цвета по умолчанию, пиксельные карты и шрифты предоставляются автоматически при создании нового проекта GUIX Studio, но эти значения по умолчанию можно легко заменить при определении внешнего вида и свойств приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-664">Default colors, pixelmaps, and fonts are provided automatically when you create a new GUIX Studio project, but these defaults are easily replaced as you define the look and feel of your application.</span></span>

<span data-ttu-id="32aee-665">Важно отметить, что идентификаторы ресурсов для цветов, шрифтов и пиксельных карт не могут быть разрешены для их фактических значений цвета, шрифта или пиксельной карты, пока не станет известным компонент активного дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-665">It is important to note that Resource IDs for colors, fonts, and pixelmaps cannot be resolved to their actual color, font, or pixelmap values until the active Display component is known.</span></span> <span data-ttu-id="32aee-666">Так как архитектура GUIX поддерживает несколько активных дисплеев, идентификаторы ресурсов могут быть разрешены для значений ресурсов, только когда мини-приложение и связанный с ним идентификатор ресурса могут быть разрешены для конкретного дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-666">Since the GUIX architecture supports multiple active displays, Resource IDs can only be resolved to resource values when a widget and its associated Resource ID can be resolved to a specific display.</span></span> <span data-ttu-id="32aee-667">Это свойство называется динамической привязкой.</span><span class="sxs-lookup"><span data-stu-id="32aee-667">This property is known as dynamic binding.</span></span> <span data-ttu-id="32aee-668">Идентификатор ресурса для свойства цвета текста, например идентификатор ресурса **GX_COLOR_ID_TEXT**, может разрешаться в 16-битное значение R:G:B для белого цвета, если используется для одного дисплея. Но тот же идентификатор цвета может разрешаться в монохромное значение черного цвета при использовании для другого дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-668">The Resource ID for a property such as a text color, for example the resource ID **GX_COLOR_ID_TEXT,** might resolve to a 16-bit R:G:B value for white when used on one display, but the same color ID might resolve to a monochrome black color value when used on another display.</span></span>

<span data-ttu-id="32aee-669">На практике эта динамическая привязка идентификаторов ресурсов к значениям ресурсов означает, что программное обеспечение приложения и внутренние компоненты GUIX чаще всего разрешают идентификаторы ресурсов только для значений ресурсов в активном контексте рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-669">In practice this dynamic binding of Resources IDs to resource values means that application software and GUIX internal components should most often only resolve Resource IDs to resource values within an active drawing context.</span></span> <span data-ttu-id="32aee-670">Активный контекст рисования определяет текущий активный дисплей, что позволяет GUIX разрешать каждый идентификатор ресурса для определенного значения ресурса.</span><span class="sxs-lookup"><span data-stu-id="32aee-670">An active drawing context specifies the currently active display, which allows GUIX to resolve each Resource ID to a specific resource value.</span></span> <span data-ttu-id="32aee-671">Если для программного обеспечения приложения необходимо найти определенное значение ресурса за пределами контекста рисования, это также можно сделать для видимых мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-671">If the application software is required to find a specific resource value outside of a drawing context, this can also be done for visible widgets.</span></span> <span data-ttu-id="32aee-672">Видимые мини-приложения связаны с корневым окном, которое также можно использовать для разрешения активного холста и дисплея для этого мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-672">Visible widgets are linked to a root window which can also be used to resolve the active canvas and display for that widget.</span></span>

<span data-ttu-id="32aee-673">Если мини-приложение создано, но еще не отображается (т. е. не связано ни с одним корневым окном или другим видимым родительским элементом), любые идентификаторы ресурсов, связанные с этим мини-приложением, не могут быть разрешены для определенного значения ресурса. Это возможно только при непосредственном индексировании для таблицы ресурсов, назначенной конкретному дисплею.</span><span class="sxs-lookup"><span data-stu-id="32aee-673">If a widget has been created but not yet displayed (i.e., has not been linked to any root window or other visible parent), any resource IDs associated with that widget cannot be resolved to a specific resource value other than by directly indexing into the resource table assigned to a specific display.</span></span> <span data-ttu-id="32aee-674">Этот прямой доступ к определенной таблице ресурсов может безопасно осуществляться программным обеспечением приложения, но он никогда не осуществляется с помощью программного обеспечения внутренней библиотеки GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-674">This direct access to a specific resource table can safely be done by the application software, but is never done in the internal GUIX library software.</span></span>

### <a name="widget-defaults"></a><span data-ttu-id="32aee-675">Значения по умолчанию мини-приложения</span><span class="sxs-lookup"><span data-stu-id="32aee-675">Widget Defaults</span></span> 

<span data-ttu-id="32aee-676">Компонент дисплея GUIX также предоставляет определения по умолчанию для различных атрибутов мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-676">The GUIX display component also provides default definitions for various widget attributes.</span></span> <span data-ttu-id="32aee-677">Если в приложении не указано иное, мини-приложения или окна создаются с этими системными атрибутами.</span><span class="sxs-lookup"><span data-stu-id="32aee-677">Unless otherwise specified by the application, widgets/windows are created with these system attributes.</span></span> <span data-ttu-id="32aee-678">Эти системные атрибуты в основном состоят из шрифтов, цветов и растровых изображений, сохраненных в таблицах системных ресурсов.</span><span class="sxs-lookup"><span data-stu-id="32aee-678">These system attributes are mainly composed of fonts, colors, and bitmaps maintained in the system resource tables.</span></span> <span data-ttu-id="32aee-679">Дополнительные атрибуты для внешнего вида полосы прокрутки по умолчанию также поддерживаются компонентом дисплея GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-679">Additional attributes for default scrollbar appearance are also maintained by the GUIX display component.</span></span>

<span data-ttu-id="32aee-680">Параметры цвета по умолчанию определяются с помощью таблицы цветов, назначенной каждому дисплею, а также предварительно определенных идентификаторов цвета по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="32aee-680">The default color settings are defined by the color table assigned to each display and the pre-defined default color IDs.</span></span> <span data-ttu-id="32aee-681">К этим идентификаторам цвета по умолчанию относятся следующие идентификаторы.</span><span class="sxs-lookup"><span data-stu-id="32aee-681">These default color ids include the following.</span></span>

| <span data-ttu-id="32aee-682">Идентификатор цвета</span><span class="sxs-lookup"><span data-stu-id="32aee-682">Color ID</span></span> | <span data-ttu-id="32aee-683">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-683">Description</span></span> |
| ------------------ | -------------------------------------------------------------------------------------------------------------------------------- |
| <span data-ttu-id="32aee-684">GX_COLOR_ID_CANVAS</span><span class="sxs-lookup"><span data-stu-id="32aee-684">GX_COLOR_ID_CANVAS</span></span> | <span data-ttu-id="32aee-685">Цвет холста по умолчанию (т. е. фон дисплея)</span><span class="sxs-lookup"><span data-stu-id="32aee-685">Default canvas (i.e. display background) color</span></span> |
| <span data-ttu-id="32aee-686">GX_COLOR_ID_WIDGET_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-686">GX_COLOR_ID_WIDGET_FILL</span></span> | <span data-ttu-id="32aee-687">Цвет заливки мини-приложения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-687">Default widget fill color</span></span> |
| <span data-ttu-id="32aee-688">GX_COLOR_ID_WINDOW_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-688">GX_COLOR_ID_WINDOW_FILL</span></span> | <span data-ttu-id="32aee-689">Цвет заливки окна по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-689">Default window fill color</span></span> |
| <span data-ttu-id="32aee-690">GX_COLOR_ID_DISABLED_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-690">GX_COLOR_ID_DISABLED_FILL</span></span> | <span data-ttu-id="32aee-691">Цвет заливки отключенного мини-приложения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-691">Default disabled widget fill color</span></span> |
| <span data-ttu-id="32aee-692">GX_COLOR_ID_DEFAULT_BORDER</span><span class="sxs-lookup"><span data-stu-id="32aee-692">GX_COLOR_ID_DEFAULT_BORDER</span></span> | <span data-ttu-id="32aee-693">Цвет границы мини-приложения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-693">Default widget border color</span></span> |
| <span data-ttu-id="32aee-694">GX_COLOR_ID_WINDOW_BORDER</span><span class="sxs-lookup"><span data-stu-id="32aee-694">GX_COLOR_ID_WINDOW_BORDER</span></span> | <span data-ttu-id="32aee-695">Цвет границы окна по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-695">Default window border color</span></span> |
| <span data-ttu-id="32aee-696">GX_COLOR_ID_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-696">GX_COLOR_ID_TEXT</span></span> | <span data-ttu-id="32aee-697">Цвет текста по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-697">Default text color</span></span> |
| <span data-ttu-id="32aee-698">GX_COLOR_ID_SELECTED_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-698">GX_COLOR_ID_SELECTED_TEXT</span></span> | <span data-ttu-id="32aee-699">Цвет выбранного текста по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-699">Default selected text color</span></span> |
| <span data-ttu-id="32aee-700">GX_COLOR_ID_DISABLED_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-700">GX_COLOR_ID_DISABLED_TEXT</span></span> | <span data-ttu-id="32aee-701">Цвет отключенного текста по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-701">Default disabled text color</span></span> |
| <span data-ttu-id="32aee-702">GX_COLOR_ID_SELECTED_TEXT_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-702">GX_COLOR_ID_SELECTED_TEXT_FILL</span></span> | <span data-ttu-id="32aee-703">Цвет заливки выбранного текста по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-703">Default selected text fill color</span></span> |
| <span data-ttu-id="32aee-704">GX_COLOR_ID_READONLY_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-704">GX_COLOR_ID_READONLY_TEXT</span></span> | <span data-ttu-id="32aee-705">Цвет текста только для чтения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-705">Default readonly text color</span></span> |
| <span data-ttu-id="32aee-706">GX_COLOR_ID_READONLY_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-706">GX_COLOR_ID_READONLY_FILL</span></span> | <span data-ttu-id="32aee-707">Цвет заливки текста только для чтения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-707">Default readonly text fill color</span></span> |
| <span data-ttu-id="32aee-708">GX_COLOR_ID_SCROLL_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-708">GX_COLOR_ID_SCROLL_FILL</span></span> |    <span data-ttu-id="32aee-709">Цвет заливки полосы прокрутки</span><span class="sxs-lookup"><span data-stu-id="32aee-709">Scrollbar fill color</span></span> |
| <span data-ttu-id="32aee-710">GX_COLOR_ID_SCROLL_BUTTON</span><span class="sxs-lookup"><span data-stu-id="32aee-710">GX_COLOR_ID_SCROLL_BUTTON</span></span> | <span data-ttu-id="32aee-711">Цвет заливки кнопки полосы прокрутки</span><span class="sxs-lookup"><span data-stu-id="32aee-711">Scrollbar button fill color</span></span> |
| <span data-ttu-id="32aee-712">GX_COLOR_ID_SHADOW</span><span class="sxs-lookup"><span data-stu-id="32aee-712">GX_COLOR_ID_SHADOW</span></span> | <span data-ttu-id="32aee-713">Цвет тени по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-713">Default shadow color</span></span> |
| <span data-ttu-id="32aee-714">GX_COLOR_ID_SHINE</span><span class="sxs-lookup"><span data-stu-id="32aee-714">GX_COLOR_ID_SHINE</span></span> | <span data-ttu-id="32aee-715">Цвет выделения по умолчанию</span><span class="sxs-lookup"><span data-stu-id="32aee-715">Default highlight color</span></span> |
| <span data-ttu-id="32aee-716">GX_COLOR_ID_BUTTON_BORDER</span><span class="sxs-lookup"><span data-stu-id="32aee-716">GX_COLOR_ID_BUTTON_BORDER</span></span> | <span data-ttu-id="32aee-717">Цвет границы мини-приложения кнопки</span><span class="sxs-lookup"><span data-stu-id="32aee-717">Button widget border color</span></span> |
| <span data-ttu-id="32aee-718">GX_COLOR_ID_BUTTON_UPPER</span><span class="sxs-lookup"><span data-stu-id="32aee-718">GX_COLOR_ID_BUTTON_UPPER</span></span> | <span data-ttu-id="32aee-719">Цвет верхней заливки мини-приложения кнопки</span><span class="sxs-lookup"><span data-stu-id="32aee-719">Button widget upper fill color</span></span> |
| <span data-ttu-id="32aee-720">GX_COLOR_ID_BUTTON_LOWER</span><span class="sxs-lookup"><span data-stu-id="32aee-720">GX_COLOR_ID_BUTTON_LOWER</span></span> | <span data-ttu-id="32aee-721">Цвет нижней заливки мини-приложения кнопки</span><span class="sxs-lookup"><span data-stu-id="32aee-721">Button widget lower fill color</span></span> |
| <span data-ttu-id="32aee-722">GX_COLOR_ID_BUTTON_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-722">GX_COLOR_ID_BUTTON_TEXT</span></span> | <span data-ttu-id="32aee-723">Цвет текста мини-приложения кнопки</span><span class="sxs-lookup"><span data-stu-id="32aee-723">Button widget text color</span></span> |
| <span data-ttu-id="32aee-724">GX_COLOR_ID_TEXT_INPUT_TEXT</span><span class="sxs-lookup"><span data-stu-id="32aee-724">GX_COLOR_ID_TEXT_INPUT_TEXT</span></span> | <span data-ttu-id="32aee-725">Цвет текста мини-приложения ввода текста</span><span class="sxs-lookup"><span data-stu-id="32aee-725">Text input widget text color</span></span> |
| <span data-ttu-id="32aee-726">GX_COLOR_ID_TEXT_INPUT_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-726">GX_COLOR_ID_TEXT_INPUT_FILL</span></span> | <span data-ttu-id="32aee-727">Цвет заливки текстового поля</span><span class="sxs-lookup"><span data-stu-id="32aee-727">Text input fill color</span></span> |
| <span data-ttu-id="32aee-728">GX_COLOR_ID_SLIDER_TICK</span><span class="sxs-lookup"><span data-stu-id="32aee-728">GX_COLOR_ID_SLIDER_TICK</span></span> | <span data-ttu-id="32aee-729">Цвет, используемый для рисования делений ползунка</span><span class="sxs-lookup"><span data-stu-id="32aee-729">Color used to draw slider tick marks.</span></span> |
| <span data-ttu-id="32aee-730">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span><span class="sxs-lookup"><span data-stu-id="32aee-730">GX_COLOR_ID_SLIDER_GROOVE_BOTTOM</span></span> | <span data-ttu-id="32aee-731">Цвет, используемый для рисования бороздки ползунка</span><span class="sxs-lookup"><span data-stu-id="32aee-731">Color used to draw slider groove</span></span> |
| <span data-ttu-id="32aee-732">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span><span class="sxs-lookup"><span data-stu-id="32aee-732">GX_COLOR_ID_SLIDER_NEEDLE_OUTLINE</span></span> | <span data-ttu-id="32aee-733">Цвет, используемый для рисования контура стрелки</span><span class="sxs-lookup"><span data-stu-id="32aee-733">Color used to draw needle outline</span></span> |
| <span data-ttu-id="32aee-734">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span><span class="sxs-lookup"><span data-stu-id="32aee-734">GX_COLOR_ID_SLIDER_NEEDLE_FILL</span></span> | <span data-ttu-id="32aee-735">Цвет, используемый для заполнения стрелки ползунка</span><span class="sxs-lookup"><span data-stu-id="32aee-735">Color used to fill slider needle</span></span> |
| <span data-ttu-id="32aee-736">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span><span class="sxs-lookup"><span data-stu-id="32aee-736">GX_COLOR_ID_SLIDER_NEEDLE_LINE1</span></span> | <span data-ttu-id="32aee-737">Цвет, используемый для рисования выделения стрелки</span><span class="sxs-lookup"><span data-stu-id="32aee-737">Color used to draw needle highlight</span></span> |
| <span data-ttu-id="32aee-738">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span><span class="sxs-lookup"><span data-stu-id="32aee-738">GX_COLOR_ID_SLIDER_NEEDLE_LINE2</span></span> | <span data-ttu-id="32aee-739">Цвет, используемый для рисования тени стрелки</span><span class="sxs-lookup"><span data-stu-id="32aee-739">Color used to draw needle shadow</span></span> |

<span data-ttu-id="32aee-740">Эти значения идентификатора цвета сопоставляются со значением цвета, определенным в таблице цветов, назначенной каждому из дисплеев.</span><span class="sxs-lookup"><span data-stu-id="32aee-740">These color ID values are mapped to a specific color value as defined by the color table assigned to each display.</span></span> <span data-ttu-id="32aee-741">Эти значения по умолчанию можно изменить как группу для одного дисплея, вызвав функцию API ***gx_display_color_table_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-741">These defaults can be changed as a group for one display by calling the ***gx_display_color_table_set*** API function.</span></span> <span data-ttu-id="32aee-742">Если используется GUIX Studio, таблица цветов дисплея автоматически инициализируется, когда приложение вызывает функцию ***gx_studio_display_configure***.</span><span class="sxs-lookup"><span data-stu-id="32aee-742">If you are using GUIX Studio, the display color table is automatically initialized when your application calls the ***gx_studio_display_configure*** function.</span></span>

<span data-ttu-id="32aee-743">Компонент дисплея GUIX также поддерживает таблицу шрифтов по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="32aee-743">The GUIX display component also maintains a default font table.</span></span> <span data-ttu-id="32aee-744">Таблица шрифтов по умолчанию определяет шрифт, используемый для каждого типа мини-приложения, если он не указан приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-744">The default font table defines the font used by each widget type unless specifically specified by the application.</span></span> <span data-ttu-id="32aee-745">К предварительно определенным идентификаторам таблицы шрифтов дисплея относятся указанные ниже значения.</span><span class="sxs-lookup"><span data-stu-id="32aee-745">The pre-defined display font table IDs include the following values.</span></span>

| <span data-ttu-id="32aee-746">Идентификатор&nbsp;шрифта</span><span class="sxs-lookup"><span data-stu-id="32aee-746">Font&nbsp;ID</span></span> | <span data-ttu-id="32aee-747">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-747">Description</span></span> |
| ------------------ | --------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="32aee-748">GX_FONT_ID_DEFAULT</span><span class="sxs-lookup"><span data-stu-id="32aee-748">GX_FONT_ID_DEFAULT</span></span> | <span data-ttu-id="32aee-749">Шрифт по умолчанию, используемый, когда не определен конкретный шрифт</span><span class="sxs-lookup"><span data-stu-id="32aee-749">Default font used when no specific font is defined</span></span> |
| <span data-ttu-id="32aee-750">GX_FONT_ID_BUTTON</span><span class="sxs-lookup"><span data-stu-id="32aee-750">GX_FONT_ID_BUTTON</span></span> | <span data-ttu-id="32aee-751">Шрифт по умолчанию, используемый для всего текста на кнопках</span><span class="sxs-lookup"><span data-stu-id="32aee-751">Default font used for all text on buttons</span></span> |
| <span data-ttu-id="32aee-752">GX_FONT_ID_TEXT_INPUT</span><span class="sxs-lookup"><span data-stu-id="32aee-752">GX_FONT_ID_TEXT_INPUT</span></span> | <span data-ttu-id="32aee-753">Шрифт по умолчанию, используемый для полей редактирования текста</span><span class="sxs-lookup"><span data-stu-id="32aee-753">Default font used for text edit fields</span></span> |

<span data-ttu-id="32aee-754">Идентификатор шрифта, используемый любым мини-приложением типа текста, можно переназначить с помощью API **gx_<widget_type>_font_set**, который предоставляется для каждого типа мини-приложения, связанного с текстом.</span><span class="sxs-lookup"><span data-stu-id="32aee-754">The font ID used by any text type widget can be re-assigned by using the **gx_<widget_type>_font_set** API provided for each text-related widget type.</span></span> <span data-ttu-id="32aee-755">Всю таблицу шрифтов можно переназначить, вызвав функцию API **gx_display_font_table_set**.</span><span class="sxs-lookup"><span data-stu-id="32aee-755">The entire font table can be re-assigned by calling the **gx_display_font_table_set** API function.</span></span>

### <a name="scrollbar-appearance"></a><span data-ttu-id="32aee-756">Внешний вид полосы прокрутки</span><span class="sxs-lookup"><span data-stu-id="32aee-756">Scrollbar Appearance</span></span> 

<span data-ttu-id="32aee-757">Дисплей GUIX также поддерживает параметры внешнего вида полосы прокрутки по умолчанию для соответствующего дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-757">GUIX Display also maintains default scrollbar appearance settings for that display.</span></span> <span data-ttu-id="32aee-758">Эти параметры определяются структурой **GX_SCROLLBAR_APPEARANCE**, которая определена ниже.</span><span class="sxs-lookup"><span data-stu-id="32aee-758">These settings are defined by the **GX_SCROLLBAR_APPEARANCE** structure which is defined below.</span></span> <span data-ttu-id="32aee-759">Дисплей GUIX поддерживает одну структуру внешнего вида для вертикальных полос прокрутки и другую структуру — для горизонтальных полос прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-759">GUIX Display maintains one scrollbar appearance structure for vertical scrollbars and a second structure for horizontal scroll bars.</span></span> <span data-ttu-id="32aee-760">Приложение может изменить внешний вид полосы прокрутки по умолчанию для любого дисплея, инициализируя структуру **GX_SCROLLBAR_APPEARANCE** и вызывая функцию API ***gx_display_scroll_appearance_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-760">The application can modify the default scrollbar appearance for any display by initializing a **GX_SCROLLBAR_APPEARANCE** structure and invoking the API function ***gx_display_scroll_appearance_set***.</span></span>

```c
typedef struct GX_SCROLLBAR_APPEARANCE_STRUCT
{
    GX_VALUE       gx_scroll_width;
    GX_VALUE       gx_scroll_thumb_width;
    GX_VALUE       gx_scroll_thumb_travel_min;
    GX_VALUE       gx_scroll_thumb_travel_max;
    GX_UBYTE       gx_scroll_thumb_border_style;
    GX_RESOURCE_ID gx_scroll_fill_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_pixelmap;
    GX_RESOURCE_ID gx_scroll_up_pixelmap;
    GX_RESOURCE_ID gx_scroll_down_pixelmap;
    GX_RESOURCE_ID gx_scroll_thumb_color;
    GX_RESOURCE_ID gx_scroll_thumb_border_color;
    GX_RESOURCE_ID gx_scroll_button_color;
} GX_SCROLLBAR_APPEARANCE;
```
| <span data-ttu-id="32aee-761">Элемент структуры GX_SCROLLBAR_APPEARANCE</span><span class="sxs-lookup"><span data-stu-id="32aee-761">GX_SCROLLBAR_APPEARANCE Structure Member</span></span> | <span data-ttu-id="32aee-762">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-762">Description</span></span> |
| --- | --- |
| <span data-ttu-id="32aee-763">gx_scroll_width</span><span class="sxs-lookup"><span data-stu-id="32aee-763">gx_scroll_width</span></span> | <span data-ttu-id="32aee-764">Ширина вертикальной полосы прокрутки или высота горизонтальной полосы прокрутки (в пикселях).</span><span class="sxs-lookup"><span data-stu-id="32aee-764">Width of a vertical scrollbar or height of a horizontal scrollbar, in pixels.</span></span> |
| <span data-ttu-id="32aee-765">gx_scroll_thumb_width</span><span class="sxs-lookup"><span data-stu-id="32aee-765">gx_scroll_thumb_width</span></span> | <span data-ttu-id="32aee-766">Ширина вертикального ползунка и конечных кнопок (в пикселях).</span><span class="sxs-lookup"><span data-stu-id="32aee-766">Width of the elevator and end buttons, in pixels.</span></span> |
| <span data-ttu-id="32aee-767">gx_scroll_thumb_travel_max</span><span class="sxs-lookup"><span data-stu-id="32aee-767">gx_scroll_thumb_travel_max</span></span> | <span data-ttu-id="32aee-768">Смещение от конца полосы прокрутки до точки максимального хода кнопки ползунка.</span><span class="sxs-lookup"><span data-stu-id="32aee-768">Offset from the end of scroll bar to maximum thumb button travel point.</span></span> |
| <span data-ttu-id="32aee-769">gx_scroll_fill_pixelmap</span><span class="sxs-lookup"><span data-stu-id="32aee-769">gx_scroll_fill_pixelmap</span></span> | <span data-ttu-id="32aee-770">Пиксельная карта, используемая для заливки фона полосы прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-770">Pixelmap used to fill scroll background.</span></span> |
| <span data-ttu-id="32aee-771">gx_scroll_thumb_pixelmap</span><span class="sxs-lookup"><span data-stu-id="32aee-771">gx_scroll_thumb_pixelmap</span></span> | <span data-ttu-id="32aee-772">Пиксельная карта, используемая для рисования кнопки ползунка.</span><span class="sxs-lookup"><span data-stu-id="32aee-772">Pixelmap used to draw scroll thumb button.</span></span> |
| <span data-ttu-id="32aee-773">gx_scroll_up_pixelmap</span><span class="sxs-lookup"><span data-stu-id="32aee-773">gx_scroll_up_pixelmap</span></span> | <span data-ttu-id="32aee-774">Пиксельная карта, используемая для рисования кнопки прокрутки вверх.</span><span class="sxs-lookup"><span data-stu-id="32aee-774">Pixelmap used to draw scroll up button.</span></span> |
| <span data-ttu-id="32aee-775">gx_scroll_down_pixelmap</span><span class="sxs-lookup"><span data-stu-id="32aee-775">gx_scroll_down_pixelmap</span></span> | <span data-ttu-id="32aee-776">Пиксельная карта, используемая для рисования кнопки прокрутки вниз.</span><span class="sxs-lookup"><span data-stu-id="32aee-776">Pixelmap used to draw scroll down button.</span></span> |
| <span data-ttu-id="32aee-777">gx_scroll_fill_color</span><span class="sxs-lookup"><span data-stu-id="32aee-777">gx_scroll_fill_color</span></span> | <span data-ttu-id="32aee-778">Идентификатор цвета, используемый для заполнения фона полосы прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-778">Color ID of color used to fill scrollbar background.</span></span> |
| <span data-ttu-id="32aee-779">gx_scroll_button_color</span><span class="sxs-lookup"><span data-stu-id="32aee-779">gx_scroll_button_color</span></span> | <span data-ttu-id="32aee-780">Идентификатор цвета, используемый для заполнения кнопки бегунка полосы прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-780">Color ID of color used to fill scrollbar thumb button.</span></span> |

<span data-ttu-id="32aee-781">Помимо этих параметров по умолчанию для шрифтов, цветов и стилей, приложение может указать любой из параметров в индивидуальном порядке с помощью API, предоставляемого каждым типом мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-781">In addition to these default settings for fonts, color, and styles, the application may specify any of the parameters on a case by case basis as desired using API provided by each widget type.</span></span>

### <a name="skinning-and-themes"></a><span data-ttu-id="32aee-782">Создание обложек и темы</span><span class="sxs-lookup"><span data-stu-id="32aee-782">Skinning and Themes</span></span>

<span data-ttu-id="32aee-783">Создавая обложки, можно легко изменять базовый внешний вид мини-приложений и окон GUIX, так как при изменении обложки в одном месте изменится базовый внешний вид всех связанных мини-приложений и окон.</span><span class="sxs-lookup"><span data-stu-id="32aee-783">Skinning allows GUIX widgets and windows to easily change their base appearance, i.e., changing the “skin” in one place will change the base appearance of all associated widgets and windows.</span></span>

<span data-ttu-id="32aee-784">Для повторного создания обложки приложения GUIX необходимо предоставить новые цвет, шрифт и таблицу пиксельных карт для таблиц ресурсов дисплея GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-784">Re-skinning your GUIX application requires that you supply a new color, font and or pixelmap table to the GUIX Display resource tables.</span></span> <span data-ttu-id="32aee-785">Так как все мини-приложения GUIX ссылаются на цвет, растровое изображение или шрифт с помощью идентификатора ресурсов, при предоставлении новой таблицы ресурсов все мини-приложения GUIX автоматически используют новые цвета и пиксельные карты, когда выполняется их рисование на соответствующем дисплее.</span><span class="sxs-lookup"><span data-stu-id="32aee-785">Since all GUIX widgets refer to their color, bitmap, or font by resource ID, providing a new resource table automatically causes all GUIX widgets to begin using your new colors and pixelmaps when they draw themselves to the desired display.</span></span>

<span data-ttu-id="32aee-786">Новый набор шрифтов, цветов и пиксельных карт, предназначенных для создания привлекательного внешнего вида, называется *темой*.</span><span class="sxs-lookup"><span data-stu-id="32aee-786">A new set of fonts, colors, and pixelmaps that are designed to work together to provide an attractive appearance is called a *theme*.</span></span> <span data-ttu-id="32aee-787">Тема определяет набор таблиц ресурсов и размер каждой таблицы ресурсов.</span><span class="sxs-lookup"><span data-stu-id="32aee-787">A theme defines a set of resource tables and the size of each resource table.</span></span> <span data-ttu-id="32aee-788">С помощью приложения GUIX Studio для любого дисплея можно определить любое количество тем.</span><span class="sxs-lookup"><span data-stu-id="32aee-788">Any number of themes can be defined for any display using the GUIX Studio application.</span></span> <span data-ttu-id="32aee-789">Необходимо передать начальный индекс темы в функцию ***gx_studio_display_configure***, которая создается в GUIX Studio и устанавливает исходную тему для созданного дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-789">You must pass the starting theme index to the GUIX Studio generated function ***gx_studio_display_configure***, which installs the initial theme into the created display.</span></span> <span data-ttu-id="32aee-790">Активную тему для любого дисплея можно изменить в любое время, вызвав функцию ***gx_display_theme_install***.</span><span class="sxs-lookup"><span data-stu-id="32aee-790">The active theme for any display can be changed at any time by calling the function ***gx_display_theme_install***.</span></span>

### <a name="root-window"></a><span data-ttu-id="32aee-791">Корневое окно</span><span class="sxs-lookup"><span data-stu-id="32aee-791">Root Window</span></span>

<span data-ttu-id="32aee-792">Для каждого созданного приложением видимого холста приложение должно также создать одно корневое окно для соответствующего холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-792">For each visible canvas created by an application, the application must also create one Root Window for that canvas.</span></span> <span data-ttu-id="32aee-793">Это специальное окно по сути выступает в качестве контейнера для всех окон и мини-приложений верхнего уровня приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-793">This special window basically acts as a container for all the top-level application windows and widgets.</span></span> <span data-ttu-id="32aee-794">С помощью корневого окна выполняется рисование фона холста. Так как корневое окно является производным элементом от класса **GX_WINDOW**, корневое окно может также иметь фоновый рисунок.</span><span class="sxs-lookup"><span data-stu-id="32aee-794">The root window draws the canvas background, and since the root window is derived from the **GX_WINDOW** class the root window can also have wallpaper.</span></span> <span data-ttu-id="32aee-795">Чтобы изменить цвет фона для дисплея или холста, нужно просто изменить цвет заливки корневого окна, подключенного к этому холсту.</span><span class="sxs-lookup"><span data-stu-id="32aee-795">To change the background color of your display or canvas, you simply change the fill color of the root window attached to that canvas.</span></span>

<span data-ttu-id="32aee-796">Если для настройки дисплеев используется созданная в GUIX Studio функция с именем ***gx_studio_display_configure***, то холст и корневое окно для каждого дисплея создаются как часть этой функции инициализации.</span><span class="sxs-lookup"><span data-stu-id="32aee-796">If you use the GUIX Studio generated function named ***gx_studio_display_configure*** to configure your displays, then the canvas and root window for each display are created for you as part of this initialization function.</span></span>

### <a name="anti-aliasing"></a><span data-ttu-id="32aee-797">Сглаживание</span><span class="sxs-lookup"><span data-stu-id="32aee-797">Anti-Aliasing</span></span> 

<span data-ttu-id="32aee-798">Сглаживание — это дополнительная функция в GUIX, которая используется для сглаживания линий, кривых и шрифтов.</span><span class="sxs-lookup"><span data-stu-id="32aee-798">Anti-Aliasing is an optional feature in GUIX that is used to smooth lines, curves, and fonts.</span></span> <span data-ttu-id="32aee-799">Сглаживание поддерживается только при использовании драйвера дисплея с глубиной цвета 16 бит/пкс или выше.</span><span class="sxs-lookup"><span data-stu-id="32aee-799">Anti-aliasing is only supported when running with a display driver utilizing 16-bpp or higher color depth.</span></span>

<span data-ttu-id="32aee-800">Рисование линий со сглаживанием можно включить путем установки вспышки **GX_BRUSH_ALIAS** для активной кисти.</span><span class="sxs-lookup"><span data-stu-id="32aee-800">Anti-aliased line drawing is enabled by setting the **GX_BRUSH_ALIAS** flash in the active brush.</span></span> <span data-ttu-id="32aee-801">Эту функцию можно применить к обычным нарисованным линиям, а также к линиям, нарисованным в качестве границы многоугольника или круга.</span><span class="sxs-lookup"><span data-stu-id="32aee-801">This applies to lines drawn directly as well as to lines drawn as the border of a polygon or circle.</span></span>

<span data-ttu-id="32aee-802">Рисование текста со сглаживанием можно включить с помощью соответствующего инструмента шрифта со сглаживанием, который создается приложением GUIX Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-802">Anti-aliased text drawing is enabled by using an anti-aliased font which is produced by the GUIX studio application.</span></span> <span data-ttu-id="32aee-803">При создании шрифта необходимо указать, должен ли шрифт создаваться как сглаженный или двоичный.</span><span class="sxs-lookup"><span data-stu-id="32aee-803">You specify whether a font should be generated as antialiased or binary when you create the font.</span></span>
<span data-ttu-id="32aee-804">В GUIX для шрифтов со сглаживанием используется 16 уровней прозрачности для каждого пикселя.</span><span class="sxs-lookup"><span data-stu-id="32aee-804">Anti-aliased fonts in GUIX utilize 16 levels of transparency for each pixel.</span></span>

### <a name="clipping"></a><span data-ttu-id="32aee-805">Усечение</span><span class="sxs-lookup"><span data-stu-id="32aee-805">Clipping</span></span> 

<span data-ttu-id="32aee-806">Возможность обрезки поддерживается на внутреннем уровне компонентом дисплея GUIX, а также на уровнях окон и мини-приложений с помощью архитектуры "родительский элемент — дочерний элемент", которая поддерживается мини-приложениями GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-806">Clipping is supported internally by the GUIX display component, and at the window and widget layers by the parent-child architecture maintained by GUIX widgets.</span></span> <span data-ttu-id="32aee-807">Ни в окне, ни в мини-приложении не разрешено рисовать за пределами соответствующей области мини-приложения. Кроме того, в мини-приложении не разрешено рисовать за пределами области соответствующего родительского элемента мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-807">No window or widget is ever allowed to draw outside of that widget’s area, and a widget is never allowed to draw outside of the area of that widget’s parent.</span></span>

<span data-ttu-id="32aee-808">При этом мини-приложения также не могут выполнять рисование, используя пиксельные координаты, которые расположены за пределами памяти холста, так как может возникнуть повреждение памяти или сбой системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-808">This also prevents widgets from drawing at pixel coordinates that lay outside of the canvas memory which likely lead to memory corruption or a system failure.</span></span> <span data-ttu-id="32aee-809">Мини-приложения не могут выполнять операцию рисования за пределами области мини-приложения, родительской области мини-приложения или за пределами экстента холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-809">Widgets are not allowed to draw outside of the widget’s area, the widget’s parent area, or beyond the canvas extent.</span></span>

<span data-ttu-id="32aee-810">Кроме того, мини-приложения могут выполнять операцию рисования только в тех областях, которые ранее были помечены как "грязные".</span><span class="sxs-lookup"><span data-stu-id="32aee-810">In addition, widgets can only draw to areas that have previously been marked as dirty.</span></span> <span data-ttu-id="32aee-811">Таким образом предотвращается рисование во всем окне, например, когда отображен только угол окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-811">This prevents an entire window being drawn, for example, when only a corner of the window has been revealed.</span></span> <span data-ttu-id="32aee-812">Только часть окна, которую действительно требуется обновить, помечается как "грязная". Поэтому функция рисования в окне обновляет пиксели только в "грязной" области.</span><span class="sxs-lookup"><span data-stu-id="32aee-812">Only the portion of the window that actually needs to be refreshed is marked as dirty, and so the window drawing function only truly refreshes pixels in the dirty area.</span></span>

<span data-ttu-id="32aee-813">Компонент дисплея GUIX применяет соответствующие алгоритмы обрезки перед вызовом функций рисования на уровне драйвера.</span><span class="sxs-lookup"><span data-stu-id="32aee-813">The GUIX dispaly component enforces these clipping algorithms before invoking the driver level drawing functions.</span></span>

### <a name="views"></a><span data-ttu-id="32aee-814">Представления</span><span class="sxs-lookup"><span data-stu-id="32aee-814">Views</span></span> 

<span data-ttu-id="32aee-815">В GUIX всегда хранится набор представлений для каждого корневого окна и каждого дочернего окна корневого окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-815">GUIX always maintains a set of views for each root window and each child window of the root window.</span></span> <span data-ttu-id="32aee-816">Представления — это динамическая, определяемая во время выполнения область обрезки, которая изменяется при изменении расположения окна и Z-порядка.</span><span class="sxs-lookup"><span data-stu-id="32aee-816">Views are a dynamic, run-time determined clipping area that changes as window position and Z-order are modified.</span></span>
<span data-ttu-id="32aee-817">GUIX использует представления, чтобы предотвратить рисование в фоновых окне или мини-приложении поверх окна или мини-приложения на переднем плане.</span><span class="sxs-lookup"><span data-stu-id="32aee-817">GUIX uses views to prevent a window or widget in the background from drawing on top of a window or widget in the foreground.</span></span> <span data-ttu-id="32aee-818">Представления применяют дисциплину Z-порядка.</span><span class="sxs-lookup"><span data-stu-id="32aee-818">Views enforce Z-order discipline.</span></span> <span data-ttu-id="32aee-819">Кроме того, представления важны для повышения эффективности, так как они предотвращают рисование в фоновом окне в области холста, которая не отображается.</span><span class="sxs-lookup"><span data-stu-id="32aee-819">In addition, views are important for efficiency in that they prevent a window in the background from drawing to any area of the canvas that cannot be seen.</span></span> <span data-ttu-id="32aee-820">Если окно полностью перекрыто другим окном, перекрытому окну не разрешается выполнять рисование на холсте, даже если оно пытается это сделать.</span><span class="sxs-lookup"><span data-stu-id="32aee-820">If a window is completely covered by another window, the covered window will not be allowed to draw to the canvas at all, even if it is attempting to do so.</span></span>

### <a name="display-driver-interface"></a><span data-ttu-id="32aee-821">Интерфейс драйвера дисплея</span><span class="sxs-lookup"><span data-stu-id="32aee-821">Display Driver Interface</span></span> 

<span data-ttu-id="32aee-822">Драйверы дисплея GUIX позволяют выполнять все операции взаимодействия с базовым физическим экраном.</span><span class="sxs-lookup"><span data-stu-id="32aee-822">GUIX display drivers are responsible for all interaction with the underlying physical screen.</span></span> <span data-ttu-id="32aee-823">Драйверы дисплея имеют три основные функции: инициализация, рисование и отображение буфера кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-823">The display drivers have three basic functions: initialization, drawing, and frame buffer display.</span></span>
<span data-ttu-id="32aee-824">Инициализация используется для подготовки оборудования физического дисплея и передает в GUIX свойства оборудования физического дисплея, а также сообщает в GUIX, какие конкретные функции рисования следует использовать.</span><span class="sxs-lookup"><span data-stu-id="32aee-824">Initialization is responsible for preparing the physical display hardware, informing GUIX of the properties of the physical display hardware, and for informing GUIX which specific drawing functions should be used.</span></span> <span data-ttu-id="32aee-825">Инициализация основного драйвера дисплея вызывается из функции GUIX ***gx_display_create***.</span><span class="sxs-lookup"><span data-stu-id="32aee-825">The main display driver initialization is called from the GUIX ***gx_display_create*** function.</span></span> <span data-ttu-id="32aee-826">Кроме того, поток GUIX также вызывает инициализацию дополнительного драйвера дисплея из контекста потока.</span><span class="sxs-lookup"><span data-stu-id="32aee-826">In addition, the GUIX thread will also call a secondary display driver initialization from the thread context.</span></span> <span data-ttu-id="32aee-827">Этот дополнительный драйвер дисплея необходим только в том случае, если драйверу требуются службы ОСРВ во время инициализации (например, устройство прерывает работу или ***tx_thread_sleep*** запрашивает задержку между шагами в процессе инициализации).</span><span class="sxs-lookup"><span data-stu-id="32aee-827">This secondary display driver is only needed if the driver requires RTOS services during its initialization, e.g., device interrupts or ***tx_thread_sleep*** requests for delay between steps in the initialization process.</span></span>

<span data-ttu-id="32aee-828">После завершения инициализации драйвер дисплея выполняет рисование, которое допускается в физическом оборудовании дисплея.</span><span class="sxs-lookup"><span data-stu-id="32aee-828">Once initialization is complete, the display driver is responsible for any direct drawing that can be done in the physical display hardware.</span></span>
<span data-ttu-id="32aee-829">Наконец, драйвер дисплея отображает буфер кадров.</span><span class="sxs-lookup"><span data-stu-id="32aee-829">Finally, the display driver is responsible for displaying the frame buffer.</span></span>

## <a name="guix-widget-component"></a><span data-ttu-id="32aee-830">Компонент мини-приложения GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-830">GUIX Widget Component</span></span>

<span data-ttu-id="32aee-831">Мини-приложение GUIX — это видимый графический элемент.</span><span class="sxs-lookup"><span data-stu-id="32aee-831">A GUIX widget is a visible graphical element.</span></span> <span data-ttu-id="32aee-832">Используются компоненты GUIX, которые не являются видимыми, такие как таймеры и математические служебные функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-832">There are GUIX components which are not visible, such as timers and math utility functions.</span></span>
<span data-ttu-id="32aee-833">Но все видимые компоненты являются производными от базового компонента мини-приложения GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-833">However all visible components are derived from the basic GUIX widget component.</span></span> <span data-ttu-id="32aee-834">Мини-приложение GUIX — это основной стандартный блок дисплея GUIX. Все остальные графические элементы являются производными от базовой функции мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-834">A GUIX widget is the primary building block of the GUIX display – all other graphic elements are derived from the base widget functionality.</span></span>

<span data-ttu-id="32aee-835">Мини-приложения GUIX реализуются объектно-ориентированным методом с полной поддержкой наследования.</span><span class="sxs-lookup"><span data-stu-id="32aee-835">GUIX widgets are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="32aee-836">Это достигается с помощью ANSI C и позволяет максимально снизить требования к памяти и обработке.</span><span class="sxs-lookup"><span data-stu-id="32aee-836">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span> <span data-ttu-id="32aee-837">Если одно конкретное мини-приложение, например **GX_BUTTON**, является *производным от* другого мини-приложения, такого как базовое **GX_WIDGET**, это означает, что структура управления **GX_BUTTON** содержит все переменные-члены и указатели функций **GX_WIDGET**, а также некоторые дополнительные переменные, характерные для **GX_BUTTON**.</span><span class="sxs-lookup"><span data-stu-id="32aee-837">When we speak of one particular widget, such as **GX_BUTTON**, being *derived from* another widget, such as the base **GX_WIDGET**, what we mean is that the **GX_BUTTON** control structure contains all of the member variables and function pointers of **GX_WIDGET**, with some additional variables that are specific to **GX_BUTTON**.</span></span> <span data-ttu-id="32aee-838">GUIX создает слои мини-приложений таким образом, чтобы более сложные мини-приложения всегда основывались на более простом мини-приложении перед ними.</span><span class="sxs-lookup"><span data-stu-id="32aee-838">GUIX builds up layers of widgets in this fashion, so that more complex widgets are always based on a simpler widget before them.</span></span> <span data-ttu-id="32aee-839">Эта иерархическая модель выведения производных элементов упрощает использование API для изменения параметров мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-839">This hierarchical model of derivation makes it easier to learn the APIs used to modify widget parameters.</span></span> <span data-ttu-id="32aee-840">Если необходимо изменить цвет кнопки, используйте тот же API, который используется для изменения цвета мини-приложения, а именно ***gx_widget_fill_color_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-840">If you want to modify the color of a button, you use the same API you use to modify the color of a widget, namely ***gx_widget_fill_color_set***.</span></span>

<span data-ttu-id="32aee-841">Организация видимых мини-приложений обеспечивается с помощью структуры "родительский элемент — дочерний элемент" при использовании списков с древовидной структурой, связывающих дочерние мини-приложения с их родительскими элементами.</span><span class="sxs-lookup"><span data-stu-id="32aee-841">The organization of visible widgets is maintained in a parent-child manner using tree structured lists linking child widgets to their parents.</span></span> <span data-ttu-id="32aee-842">Дочерние элементы наследуют характеристики родительских элементов, таких как представления и холст, с помощью которых выполняется рисование.</span><span class="sxs-lookup"><span data-stu-id="32aee-842">The children inherit characteristics from their parents such as the views into which they can draw and the canvas on which they draw.</span></span>
<span data-ttu-id="32aee-843">Дочерние мини-приложения могут иметь собственные дочерние мини-приложения и наследовать различные характеристики родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="32aee-843">Child widgets may have their own child widgets, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="32aee-844">Характеристики любого мини-приложения можно переопределить с помощью различных вызовов API GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-844">The characteristics of any widget may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="widget-creation"></a><span data-ttu-id="32aee-845">Создание мини-приложения</span><span class="sxs-lookup"><span data-stu-id="32aee-845">Widget Creation</span></span> 

<span data-ttu-id="32aee-846">Объект мини-приложения можно создать во время инициализации или в любое время при выполнении потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-846">A widget object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="32aee-847">Количество объектов мини-приложения, которые можно создать с помощью приложения, не ограничено.</span><span class="sxs-lookup"><span data-stu-id="32aee-847">There is no limit on the number of widget objects that can be created by an application.</span></span> <span data-ttu-id="32aee-848">Кроме того, нет ограничений на количество дочерних элементов для мини-приложения с учетом ограничений памяти вашего целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-848">There is also no limit on the number of children any widget may have, within the memory limits of your target hardware.</span></span>

<span data-ttu-id="32aee-849">У каждого типа мини-приложения есть собственная функция операции создания, например ***gx_button_create** _ или _*_gx_prompt_create_\*\*.</span><span class="sxs-lookup"><span data-stu-id="32aee-849">Each widget type has its own create function, such as ***gx_button_create** _ or _*_gx_prompt_create_\*\*.</span></span> <span data-ttu-id="32aee-850">Первые три параметра этих функций всегда одинаковы — указатель на структуру управления мини-приложением, строковый указатель на имя мини-приложения и указатель на его родительский элемент.</span><span class="sxs-lookup"><span data-stu-id="32aee-850">The first three parameters to these functions are always the same, namely a pointer to the widget control structure, a string pointer to the widget name, and a pointer to the widget’s parent.</span></span> <span data-ttu-id="32aee-851">Каждая функция создания может иметь любое количество дополнительных параметров в зависимости от требований конкретного типа мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-851">Each create function may have any number of additional parameters depending on the requirements of that particular widget type.</span></span>

### <a name="widget-control-block"></a><span data-ttu-id="32aee-852">Блок управления мини-приложением</span><span class="sxs-lookup"><span data-stu-id="32aee-852">Widget Control Block</span></span> 

<span data-ttu-id="32aee-853">Характеристики каждого объекта мини-приложения расположены в блоке управления \***GX_WIDGET** _ и определены в **_gx_api.h_**.</span><span class="sxs-lookup"><span data-stu-id="32aee-853">The characteristics of each widget object are found in its control block **GX_WIDGET** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="32aee-854">Память, необходимая для объекта мини-приложения, предоставляется приложением и может находиться в любом месте в основной памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-854">The memory required for a widget object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="32aee-855">Однако чаще всего блок управления объектом мини-приложения становится глобальной структурой путем его определения вне области какой-либо функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-855">However, it is most common to make the widget object control block a global structure by defining it outside the scope of any function.</span></span> <span data-ttu-id="32aee-856">Если используется GUIX Studio, блоки управления мини-приложением можно выделить статически в файле спецификаций GUIX Studio. Кроме того, их можно выделить динамически с помощью приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-856">If you are using GUIX Studio, your widget control blocks can be statically allocated within your Studio generated specifications file, or they can be dynamically allocated by your application.</span></span>

### <a name="dynamic-widget-control-block-allocation-and-de-allocation"></a><span data-ttu-id="32aee-857">Динамическое выделение блока управления мини-приложением и отмена выделения</span><span class="sxs-lookup"><span data-stu-id="32aee-857">Dynamic Widget Control Block Allocation and De-allocation</span></span> 

<span data-ttu-id="32aee-858">Если используется динамическое выделение блока управления, необходимо определить две функции, которые GUIX может использовать для выделения и освобождения памяти, необходимой для блоков управления мини-приложениями.</span><span class="sxs-lookup"><span data-stu-id="32aee-858">If you are using dynamic control block allocation, you will need to define two functions that GUIX will use to allocate and free the memory required for your widget control blocks.</span></span> <span data-ttu-id="32aee-859">Функции управления памятью передаются в системный компонент GUIX с помощью функции API ***gx_system_memory_allocator_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-859">Your functions for memory management are passed to the GUIX system component via the ***gx_system_memory_allocator_set*** API function.</span></span> <span data-ttu-id="32aee-860">Эта функция позволяет передавать два указателя функций в GUIX: первый — указатель на функцию выделения памяти, а второй — указатель на функцию освобождения памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-860">This function allows you to pass two function pointers into GUIX: the first is a pointer to a memory allocation function, and the second is a pointer to a memory free function.</span></span> <span data-ttu-id="32aee-861">Чаще всего эти функции реализуются с помощью пулов байтов ThreadX, но структура GUIX позволяет реализовать динамическое управление памятью любым предпочтительным способом.</span><span class="sxs-lookup"><span data-stu-id="32aee-861">Most often, you will implement these functions using ThreadX byte pools, but the design of GUIX allows you to implement dynamic memory management in whatever way you prefer.</span></span>

<span data-ttu-id="32aee-862">Динамическое выделение мини-приложений чаще всего используется в файле спецификаций приложения Studio при выборе параметра Dynamically allocated (Динамически выделенное) в поле свойств мини-приложения Studio.</span><span class="sxs-lookup"><span data-stu-id="32aee-862">Dynamic widget allocation is most often employed within your Studio generated application specifications file, when you select the “dynamically allocated” option in the Studio widget properties field.</span></span> <span data-ttu-id="32aee-863">Однако в приложении можно также использовать динамическое выделение блоков управления.</span><span class="sxs-lookup"><span data-stu-id="32aee-863">However, you can also use dynamic control block allocation within your application.</span></span> <span data-ttu-id="32aee-864">Если в приложении используется динамическое выделение блока управления, следует вызвать функцию API \***gx_widget_allocate** _, чтобы выделить блок управления мини-приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-864">If you use dynamic control block allocation within your application, you should invoke the \***gx_widget_allocate** _ API function to allocate the widget control block.</span></span> <span data-ttu-id="32aee-865">Затем при создании мини-приложения убедитесь, что вы передали флаг стиля _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* (вместе с любыми другими необходимыми флагами стиля) для функции создания мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-865">Next, when you create the widget, make certain you pass the _ *GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED*\* style flag (along with any other needed style flags) to the widget create function.</span></span> <span data-ttu-id="32aee-866">Этот флаг используется для пометки мини-приложения в поле состояния как динамически выделенного.</span><span class="sxs-lookup"><span data-stu-id="32aee-866">This flag is used to mark the widget as being dynamically allocated in the widget status field.</span></span> <span data-ttu-id="32aee-867">Если мини-приложение удалено с помощью **_gx_widget_delete_**, GUIX проверяет это поле состояния и автоматически вызывает функцию отмены выделения памяти, чтобы убедиться в отсутствии утечек памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-867">When and if the widget is later deleted using **_gx_widget_delete_**, GUIX will check this status field and automatically call your memory de-allocator function to insure there are no memory leaks.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-868">Мини-приложение, созданное с помощью динамически выделенного блока управления, должно быть создано с использованием флага стиля **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** для предотвращения потери памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-868">A widget created using a dynamically allocated control block must be created with the **GX_WIDGET_STYLE_DYNAMICALLY_ALLOCATED** style flag to prevent memory loss.</span></span>

### <a name="types"></a><span data-ttu-id="32aee-869">Типы</span><span class="sxs-lookup"><span data-stu-id="32aee-869">Types</span></span>

<span data-ttu-id="32aee-870">GUIX предоставляет расширенный полнофункциональный набор встроенных мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-870">GUIX provides a rich, fully functional set of built-in widgets.</span></span> <span data-ttu-id="32aee-871">Как упоминалось ранее, все специализированные мини-приложения являются производными от базового мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-871">As mentioned previously, all specialized widgets are derived from the base widget.</span></span> <span data-ttu-id="32aee-872">Ниже приведен список встроенных мини-приложений в GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-872">Following is a list of the built-in widgets in GUIX:</span></span>

<span data-ttu-id="32aee-873">**GX_TYPE_WIDGET**</span><span class="sxs-lookup"><span data-stu-id="32aee-873">**GX_TYPE_WIDGET**</span></span>

<span data-ttu-id="32aee-874">**GX_TYPE_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-874">**GX_TYPE_BUTTON**</span></span>

<span data-ttu-id="32aee-875">**GX_TYPE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-875">**GX_TYPE_TEXT_BUTTON**</span></span>

<span data-ttu-id="32aee-876">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-876">**GX_TYPE_MULTI_LINE_TEXT_BUTTON**</span></span>

<span data-ttu-id="32aee-877">**GX_TYPE_RADIO_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-877">**GX_TYPE_RADIO_BUTTON**</span></span>

<span data-ttu-id="32aee-878">**GX_TYPE_CHECKBOX**</span><span class="sxs-lookup"><span data-stu-id="32aee-878">**GX_TYPE_CHECKBOX**</span></span>

<span data-ttu-id="32aee-879">**GX_TYPE_PIXELMAP_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-879">**GX_TYPE_PIXELMAP_BUTTON**</span></span>

<span data-ttu-id="32aee-880">**GX_TYPE_ICON_BUTTON**</span><span class="sxs-lookup"><span data-stu-id="32aee-880">**GX_TYPE_ICON_BUTTON**</span></span>

<span data-ttu-id="32aee-881">**GX_TYPE_ICON**</span><span class="sxs-lookup"><span data-stu-id="32aee-881">**GX_TYPE_ICON**</span></span>

<span data-ttu-id="32aee-882">**GX_TYPE_SPRITE**</span><span class="sxs-lookup"><span data-stu-id="32aee-882">**GX_TYPE_SPRITE**</span></span>

<span data-ttu-id="32aee-883">**GX_TYPE_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="32aee-883">**GX_TYPE_SLIDER**</span></span>

<span data-ttu-id="32aee-884">**GX_TYPE_PIXELMAP_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="32aee-884">**GX_TYPE_PIXELMAP_SLIDER**</span></span>

<span data-ttu-id="32aee-885">**GX_TYPE_VERTICAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="32aee-885">**GX_TYPE_VERTICAL_SCROLL**</span></span>

<span data-ttu-id="32aee-886">**GX_TYPE_HORIZONTAL_SCROLL**</span><span class="sxs-lookup"><span data-stu-id="32aee-886">**GX_TYPE_HORIZONTAL_SCROLL**</span></span>

<span data-ttu-id="32aee-887">**GX_TYPE_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="32aee-887">**GX_TYPE_PROGRESS_BAR**</span></span>

<span data-ttu-id="32aee-888">**GX_TYPE_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="32aee-888">**GX_TYPE_PROMPT**</span></span>

<span data-ttu-id="32aee-889">**GX_TYPE_NUMERIC_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="32aee-889">**GX_TYPE_NUMERIC_PROMPT**</span></span>

<span data-ttu-id="32aee-890">**GX_TYPE_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="32aee-890">**GX_TYPE_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="32aee-891">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span><span class="sxs-lookup"><span data-stu-id="32aee-891">**GX_TYPE_NUMERIC_PIXELMAP_PROMPT**</span></span>

<span data-ttu-id="32aee-892">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="32aee-892">**GX_TYPE_SINGLE_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="32aee-893">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span><span class="sxs-lookup"><span data-stu-id="32aee-893">**GX_TYPE_MULTI_LINE_TEXT_VIEW**</span></span>

<span data-ttu-id="32aee-894">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span><span class="sxs-lookup"><span data-stu-id="32aee-894">**GX_TYPE_MULTI_LINE_TEXT_INPUT**</span></span>

<span data-ttu-id="32aee-895">**GX_TYPE_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="32aee-895">**GX_TYPE_WINDOW**</span></span>

<span data-ttu-id="32aee-896">**GX_TYPE_ROOT_WINDOW**</span><span class="sxs-lookup"><span data-stu-id="32aee-896">**GX_TYPE_ROOT_WINDOW**</span></span>

<span data-ttu-id="32aee-897">**GX_TYPE_VERTICAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="32aee-897">**GX_TYPE_VERTICAL_LIST**</span></span>

<span data-ttu-id="32aee-898">**GX_TYPE_HORIZONTAL_LIST**</span><span class="sxs-lookup"><span data-stu-id="32aee-898">**GX_TYPE_HORIZONTAL_LIST**</span></span>

<span data-ttu-id="32aee-899">**GX_TYPE_POPUP_LIST**</span><span class="sxs-lookup"><span data-stu-id="32aee-899">**GX_TYPE_POPUP_LIST**</span></span>

<span data-ttu-id="32aee-900">**GX_TYPE_DROP_LIST**</span><span class="sxs-lookup"><span data-stu-id="32aee-900">**GX_TYPE_DROP_LIST**</span></span>

<span data-ttu-id="32aee-901">**GX_TYPE_LINE_CHART**</span><span class="sxs-lookup"><span data-stu-id="32aee-901">**GX_TYPE_LINE_CHART**</span></span>

<span data-ttu-id="32aee-902">**GX_TYPE_DIALOG**</span><span class="sxs-lookup"><span data-stu-id="32aee-902">**GX_TYPE_DIALOG**</span></span>

<span data-ttu-id="32aee-903">**GX_TYPE_KEYBOARD**</span><span class="sxs-lookup"><span data-stu-id="32aee-903">**GX_TYPE_KEYBOARD**</span></span>

<span data-ttu-id="32aee-904">**GX_TYPE_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="32aee-904">**GX_TYPE_SCROLL_WHEEL**</span></span>

<span data-ttu-id="32aee-905">**GX_TYPE_TEXT_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="32aee-905">**GX_TYPE_TEXT_SCROLL_WHEEL**</span></span>

<span data-ttu-id="32aee-906">**GX_TYPE_STRING_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="32aee-906">**GX_TYPE_STRING_SCROLL_WHEEL**</span></span>

<span data-ttu-id="32aee-907">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span><span class="sxs-lookup"><span data-stu-id="32aee-907">**GX_TYPE_NUMERIC_SCROLL_WHEEL**</span></span>

<span data-ttu-id="32aee-908">**GX_TYPE_CIRCULAR_GAUGE**</span><span class="sxs-lookup"><span data-stu-id="32aee-908">**GX_TYPE_CIRCULAR_GAUGE**</span></span>

<span data-ttu-id="32aee-909">**GX_TYPE_RADIAL_PROGRESS_BAR**</span><span class="sxs-lookup"><span data-stu-id="32aee-909">**GX_TYPE_RADIAL_PROGRESS_BAR**</span></span>

<span data-ttu-id="32aee-910">**GX_TYPE_RADIAL_SLIDER**</span><span class="sxs-lookup"><span data-stu-id="32aee-910">**GX_TYPE_RADIAL_SLIDER**</span></span>

<span data-ttu-id="32aee-911">**GX_TYPE_MENU_LIST**</span><span class="sxs-lookup"><span data-stu-id="32aee-911">**GX_TYPE_MENU_LIST**</span></span>

<span data-ttu-id="32aee-912">**GX_TYPE_MENU**</span><span class="sxs-lookup"><span data-stu-id="32aee-912">**GX_TYPE_MENU**</span></span>

<span data-ttu-id="32aee-913">**GX_TYPE_ACCORDION_MENU**</span><span class="sxs-lookup"><span data-stu-id="32aee-913">**GX_TYPE_ACCORDION_MENU**</span></span>

<span data-ttu-id="32aee-914">**GX_TYPE_TREE_VIEW**</span><span class="sxs-lookup"><span data-stu-id="32aee-914">**GX_TYPE_TREE_VIEW**</span></span>


### <a name="styles"></a><span data-ttu-id="32aee-915">Стили</span><span class="sxs-lookup"><span data-stu-id="32aee-915">Styles</span></span>

<span data-ttu-id="32aee-916">Стили мини-приложений состоят из таких элементов, как свойства границ (выпуклые, углубленные, тонкие, толстые или без границ), а также свойств для конкретных типов мини-приложений, как показано выше.</span><span class="sxs-lookup"><span data-stu-id="32aee-916">Widget styles consist of things like border properties (raised, recessed, thin, thick, or no boarder at all) as well as properties for specific widget types, as listed previously.</span></span> <span data-ttu-id="32aee-917">Флаги стиля мини-приложения являются простейшим способом изменения внешнего вида любого мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-917">The widget style flags offer the simplest method for modifying the appearance of any widget.</span></span>
<span data-ttu-id="32aee-918">Исходный стиль мини-приложения всегда является параметром, передаваемым в конкретную функцию создания типа мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-918">The initial widget style is always a parameter passed to the widget type specific create function.</span></span>

### <a name="colors"></a><span data-ttu-id="32aee-919">Цвета</span><span class="sxs-lookup"><span data-stu-id="32aee-919">Colors</span></span> 

<span data-ttu-id="32aee-920">Рисование мини-приложений выполняется с помощью цветов, определенных в таблице цветов системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-920">Widgets draw themselves using colors defined in the system color table.</span></span>
<span data-ttu-id="32aee-921">Идентификаторы цвета определяются для фона холста, цвета заливки мини-приложения по умолчанию, цвета заливки кнопок, цвета заливки мини-приложения текста, цвета заливки окон и нескольких других значений цвета по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="32aee-921">Color IDs are defined for canvas background, default widget fill color, button fill color, text widget fill color, window fill color, and several other default color values.</span></span> <span data-ttu-id="32aee-922">Кроме того, объекты **GX_WINDOW** поддерживают отображение растрового изображения или фонового рисунка при заполнении клиента окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-922">In addition, **GX_WINDOW** objects support displaying a bitmap or wallpaper as the window client is filled.</span></span>

<span data-ttu-id="32aee-923">Самый простой способ изменить цветовую схему по умолчанию — использовать GUIX Studio для создания или определения цветовой схемы, соответствующей вашим требованиям.</span><span class="sxs-lookup"><span data-stu-id="32aee-923">The simplest method of changing the default color scheme is to use GUIX Studio and create or define a color scheme that meets your requirements.</span></span>
<span data-ttu-id="32aee-924">Кроме того, можно определить цветовую схему вручную, создав массив значений GX_COLOR и вызвав функцию API gx_system_color_table_set.</span><span class="sxs-lookup"><span data-stu-id="32aee-924">You can also define your color scheme manually by creating an array of GX_COLOR values and invoking the gx_system_color_table_set API function.</span></span>

### <a name="event-notification"></a><span data-ttu-id="32aee-925">Уведомление о событии</span><span class="sxs-lookup"><span data-stu-id="32aee-925">Event Notification</span></span> 

<span data-ttu-id="32aee-926">События GUIX — это запросы к одному или нескольким мини-приложениям для выполнения определенных действий и создания уведомлений для мини-приложений о вводе данных пользователем и внутренних изменениях состояния системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-926">GUIX events are requests made to one or more widgets to perform a particular action and notifications to notify widgets of user input and internal system status changes.</span></span> <span data-ttu-id="32aee-927">Например, когда мини-приложение выполняет фокусирование, **GX_EVENT_FOCUS_GAINED** отправляется в мини-приложение с помощью службы API ***gx_system_event_send***.</span><span class="sxs-lookup"><span data-stu-id="32aee-927">For example, when a widget gains focus, the **GX_EVENT_FOCUS_GAINED** is sent to the widget via the ***gx_system_event_send*** API service.</span></span>

<span data-ttu-id="32aee-928">События передаются через очередь событий GUIX, где каждое событие является экземпляром структуры данных **GX_EVENT**.</span><span class="sxs-lookup"><span data-stu-id="32aee-928">Events are passed through the GUIX event queue, and each event is an instance of the **GX_EVENT** data structure.</span></span> <span data-ttu-id="32aee-929">Структура данных **GX_EVENT** определена в ***gx_api.h***, однако наиболее важными полями структуры являются **gx_event_type**, **gx_event_sender**, **gx_event_target** и **gx_event_payload**.</span><span class="sxs-lookup"><span data-stu-id="32aee-929">The **GX_EVENT** data structure is defined in ***gx_api.h***, however the most important fields of the structure are the **gx_event_type**, **gx_event_sender**, **gx_event_target**, and **gx_event_payload**.</span></span>

<span data-ttu-id="32aee-930">Поле **gx_event_type** используется для идентификации конкретного класса событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-930">The **gx_event_type** field is used to identify the particular event class.</span></span> <span data-ttu-id="32aee-931">Тип события указывает, является ли элемент, например, событием **GX_EVENT_PEN_DOWN** или событием **GX_EVENT_TIMER**.</span><span class="sxs-lookup"><span data-stu-id="32aee-931">The event type indicates if this is, for example, a **GX_EVENT_PEN_DOWN** event or a **GX_EVENT_TIMER** event.</span></span> <span data-ttu-id="32aee-932">**gx_event_payload** является объединением различных полей данных. Они не являются допустимыми для каждого типа событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-932">The **gx_event_payload** is a union of various data fields, and they are not all valid for every event type.</span></span>
<span data-ttu-id="32aee-933">Сначала используется поле типа события. Затем проверяются другие поля данных событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-933">You use the event type field first, before examining the other event data fields.</span></span>

<span data-ttu-id="32aee-934">Поле **gx_event_sender** содержит идентификатор мини-приложения, создавшего событие, если событие является уведомлением для дочернего мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-934">The **gx_event_sender** field contains the ID of the widget that generated the event if the event is a child-widget notification.</span></span>

<span data-ttu-id="32aee-935">Поле **gx_event_target** можно использовать для отправки определяемых пользователем событий в определенное окно или мини-приложение.</span><span class="sxs-lookup"><span data-stu-id="32aee-935">The **gx_event_target** field can be used to route user-defined events to a particular window or widget.</span></span> <span data-ttu-id="32aee-936">Если необходимо отправить событие в определенное окно, следует присвоить окну уникальное значение идентификатора (чтобы его можно было однозначно идентифицировать) и при создании события задать значение идентификатора окна в поле **gx_event_target**.</span><span class="sxs-lookup"><span data-stu-id="32aee-936">If you want to send an event to a particular window, you should give the window a unique Id value (so that it can be positively identified), and when building the event place the window Id value in the **gx_event_target** field.</span></span> <span data-ttu-id="32aee-937">Если идентификатор целевого объекта неизвестен или необходимо, чтобы событие было отправлено в мини-приложение, имеющее фокус ввода, обязательно задайте для поля **gx_event_target** значение 0.</span><span class="sxs-lookup"><span data-stu-id="32aee-937">If you don’t know the target Id or if you just want the event to be routed to the widget that has input focus, make sure to set the **gx_event_target** field to 0.</span></span>

<span data-ttu-id="32aee-938">Наконец, поле **gx_event_payload** является объединением различных типов данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-938">Finally, the **gx_event_payload** field is a union of various data types.</span></span> <span data-ttu-id="32aee-939">Для событий **GX_EVENT_PEN_DOWN** и **GX_EVENT_PEN_UP** поле **gx_event_pointdata** содержит пиксельные координаты x, y для позиции пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-939">For **GX_EVENT_PEN_DOWN** and **GX_EVENT_PEN_UP** events, the **gx_event_pointdata** field contains the x,y pixel coordinate the pen position.</span></span> <span data-ttu-id="32aee-940">Для событий таймера поле **gx_event_timer_id** содержит идентификатор таймера с истекшим значением.</span><span class="sxs-lookup"><span data-stu-id="32aee-940">For timer events, the **gx_event_timer_id** field contains the ID of the expired timer.</span></span> <span data-ttu-id="32aee-941">Остальные поля полезных данных используются для других типов событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-941">Other payload data fields are utilized for other event types.</span></span> <span data-ttu-id="32aee-942">Полный список предварительно определенных типов событий и их полей полезных данных см. в [приложении E с описанием событий GUIX](appendix-e.md).</span><span class="sxs-lookup"><span data-stu-id="32aee-942">The complete list of pre-defined event types and their payload fields is defined in [Appendix E - GUIX Event Descriptions](appendix-e.md).</span></span>

<span data-ttu-id="32aee-943">Приложение может также добавлять собственные пользовательские события, начиная с числа после константы **GX_FIRST_APP_EVENT**.</span><span class="sxs-lookup"><span data-stu-id="32aee-943">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="32aee-944">Все номера событий после этой константы зарезервированы для использования приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-944">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="32aee-945">Разумеется, обработчик событий мини-приложений приложения должен выполнить соответствующую обработку для этих событий приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-945">Of course, the application’s widget event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="32aee-946">Обработка событий</span><span class="sxs-lookup"><span data-stu-id="32aee-946">Event Processing</span></span> 

<span data-ttu-id="32aee-947">Для каждого мини-приложения используется функция обработки событий мини-приложения по умолчанию с именем ***gx_<widget-type>_event_process***.</span><span class="sxs-lookup"><span data-stu-id="32aee-947">There is a default widget event processing function for each and every widget, named ***gx_<widget-type>_event_process***.</span></span> <span data-ttu-id="32aee-948">В большинстве случаев приложению не нужно проверять обработку событий мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-948">In most cases, the application won’t need to worry about the event handling of any given widget.</span></span> <span data-ttu-id="32aee-949">Однако в ситуациях, когда для приложения требуется пользовательская или дополнительная обработка событий, приложение может переопределить функцию обработки данных по умолчанию с помощью API GUIX ***gx_widget_event_process_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-949">However, in situations where the application requires custom or supplemental event processing, the application may override the default processing function with its own via the GUIX API ***gx_widget_event_process_set***.</span></span> <span data-ttu-id="32aee-950">Эта функция переопределяет функцию обработки событий по умолчанию функцией обработки событий, указанной в API.</span><span class="sxs-lookup"><span data-stu-id="32aee-950">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-951">Функции обработки событий приложения могут использовать обработку по умолчанию (т. е. не дублировать обработку), просто вызвав обработку по умолчанию ***gx_widget_event_process*** напрямую.</span><span class="sxs-lookup"><span data-stu-id="32aee-951">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_widget_event_process*** processing directly.</span></span>

<span data-ttu-id="32aee-952">Обработка событий вызывается исключительно из контекста внутреннего системного потока GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-952">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="32aee-953">Таким образом, требования стека обрабатывать события применяются только к потоку GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-953">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

### <a name="implementing-custom-event-processing-example"></a><span data-ttu-id="32aee-954">Реализация обработки пользовательских событий (пример)</span><span class="sxs-lookup"><span data-stu-id="32aee-954">Implementing Custom Event Processing (example)</span></span> 

<span data-ttu-id="32aee-955">Вы можете предоставить собственную функцию обработки событий для любого мини-приложения или окна в системе GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-955">You can provide your own event processing function for any widget or window in the GUIX system.</span></span> <span data-ttu-id="32aee-956">При создании собственного пользовательского типа мини-приложения обычно в функции создания мини-приложений устанавливается обработчик настраиваемых событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-956">If you are creating your own custom widget type, you will normally install your custom event handler in the widget creation function.</span></span> <span data-ttu-id="32aee-957">Если необходимо просто расширить или изменить работу существующего мини-приложения или окна, можно вызвать функцию API gx_widget_event_process_set после создания мини-приложения или окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-957">If you are just extending or modifying the operation of an existing widget or window, you can call the gx_widget_event_process_set API function after the widget or window has been created.</span></span> <span data-ttu-id="32aee-958">Для окон верхнего уровня (также называемых экранами) вы почти всегда будете выполнять собственную обработку событий, чтобы обработать события, созданные с помощью дочерних элементов управления.</span><span class="sxs-lookup"><span data-stu-id="32aee-958">You will almost always provide your own event handling for your top-level windows (also called Screens) in order to process events generated by your child controls.</span></span> <span data-ttu-id="32aee-959">Обработка события, созданного с помощью дочерних элементов управления экраном, является основным способом добавления функциональных возможностей в приложение GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-959">Processing event generated by the child controls of a screen is the main way you add functionality to your GUIX application.</span></span>

<span data-ttu-id="32aee-960">Например, предположим, что вы определили экран верхнего уровня с именем main_menu.</span><span class="sxs-lookup"><span data-stu-id="32aee-960">As an example, suppose you define a top-level screen named “main_menu”.</span></span>
<span data-ttu-id="32aee-961">Этот экран может быть определен с помощью GUIX Studio или создан в коде приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-961">This screen might be defined using GUIX Studio, or you might create this screen in your application code.</span></span> <span data-ttu-id="32aee-962">Если вы определили экран в GUIX Studio, просто введите имя обработчика событий в поле свойств Studio для этого экрана, и код спецификации Studio автоматически установит обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-962">If you define the screen within GUIX Studio, you simply type the name of your event handler in the Studio properties field for that screen, and the Studio generated specifications code will automatically install your event handler.</span></span> <span data-ttu-id="32aee-963">В этом случае вызывается обработчик настраиваемых событий ***main_menu_event_handler***. При этом необходимо использовать следующий код:</span><span class="sxs-lookup"><span data-stu-id="32aee-963">In this case, we will call the custom event handler ***main_menu_event_handler*** and it should be coded like this:</span></span>

```C
int main_menu_item; /* example: variable to keep track of selected item */

UINT main_menu_event_handler(GX_WINDOW *main_screen, GX_EVENT *event_ptr)
{
    UINT status = GX_SUCCESS;

    switch(event_ptr->gx_event_type)
    {
    /* this is an example for catching events from a child button */
    case GX_SIGNAL(IDB_CHILD_BUTTON, GX_EVENT_CLICKED):
        /* insert your button handler code here */
        break;

    case GX_EVENT_SHOW:
        /* add functionality to the show event handler */
        /* first, do default processing */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */

        /* now add my own processing */
        main_menu_item = 0;
        break;

    default:
        /* pass all other events to base processing function */
        status = gx_window_event_process(main_screen, event_ptr); /* note 1 */
        break;
    }
    return status;
}
```

<span data-ttu-id="32aee-964">В рамках приведенного выше примера важно отметить, что для системных событий, таких как **GX_EVENT_SHOW** (события, созданные внутренним образом для уведомления мини-приложения об изменении состояния), приложение должно передать эти события в базовую функцию обработки событий мини-приложения, чтобы обеспечить соответствующую обработку данных.</span><span class="sxs-lookup"><span data-stu-id="32aee-964">In the example above, it is important to notice that for system events like **GX_EVENT_SHOW** (events generated internally to notify a widget of a status change), the application must pass those events to the base widget event processing function to insure that the normal processing occurs.</span></span> <span data-ttu-id="32aee-965">Приложение может при необходимости добавить дополнительную логику.</span><span class="sxs-lookup"><span data-stu-id="32aee-965">The application can then add additional logic as desired.</span></span> <span data-ttu-id="32aee-966">Все события, которые не обрабатываются приложением (вариант по умолчанию выше), также должны передаваться в базовую функцию обработки событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-966">All events that are not handled by the application (the default case above) should also be passed to the base event processing function.</span></span> <span data-ttu-id="32aee-967">Так как этот пример предназначен для экрана верхнего уровня на основе **GX_WINDOW**, функция обработки событий по умолчанию — gx_window_event_process.</span><span class="sxs-lookup"><span data-stu-id="32aee-967">Since this example was for a top-level screen based on **GX_WINDOW**, the default event processing function is gx_window_event_process.</span></span>

### <a name="drawing-function"></a><span data-ttu-id="32aee-968">Функция рисования</span><span class="sxs-lookup"><span data-stu-id="32aee-968">Drawing Function</span></span> 

<span data-ttu-id="32aee-969">Все операции рисования в мини-приложении выполняются отдельно от обработки событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-969">All widget drawing is performed separately from the event handling.</span></span> <span data-ttu-id="32aee-970">Это более эффективно, так как операция рисования обычно является ресурсоемкой в отношении циклов ЦП.</span><span class="sxs-lookup"><span data-stu-id="32aee-970">This is more efficient because drawing is usually expensive in terms of CPU cycles.</span></span> <span data-ttu-id="32aee-971">При реализации алгоритма отложенного рисования все необработанные события и связанные изменения дисплея можно завершить до выполнения рисования. Это позволяет предотвратить рисование впустую.</span><span class="sxs-lookup"><span data-stu-id="32aee-971">By implementing a deferred drawing algorithm, all of the outstanding events and associated display changes can be completed before any drawing is done, thus eliminating wasted drawing.</span></span> <span data-ttu-id="32aee-972">Аналогично обработке событий для большинства мини-приложений используется функция рисования мини-приложения по умолчанию с именем ***gx_<widget-type>_draw***, где xxx — это тип мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-972">Similar to event processing, there is a default widget drawing function for most widgets, named ***gx_<widget-type>_draw***, where xxx is the widget type.</span></span> <span data-ttu-id="32aee-973">В большинстве случаев приложению не нужно контролировать выполнение функции рисования для любого мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-973">In most cases, the application won’t need to worry about the drawing function of any given widget.</span></span> <span data-ttu-id="32aee-974">Однако в ситуациях, когда приложение должно выполнить пользовательскую или дополнительную операцию рисования, оно может переопределить функцию рисования по умолчанию с помощью соответствующего API GUIX ***gx_widget_draw_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-974">However, in situations where the application requires custom or supplemental drawing, the application may override the default drawing function with its own via the GUIX API ***gx_widget_draw_set***.</span></span> <span data-ttu-id="32aee-975">Эта функция позволяет приложению предоставить собственную пользовательскую функцию рисования для любого мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-975">This function allows the application to provide its own customized drawing function for any widget.</span></span> <span data-ttu-id="32aee-976">Это также позволяет приложению определять полностью новые типы мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-976">This further allows the application to define entire new widget types.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-977">Функции рисования приложений могут выполнять операцию рисования по умолчанию (т. е. не дублировать код), просто вызвав ее непосредственно в переопределенной функции рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-977">Application drawing functions can take advantage (i.e., not duplicate the coding) of the default drawing by simply calling it directly from the overridden drawing function.</span></span>

<span data-ttu-id="32aee-978">Рисование для мини-приложений вызывается исключительно из контекста внутреннего системного потока GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-978">Widget drawing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="32aee-979">Таким образом, требования параметра времени и стека относительно выполнения рисования применяются только к потоку GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-979">In this way, the timing and stack requirements to perform the drawing only apply to the GUIX thread.</span></span>

### <a name="implementing-custom-drawing-example"></a><span data-ttu-id="32aee-980">Реализация пользовательского рисования (пример)</span><span class="sxs-lookup"><span data-stu-id="32aee-980">Implementing Custom Drawing (example)</span></span> 

<span data-ttu-id="32aee-981">Ссылка на функцию рисования для любого мини-приложения выполняется с помощью косвенного указателя на функцию, который является элементом блока управления GX_WIDGET.</span><span class="sxs-lookup"><span data-stu-id="32aee-981">The drawing function for any widget is referenced through an indirect function pointer which is a member of the GX_WIDGET control block.</span></span> <span data-ttu-id="32aee-982">Если для определения мини-приложения используется GUIX Studio, можно установить собственный указатель на функцию, введя имя функции в параметре Drawing Function (Функция рисования) для свойств мини-приложения. При создании мини-приложения в Studio будет установлен указатель на функцию.</span><span class="sxs-lookup"><span data-stu-id="32aee-982">If you use GUIX Studio to define your widget, you can install your own function pointer simply by typing the name of your function in the “Drawing Function” parameter of the widget properties, and Studio will install your function pointer for you when the widget is created.</span></span> <span data-ttu-id="32aee-983">Если вы создаете мини-приложение в коде приложения, необходимо использовать функцию API ***gx_widget_draw_set***, чтобы установить пользовательскую функцию рисования после создания мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-983">If you create the widget in your application code, you must use the ***gx_widget_draw_set*** API function to install your custom drawing function after the widget has been created.</span></span>

<span data-ttu-id="32aee-984">В рамках этого примера предполагается, что необходимо настроить внешний вид кнопки.</span><span class="sxs-lookup"><span data-stu-id="32aee-984">For this example, let’s assume that you want to customize the appearance of a button.</span></span> <span data-ttu-id="32aee-985">Кнопка похожа на кнопку **GX_TEXT_BUTTON**, но при ее нажатии в средней правой части кнопки добавляется маленькое зеленое растровое изображение LED_ON, а если кнопка не нажата — маленькое растровое изображение LED_OFF.</span><span class="sxs-lookup"><span data-stu-id="32aee-985">The button will look very much like a **GX_TEXT_BUTTON**, but we will add drawing a small green “LED_ON” bitmap in the middle-right portion of the button when the button is pressed, and small “LED_OFF” bitmap when the button is not pressed.</span></span> <span data-ttu-id="32aee-986">Необходимо создать кнопку, которая выглядит как на иллюстрациях ниже.</span><span class="sxs-lookup"><span data-stu-id="32aee-986">We want to create a button that looks like the illustrations below.</span></span>

![Снимок экрана с зеленой кнопкой в режиме "Вкл."](./media/guix/image4.jpg) <span data-ttu-id="32aee-988">Пользовательская кнопка "Вкл."</span><span class="sxs-lookup"><span data-stu-id="32aee-988">custom button “on”</span></span>

![Снимок экрана с красной кнопкой в режиме "Выкл."](./media/guix/image5.jpg) <span data-ttu-id="32aee-990">Пользовательская кнопка "Выкл."</span><span class="sxs-lookup"><span data-stu-id="32aee-990">custom button “off”</span></span>

<span data-ttu-id="32aee-991">В этом случае создается функция рисования кнопки, которая выглядит, как показано ниже.</span><span class="sxs-lookup"><span data-stu-id="32aee-991">In this case, we would write a button drawing function that looks something like the following.</span></span>

```C
UINT my_button_draw(GX_TEXT_BUTTON *button)
{
    GX_PIXELMAP *map;
    ULONG button_style;
    INT xpos;
    INT ypos;

    /* first, do the normal text button drawing */
    gx_text_button_draw(button);

    /* now add our extra pixelmap */

    gx_widget_style_get(button, &button_style);

    if (button_style & GX_STYLE_BUTTON_PUSHED)
    {
        /* use the ON pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_ON, &map);
    }
    else
    {
        /* use the OFF pixelmap */
        gx_context_pixelmap_get(GX_PIXELMAP_ID_LED_OFF, &map);
    }
    if (map)
    {
        /* draw it 20 pixels in from right edge */
        xpos = button->gx_widget_size.gx_rectangle_right;
        xpos -= map->gx_pixelmap_width + 20;

        /* and draw 10 pixels from the top edge */
        ypos = button->gx_widget_size.gx_rectangle_top + 10;

        /* draw the extra pixelmap on top of the button */
        gx_canvas_pixelmap_draw(xpos, ypos, map);
    }
}
```

## <a name="guix-drawing-context-component"></a><span data-ttu-id="32aee-992">Компонент контекста рисования GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-992">GUIX Drawing Context Component</span></span> 

<span data-ttu-id="32aee-993">Контекст рисования создается динамически в среде выполнения, так как GUIX выполняет каждую операцию обновления холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-993">The drawing context is created dynamically, at runtime, as GUIX performs each canvas refresh operation.</span></span> <span data-ttu-id="32aee-994">Контекст рисования связывает холст, драйвер экрана и кисть для выполнения текущих операций рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-994">The drawing context ties together the canvas, screen driver, and brush being used to perform the current drawing operations.</span></span>

<span data-ttu-id="32aee-995">Контекст рисования определяется структурой **GX_DRAW_CONTEXT**.</span><span class="sxs-lookup"><span data-stu-id="32aee-995">The drawing context is defined by the **GX_DRAW_CONTEXT** structure.</span></span>
<span data-ttu-id="32aee-996">Эта структура содержит переменные, определяющие обрезку и представление текущей операции рисования, а также текущие используемые холст и драйвер экрана.</span><span class="sxs-lookup"><span data-stu-id="32aee-996">This structure contains variables that define the clipping and view of the current drawing operation, define the current canvas, and define the current screen driver in use.</span></span> <span data-ttu-id="32aee-997">Структура **GX_DRAW_CONTEXT** также содержит кисть, используемую для рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-997">The **GX_DRAW_CONTEXT** structure also holds the brush being used for drawing.</span></span> <span data-ttu-id="32aee-998">Кисть контекста рисования — это элемент, который используется непосредственно в пользовательских функциях рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-998">The draw context brush is the member that you will work directly with in your custom drawing functions.</span></span> <span data-ttu-id="32aee-999">Структура кисти определяется, как показано в приведенном ниже коде.</span><span class="sxs-lookup"><span data-stu-id="32aee-999">The brush structure is defined as shown in the code below.</span></span>

```C
typedef struct GX_BRUSH_STRUCT
{
    GX_PIXELMAP *gx_brush_pixelmap;
    GX_FONT     *gx_brush_font;
    ULONG        gx_brush_line_pattern;
    ULONG        gx_brush_pattern_mask;
    GX_COLOR     gx_brush_fill_color;  
    GX_COLOR     gx_brush_line_color;  
    UINT         gx_brush_style;
    GX_VALUE     gx_brush_width;
    UCHAR        gx_brush_alpha;  
} GX_BRUSH;
```

<span data-ttu-id="32aee-1000">Поле **gx_brush_pixelmap** определяет пиксельную карту, используемую для заливки прямоугольника и многоугольника.</span><span class="sxs-lookup"><span data-stu-id="32aee-1000">The **gx_brush_pixelmap** field defines a pixelmap to use for rectangle and polygon fills.</span></span> <span data-ttu-id="32aee-1001">Этот элемент используется, только если **gx_brush_style** содержит стиль **GX_BRUSH_PIXELMAP**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1001">This member is not used unless the **gx_brush_style** is includes the **GX_BRUSH_PIXELMAP** style.</span></span>

<span data-ttu-id="32aee-1002">Элемент **gx_brush_font** определяет шрифт для рисования текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-1002">The **gx_brush_font** member defines the font used for text drawing.</span></span>
<span data-ttu-id="32aee-1003">Элемент **gx_brush_line_pattern** определяет шаблон для пунктирных линий.</span><span class="sxs-lookup"><span data-stu-id="32aee-1003">The **gx_brush_line_pattern** member defines the pattern used for dashed lines.</span></span>
<span data-ttu-id="32aee-1004">Элемент **gx_brush_style** — это набор флагов стиля, которые можно совместно использовать для полного определения атрибутов кисти.</span><span class="sxs-lookup"><span data-stu-id="32aee-1004">The **gx_brush_style** member is a set of style flags that can be OR’d together to fully define the brush attributes.</span></span> <span data-ttu-id="32aee-1005">Доступные флаги стиля кисти включают в себя указанные ниже элементы.</span><span class="sxs-lookup"><span data-stu-id="32aee-1005">The available brush style flags include the following.</span></span>

<span data-ttu-id="32aee-1006">**GX_BRUSH_OUTLINE**</span><span class="sxs-lookup"><span data-stu-id="32aee-1006">**GX_BRUSH_OUTLINE**</span></span>  
<span data-ttu-id="32aee-1007">**GX_BRUSH_SOLID_FILL**</span><span class="sxs-lookup"><span data-stu-id="32aee-1007">**GX_BRUSH_SOLID_FILL**</span></span>  
<span data-ttu-id="32aee-1008">**GX_BRUSH_PIXELMAP_FILL**</span><span class="sxs-lookup"><span data-stu-id="32aee-1008">**GX_BRUSH_PIXELMAP_FILL**</span></span>  
<span data-ttu-id="32aee-1009">**GX_BRUSH_ALIAS**</span><span class="sxs-lookup"><span data-stu-id="32aee-1009">**GX_BRUSH_ALIAS**</span></span>  
<span data-ttu-id="32aee-1010">**GX_BRUSH_UNDERLINE**</span><span class="sxs-lookup"><span data-stu-id="32aee-1010">**GX_BRUSH_UNDERLINE**</span></span>  
<span data-ttu-id="32aee-1011">**GX_BRUSH_ROUND**</span><span class="sxs-lookup"><span data-stu-id="32aee-1011">**GX_BRUSH_ROUND**</span></span>

<span data-ttu-id="32aee-1012">Элемент **gx_brush_width** определяет линию для операции рисования линий, а также ширину контура для операции рисования контура фигуры.</span><span class="sxs-lookup"><span data-stu-id="32aee-1012">The **gx_brush_width** member defines the line with for line drawing, or the outline width for outlined shape drawing.</span></span>

<span data-ttu-id="32aee-1013">Элемент **gx_brush_line_color** определяет цвет переднего плана для рисования линий и для рисования текста.</span><span class="sxs-lookup"><span data-stu-id="32aee-1013">The **gx_brush_line_color** member defines the foreground color for line drawing and for text drawing.</span></span>

<span data-ttu-id="32aee-1014">Элемент **gx_brush_fill_color** определяет цвет сплошной заливки фигур.</span><span class="sxs-lookup"><span data-stu-id="32aee-1014">The **gx_brush_fill_color** member defines the solid fill color used for shape filling.</span></span> <span data-ttu-id="32aee-1015">Компонент контекста GUIX предоставляет набор API для удобного изменения текущей кисти в активном контексте.</span><span class="sxs-lookup"><span data-stu-id="32aee-1015">The GUIX context component provides a set of APIs designed to make it very easy to modify the current brush within the active context.</span></span> <span data-ttu-id="32aee-1016">К этим API относятся **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set** и многие другие.</span><span class="sxs-lookup"><span data-stu-id="32aee-1016">These APIs include **gx_context_brush_define**, **gx_context_line_color_set**, **gx_context_fill_color_set**, **gx_context_font_set**, and many others.</span></span>

<span data-ttu-id="32aee-1017">Контекст рисования родительского объекта наследуется дочерними объектами.</span><span class="sxs-lookup"><span data-stu-id="32aee-1017">The draw context of a parent object is inherited by the objects children.</span></span> <span data-ttu-id="32aee-1018">Фактически при вызове функций рисования дочерние объекты наследуют клон родительского контекста рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1018">Actually, a clone of the parent drawing context is inherited by the child objects when their drawing functions are invoked.</span></span> <span data-ttu-id="32aee-1019">Дочерний элемент может изменять контекст, не влияя на рисование для родительского элемента, но при необходимости он может также наследовать сведения от родительского элемента, например цвет и стиль кисти.</span><span class="sxs-lookup"><span data-stu-id="32aee-1019">The child can modify the context without affecting the parent drawing, but it can also inherit information from the parent such as brush color and style if desired.</span></span>

## <a name="guix-window-component"></a><span data-ttu-id="32aee-1020">Компонент окна GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-1020">GUIX Window Component</span></span> 

<span data-ttu-id="32aee-1021">Компонент окна позволяет выполнять всю обработку окон в GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1021">The window component is responsible for all window processing in GUIX.</span></span> <span data-ttu-id="32aee-1022">Окно GUIX представляет собой отдельную область дисплея, которая может содержать одно или несколько дочерних мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-1022">A GUIX window is fundamentally a distinct display area that may contain one or more child widgets.</span></span> <span data-ttu-id="32aee-1023">В GUIX окно представляет собой лишь особую форму основного объекта мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1023">In GUIX, the window is actually just a special form of the fundamental widget object.</span></span>

<span data-ttu-id="32aee-1024">Окна GUIX реализуются объектно-ориентированным методом с полной поддержкой наследования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1024">GUIX windows are implemented in an object oriented manner with full support of inheritance.</span></span> <span data-ttu-id="32aee-1025">Это достигается с помощью ANSI C и позволяет максимально снизить требования к памяти и обработке.</span><span class="sxs-lookup"><span data-stu-id="32aee-1025">This is accomplished using ANSI C, which results in the smallest possible memory and processing requirements.</span></span>

<span data-ttu-id="32aee-1026">Окна GUIX позволяют расширить функциональные возможности мини-приложения GUIX преимущественно благодаря добавлению поддержки горизонтальной и вертикальной прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-1026">GUIX windows extend the functionality of the GUIX widget primarily by adding support for horizontal and vertical scrolling.</span></span> <span data-ttu-id="32aee-1027">Объекты окна GUIX могут автоматически создавать и отображать полосы прокрутки и реагировать на входные данные полосы прокрутки.</span><span class="sxs-lookup"><span data-stu-id="32aee-1027">GUIX window objects can automatically create and display scroll bars and respond to scroll bar input.</span></span> <span data-ttu-id="32aee-1028">В перемещаемых окнах также встроена обработка событий, позволяющая перемещать или перетаскивать окно на основе событий ввода с помощью пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1028">Movable windows also have built in event handling to allow the window to be moved or dragged based on pen input events.</span></span>
<span data-ttu-id="32aee-1029">Наконец, окно GUIX реагирует на получение фокуса ввода, перемещая окно в переднюю часть Z-порядка окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-1029">Finally, GUIX window responds to receiving input focus by moving the window to the front of the window Z-order.</span></span>

<span data-ttu-id="32aee-1030">Окно GUIX поддерживает концепцию *клиентской области*, которая является внутренней частью окна после удаления границ окна и неклиентских объектов, таких как полосы прокрутки, из доступной области.</span><span class="sxs-lookup"><span data-stu-id="32aee-1030">GUIX window maintains the concept of *client area*, which is the inner portion of the window once the window borders and non-client objects such as scrollbars are removed from the available area.</span></span> <span data-ttu-id="32aee-1031">Дочерние мини-приложения клиентской области обрезаются по размеру клиентской области окна, а неклиентские дочерние элементы, такие как полосы прокрутки, могут рисовать за пределами клиентской области, но обрезаются по размеру внешнего окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-1031">Client area child widgets are clipped to the window client area, while non-client children such as scroll bars are allowed to draw outside of the client area, but are still clipped to the window outer dimensions.</span></span>

<span data-ttu-id="32aee-1032">Окна поддерживаются в виде структуры "родительский элемент — дочерний элемент", где дочерние элементы наследуют характеристики родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="32aee-1032">Windows are maintained in a parent-child manner, where the children inherit characteristics from their parent.</span></span> <span data-ttu-id="32aee-1033">У дочерних окон могут быть собственные дочерние окна, которые наследуют различные характеристики родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="32aee-1033">Children windows may have their own child windows, again inheriting various characteristics from the parent.</span></span> <span data-ttu-id="32aee-1034">Характеристики любого окна можно переопределить с помощью различных вызовов API GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1034">The characteristics of any window may be explicitly redefined via various GUIX API calls.</span></span>

### <a name="window-creation"></a><span data-ttu-id="32aee-1035">Создание окна</span><span class="sxs-lookup"><span data-stu-id="32aee-1035">Window Creation</span></span> 

<span data-ttu-id="32aee-1036">Объект окна можно создать во время инициализации или в любое время при выполнении потоков приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1036">A window object can be created during initialization or anytime during the execution of application threads.</span></span> <span data-ttu-id="32aee-1037">Количество объектов окна, которые можно создать с помощью приложения, не ограничено.</span><span class="sxs-lookup"><span data-stu-id="32aee-1037">There is no limit on the number of window objects that can be created by an application.</span></span> <span data-ttu-id="32aee-1038">Кроме того, нет ограничений на количество дочерних элементов для какого-либо окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-1038">There is also no limit on the number of children any window may have.</span></span>

### <a name="window-control-block"></a><span data-ttu-id="32aee-1039">Блок управления окном</span><span class="sxs-lookup"><span data-stu-id="32aee-1039">Window Control Block</span></span> 

<span data-ttu-id="32aee-1040">Характеристики каждого объекта окна расположены в блоке управления **GX_WINDOW** и определены в **_gx_api.h_**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1040">The characteristics of each window object are found in its control block **GX_WINDOW** and are defined in **_gx_api.h_**.</span></span> <span data-ttu-id="32aee-1041">Память, необходимая для объекта окна, предоставляется приложением и может находиться в любом месте в основной памяти.</span><span class="sxs-lookup"><span data-stu-id="32aee-1041">The memory required for a window object is provided by the application and can be located anywhere in memory.</span></span> <span data-ttu-id="32aee-1042">Однако чаще всего блок управления объектом окна становится глобальной структурой путем его определения вне области какой-либо функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-1042">However, it is most common to make the window object control block a global structure by defining it outside the scope of any function.</span></span>

### <a name="root-window"></a><span data-ttu-id="32aee-1043">Корневое окно</span><span class="sxs-lookup"><span data-stu-id="32aee-1043">Root Window</span></span> 

<span data-ttu-id="32aee-1044">В GUIX для каждого холста необходимо корневое окно.</span><span class="sxs-lookup"><span data-stu-id="32aee-1044">GUIX requires what is called a root window for each canvas.</span></span> <span data-ttu-id="32aee-1045">Корневое окно не имеет границ и имеет те же размеры, что и холст, к которому оно подключено.</span><span class="sxs-lookup"><span data-stu-id="32aee-1045">The root window is borderless and has the same dimensions as the canvas to which it is attached.</span></span> <span data-ttu-id="32aee-1046">Оно используется преимущественно в качестве контейнера для всех мини-приложений и окон первого уровня.</span><span class="sxs-lookup"><span data-stu-id="32aee-1046">It is used primarily as a container for all first-level widgets and windows.</span></span> <span data-ttu-id="32aee-1047">Корневое окно обычно создается приложением с помощью функции API ***gx_window_root_create*** сразу после создания экрана и холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-1047">The root window is typically created by the application via the API function ***gx_window_root_create***, shortly after the creation of the screen and canvas.</span></span> <span data-ttu-id="32aee-1048">Если используется функция gx_studio_display_configure, созданная с помощью Studio, адрес корневого окна может быть возвращен в соответствующее расположение в качестве последнего параметра этой функции.</span><span class="sxs-lookup"><span data-stu-id="32aee-1048">If you use the Studio generated function gx_studio_display_configure, the address of the root window can be returned in the location passed as the last parameter to this function.</span></span>

<span data-ttu-id="32aee-1049">По умолчанию корневое окно не может быть перемещено, и в самом простом случае корневое окно имеет размер холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-1049">A root window defaults to being un-moveable, and in the simplest case the root window is the size of the canvas.</span></span> <span data-ttu-id="32aee-1050">Корневое окно создает фон дисплея, поэтому для изменения цвета фона дисплея или для отображения фонового рисунка необходимо назначить корневому окну цвет или фоновый рисунок.</span><span class="sxs-lookup"><span data-stu-id="32aee-1050">The root window in effect draws the display background, so to change the display background color or to display background wallpaper you would assign a color or wallpaper to the root window.</span></span>

<span data-ttu-id="32aee-1051">Если корневое окно является перемещаемым, оно перемещается не путем изменения его положения на холсте подобно дочернему окну, а путем перемещения самого холста.</span><span class="sxs-lookup"><span data-stu-id="32aee-1051">If a root window is moveable, it moves not by changing its position on the canvas as a child window would do, but by moving the canvas itself.</span></span>
<span data-ttu-id="32aee-1052">Эта возможность позволяет корневому окну GUIX использовать оборудование, которое поддерживает несколько буферов кадров с аппаратными регистрами смещения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1052">This feature allows the GUIX root window to leverage hardware that supports multiple frame buffers with hardware offset registers.</span></span>

### <a name="background"></a><span data-ttu-id="32aee-1053">Фон</span><span class="sxs-lookup"><span data-stu-id="32aee-1053">Background</span></span> 

<span data-ttu-id="32aee-1054">Для фона окна используются либо сплошные цвета, либо растровые изображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1054">Window backgrounds are either solid colors or bitmap images.</span></span> <span data-ttu-id="32aee-1055">На системном уровне используется фон окна по умолчанию, который предоставляет значение по умолчанию для начального набора окон.</span><span class="sxs-lookup"><span data-stu-id="32aee-1055">There is a default window background at the system level which provides the default for the initial set of windows.</span></span> <span data-ttu-id="32aee-1056">Разумеется, любое фоновое окно можно изменить с помощью API GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1056">Of course, any window background can be changed via the GUIX API.</span></span>

<span data-ttu-id="32aee-1057">Чтобы изменить сплошной цвет фона окна, используйте API ***gx_widget_fill_color_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-1057">To change the solid color background of a window, use the ***gx_widget_fill_color_set*** API.</span></span> <span data-ttu-id="32aee-1058">Чтобы назначить фоновый рисунок для окна, используйте API ***gx_window_wallpaper_set***.</span><span class="sxs-lookup"><span data-stu-id="32aee-1058">To assign a background wallpaper to a window, use the ***gx_window_wallpaper_set*** API.</span></span>

### <a name="scrolling"></a><span data-ttu-id="32aee-1059">Прокрутка</span><span class="sxs-lookup"><span data-stu-id="32aee-1059">Scrolling</span></span> 

<span data-ttu-id="32aee-1060">GUIX поддерживает стандартную прокрутку окна, когда область для отображения дочерних окон превышает текущий размер окна (горизонтально и (или) вертикально).</span><span class="sxs-lookup"><span data-stu-id="32aee-1060">GUIX supports standard window scrolling when area required to display the window children exceeds the current size of the window – horizontally and/or vertically.</span></span> <span data-ttu-id="32aee-1061">Чтобы включить прокрутку, приложение должно создать нужные полосы прокрутки и подключить их к окну.</span><span class="sxs-lookup"><span data-stu-id="32aee-1061">To enable scrolling, the application must create the desired scroll bars and attach them to the window.</span></span>

<span data-ttu-id="32aee-1062">Компонент окна GUIX обеспечивает реализацию прокрутки по умолчанию на основе размера клиентской области окна и экстента всех дочерних мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-1062">The GUIX window component provides a default scrolling implementation based on the size of the window client area and the extent of the all child widgets.</span></span> <span data-ttu-id="32aee-1063">Приложения также могут предоставлять собственную реализацию и интерпретацию прокрутки путем переопределения функции ***gx_window_scroll_info_get*** для конкретного окна.</span><span class="sxs-lookup"><span data-stu-id="32aee-1063">Applications can also provide their own scrolling implementation and interpretation by overriding the ***gx_window_scroll_info_get*** function for a particular window.</span></span>

### <a name="event-notification"></a><span data-ttu-id="32aee-1064">Уведомление о событии</span><span class="sxs-lookup"><span data-stu-id="32aee-1064">Event Notification</span></span> 

<span data-ttu-id="32aee-1065">Функция обработки событий окна по умолчанию отличается от обработки событий GX_WIDGET преимущественно способом обработки событий прокрутки и изменения размера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1065">The default window event processing function differs from the GX_WIDGET event processing primarily in the handling of scrolling and sizing events.</span></span> <span data-ttu-id="32aee-1066">GX_WINDOW предоставляет обработчики по умолчанию для событий прокрутки и изменения размера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1066">GX_WINDOW provided defalt handlers for scrolling and sizing events.</span></span>

<span data-ttu-id="32aee-1067">Приложение может также добавлять собственные пользовательские события, начиная с числа после константы **GX_FIRST_APP_EVENT**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1067">The application can also add its own custom events, starting numerically after the constant **GX_FIRST_APP_EVENT**.</span></span> <span data-ttu-id="32aee-1068">Все номера событий после этой константы зарезервированы для использования приложением.</span><span class="sxs-lookup"><span data-stu-id="32aee-1068">All event numbers after this constant are reserved for the application’s use.</span></span> <span data-ttu-id="32aee-1069">Разумеется, обработчик событий окна приложения должен выполнить соответствующую обработку для этих событий приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1069">Of course, the application’s window event handler must have processing for such application events.</span></span>

### <a name="event-processing"></a><span data-ttu-id="32aee-1070">Обработка событий</span><span class="sxs-lookup"><span data-stu-id="32aee-1070">Event Processing</span></span> 

<span data-ttu-id="32aee-1071">Подобно всем остальным типам мини-приложений для каждого окна используется функция обработки событий окна по умолчанию с именем ***gx_window_event_process***.</span><span class="sxs-lookup"><span data-stu-id="32aee-1071">Just like all other widget types, there is a default window event processing function for every window, named ***gx_window_event_process***.</span></span> <span data-ttu-id="32aee-1072">Как правило, эта функция обработки событий переопределяется собственным обработчиком событий в создаваемых окнах.</span><span class="sxs-lookup"><span data-stu-id="32aee-1072">You will usually override this event handling function with your own event handler in the windows that you create.</span></span> <span data-ttu-id="32aee-1073">Таким способом вы реагируете на события и предпринимаете действия на основе событий, созданных дочерними элементами управления окном.</span><span class="sxs-lookup"><span data-stu-id="32aee-1073">This is how you will respond to events and take action based on events generated by the window child controls.</span></span>

<span data-ttu-id="32aee-1074">Важно вызывать базовую функцию ***gx_window_event_process*** для системных событий GUIX при переопределении соответствующего обработчика событий, чтобы разрешить обработку событий по умолчанию в дополнение к любому действию, которое добавляется в обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-1074">It is important to remember to invoke the base ***gx_window_event_process*** function for GUIX system events if you override that event handler, to allow the default event handling to occur in addition to whatever action you are adding to the event handler.</span></span> <span data-ttu-id="32aee-1075">Например, если используется пользовательский обработчик для события **GX_EVENT_SHOW** и это событие не передается в ***gx_window_event_process***, окно никогда не станет видимым.</span><span class="sxs-lookup"><span data-stu-id="32aee-1075">For example if you provide a custom handler for the **GX_EVENT_SHOW** event, and do not pass this event to ***gx_window_event_process***, your window will never become visible.</span></span>
<span data-ttu-id="32aee-1076">Чтобы предоставить пользовательский обработчик событий для окна, используйте функцию ***gx_widget_event_process_set*** для определения адреса обработчика событий.</span><span class="sxs-lookup"><span data-stu-id="32aee-1076">To provide a custom event handler for a window, use the ***gx_widget_event_process_set*** function to define the address of your event handler.</span></span> <span data-ttu-id="32aee-1077">Эта функция переопределяет функцию обработки событий по умолчанию функцией обработки событий, указанной в API.</span><span class="sxs-lookup"><span data-stu-id="32aee-1077">This function overrides the default event processing function with the event function processing function specified in the API.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-1078">Функции обработки событий приложения могут использовать обработку по умолчанию (т. е. не дублировать обработку), просто вызвав обработку по умолчанию ***gx_window_event_process*** напрямую.</span><span class="sxs-lookup"><span data-stu-id="32aee-1078">Application event processing functions can take advantage (i.e., not duplicate the processing) of the default processing by simply calling the default ***gx_window_event_process*** directly.</span></span>

<span data-ttu-id="32aee-1079">Обработка событий вызывается исключительно из контекста внутреннего системного потока GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1079">Event processing is called exclusively from the context of the internal GUIX system thread.</span></span> <span data-ttu-id="32aee-1080">Таким образом, требования стека обрабатывать события применяются только к потоку GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1080">In this way, the stack requirements to process the event handling only applies to the GUIX thread.</span></span>

## <a name="guix-image-reader-component"></a><span data-ttu-id="32aee-1081">Компонент читателя изображений GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-1081">GUIX Image Reader Component</span></span> 

<span data-ttu-id="32aee-1082">Компонент читателя изображений предоставляет служебные программы и функции API для распаковки необработанных сжатых изображений в формате пиксельных карт GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1082">The image reader component provides utilities and API functions to decompress raw compressed images to GUIX pixelmap format.</span></span> <span data-ttu-id="32aee-1083">Необработанные данные изображений в формате JPEG и PNG поддерживаются. Дополнительные форматы зарезервированы для будущих выпусков.</span><span class="sxs-lookup"><span data-stu-id="32aee-1083">JPEG and PNG format raw image data are supported, with additional formats reserved for future releases.</span></span>

<span data-ttu-id="32aee-1084">Обратите внимание, что для большинства приложений GUIX не требуется компонент читателя изображений GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1084">Note that for the vast majority of GUIX applications, the GUIX Image Reader component is not required.</span></span> <span data-ttu-id="32aee-1085">Большинство приложений используют приложение GUIX Studio для преобразования графических ресурсов в формате JPEG и PNG в GUIX-совместимые ресурсы **GX_PIXELMAP**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1085">Most applications rely on the GUIX Studio application to convert JPEG and PNG format graphics assets into GUIX compatible **GX_PIXELMAP** resources.</span></span> <span data-ttu-id="32aee-1086">Компонент читателя изображений GUIX используется, когда необработанные графические ресурсы известны только в среде выполнения или если ограничения хранилища системы не позволяют хранить ресурсы в формате **GX_PIXELMAP**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1086">The GUIX image reader component is utilized when the raw graphics assets are known only at runtime, or when the system storage constraints prevent storing resources in **GX_PIXELMAP** format.</span></span> <span data-ttu-id="32aee-1087">Данные изображений в формате JPEG и PNG обычно более компактны, чем в формате **GX_PIXELMAP**, однако при этом возникают значительные нагрузки в среде выполнения, связанные с динамическим выполнением распаковки и преобразования цветового пространства этих типов изображений.</span><span class="sxs-lookup"><span data-stu-id="32aee-1087">JPEG and PNG format image data is generally more compact than **GX_PIXELMAP** format, however there is considerable runtime overhead associated with performing decompression and color space conversion of these image types dynamically.</span></span>

<span data-ttu-id="32aee-1088">Если изображения в необработанном формате JPEG или PNG передаются в функцию API gx_canvas_pixelmap_draw, GUIX динамически распаковывает данные JPEG или PNG и выполняет соответствующую операцию рисования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1088">If raw format JPEG or PNG images are passed to the gx_canvas_pixelmap_draw API function, GUIX dynamically decompresses and draws the JPEG or PNG data.</span></span> <span data-ttu-id="32aee-1089">Обратите внимание, что это окажет значительное негативное влияние на скорость рисования в среде выполнения. Передача данных изображения в формате RAW в функцию gx_canvas_pixelmap_draw не рекомендуется, если вы не используете аппаратный целевой объект, который поддерживает аппаратную распаковку данных JPEG или PNG.</span><span class="sxs-lookup"><span data-stu-id="32aee-1089">Note that this will have a significant negative impact on runtime drawing speed, and passing RAW format image data to the gx_canvas_pixelmap_draw function is not recommended unless you are using a hardware target that supports hardware assisted JPEG or PNG decompression.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="32aee-1090">Передача необработанных изображений в формате JPEG или PNG в API gx_canvas_pixelmap_draw приводит к значительной нагрузке в среде выполнения для большей части целевого оборудования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1090">Passing raw JPEG or PNG formatted images to the gx_canvas_pixelmap_draw API incurs significant runtime overhead for most target hardware.</span></span>

<span data-ttu-id="32aee-1091">В качестве альтернативы необработанные данные JPEG и PNG можно преобразовать в формат GX_PIXELMAP в среде выполнения с помощью компонента читателя изображений.</span><span class="sxs-lookup"><span data-stu-id="32aee-1091">As an alternative, raw JPEG and PNG data may be converted to GX_PIXELMAP format at runtime using the Image Reader component.</span></span>
<span data-ttu-id="32aee-1092">Созданные таким образом пиксельные карты можно использовать и рисовать так же, как пиксельные карты, созданные в Studio и содержащиеся в вашем файле ресурсов.</span><span class="sxs-lookup"><span data-stu-id="32aee-1092">Pixelmaps produced in this way can be used and drawn just like pixelmaps produced by Studio and contained within your resource file.</span></span> <span data-ttu-id="32aee-1093">Это позволяет вашему приложению выполнять распаковку изображения, сглаживание и преобразование цветового пространства один раз (обычно во время запуска программы) вместо того, чтобы выполнять эти операции каждый раз при создании изображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1093">This allows your application to perform the image decompression, dithering, and color space conversion one time (usually during program startup) rather than performing these operations each time the image is drawn.</span></span>

<span data-ttu-id="32aee-1094">Функции компонента читателя изображений указаны ниже.</span><span class="sxs-lookup"><span data-stu-id="32aee-1094">The Image Reader component functions include:</span></span>

<span data-ttu-id="32aee-1095">***gx_image_reader_create***</span><span class="sxs-lookup"><span data-stu-id="32aee-1095">***gx_image_reader_create***</span></span>  
<span data-ttu-id="32aee-1096">***gx_image_reader_palette_set***</span><span class="sxs-lookup"><span data-stu-id="32aee-1096">***gx_image_reader_palette_set***</span></span>  
<span data-ttu-id="32aee-1097">***gx_image_reader_start***</span><span class="sxs-lookup"><span data-stu-id="32aee-1097">***gx_image_reader_start***</span></span>

## <a name="guix-animation-component"></a><span data-ttu-id="32aee-1098">Компонент анимации GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-1098">GUIX Animation Component</span></span> 

<span data-ttu-id="32aee-1099">Компонент анимации GUIX — это набор функций и служб, используемых для автоматизации операций экрана и переходов мини-приложений.</span><span class="sxs-lookup"><span data-stu-id="32aee-1099">The GUIX Animation component is a set of functions and services used to automate screen and widget transition automations.</span></span> <span data-ttu-id="32aee-1100">Компонент анимации GUIX поддерживает эффекты появления, исчезания, перемещения или анимации перемещения для любого типа мини-приложения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1100">The GUIX Animation component supports fading in, fading out, and movement or slide type animations of any widget type.</span></span>

<span data-ttu-id="32aee-1101">Анимация появления и исчезания изображения может поддерживаться путем изменения внутреннего альфа-фактора соответствующего эффекта мини-приложения (если элемент **GX_BRUSH_ALPHA_SUPPORT** включен) или путем рисования любой коллекции мини-приложений на отдельном холсте памяти и соответствующего смешения с фоном.</span><span class="sxs-lookup"><span data-stu-id="32aee-1101">Fade type animations can be supported either by varying the fading widget(s) internal alpha value (if **GX_BRUSH_ALPHA_SUPPORT** is enabled), or by drawing any collection of widgets to a separate memory canvas when is then blended with the background.</span></span> <span data-ttu-id="32aee-1102">Для аппаратных целевых объектов, которые поддерживают несколько аппаратных графических слоев, поддержка эффектов плавного появления и исчезания изображения лучше всего достигается с помощью данного подхода смешения холста (часто с использованием невысокой требуемой пропускной способности ЦП).</span><span class="sxs-lookup"><span data-stu-id="32aee-1102">For hardware targets that support multiple hardware graphics layers, support for smooth fading effects is best accomplished using this canvas blending approach, often with very little core CPU bandwidth required.</span></span> <span data-ttu-id="32aee-1103">Для аппаратных целевых объектов, которые не поддерживают несколько графических слоев, смешение с использованием альфа-фактора кисти GUIX поддерживается при использовании глубин цвета 16 бит/пкс и выше.</span><span class="sxs-lookup"><span data-stu-id="32aee-1103">For hardware targets that do not support multiple graphics layers, blending using the GUIX brush alpha value is supported when running at 16 bpp and higher color depths.</span></span>

<span data-ttu-id="32aee-1104">Если для анимации должно использоваться отдельное полотно, компонент анимации GUIX предоставляет службу API gx_animation_canvas_define для этой цели.</span><span class="sxs-lookup"><span data-stu-id="32aee-1104">If an animation should use a separate drawing canvas, the GUIX Animation component provides the API service gx_animation_canvas_define for this purpose.</span></span> <span data-ttu-id="32aee-1105">Для других типов анимации не требуется отдельный холст, но они используют его, если он доступен.</span><span class="sxs-lookup"><span data-stu-id="32aee-1105">Other animation types do not require a separate canvas, but they will utilize it if it is available.</span></span> <span data-ttu-id="32aee-1106">Это позволяет максимально эффективно использовать любую базовую поддержку оборудования для нескольких аппаратных поверхностей.</span><span class="sxs-lookup"><span data-stu-id="32aee-1106">This makes the best possible use of any underlying hardware support for multiple hardware surfaces.</span></span>

<span data-ttu-id="32aee-1107">Переменные, управляющие анимацией, определяются с помощью двух блоков управления.</span><span class="sxs-lookup"><span data-stu-id="32aee-1107">The variables controlling an animation are defined by two control blocks.</span></span> <span data-ttu-id="32aee-1108">Сначала — блоком управления **GX_ANIMATION**, который определяет контроллер анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1108">First, the **GX_ANIMATION** control block which defines the animation controller.</span></span> <span data-ttu-id="32aee-1109">Контроллер анимации — это обработчик, который выполняет определенную последовательность анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1109">The animation controller is the driving engine that executes the animation sequence you define.</span></span> <span data-ttu-id="32aee-1110">Один контроллер анимации можно использовать многократно для выполнения различных последовательностей анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1110">A single animation controller can be re-used many times to run many different animation sequences.</span></span> <span data-ttu-id="32aee-1111">Если требуется одновременное выполнение нескольких последовательностей анимации, можно создать несколько контроллеров анимации **GX_ANIMATION**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1111">If you need to run multiple animation sequences simultaneously, you can create multiple **GX_ANIMATION** animation controllers.</span></span>

<span data-ttu-id="32aee-1112">Системный компонент GUIX может предоставить многократно используемый блок структур управления **GX_ANIMATION**, которые могут запрашиваться приложением, когда требуется анимация, и автоматически возвращаться в системный пул при завершении последовательности анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1112">The GUIX system component can provide a re-usable block of **GX_ANIMATION** control structures, which can be requested by the application when and animation is needed and are automatically returned to the system pool when the animation sequence is completed.</span></span> <span data-ttu-id="32aee-1113">Это освобождает приложение от необходимости статического определения структуры **GX_ANIMATION** для каждой анимации при ее реализации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1113">This frees the application from statically defining a **GX_ANIMATION** structure for every animation that might be implemented.</span></span> <span data-ttu-id="32aee-1114">Размер этого пула структур **GX_ANIMATION** определяется константой **GX_ANIMATION_POOL_SIZE**, у которой значение по умолчанию — 6. Это означает, что по умолчанию из системного пула можно выделить 6 одновременных анимаций.</span><span class="sxs-lookup"><span data-stu-id="32aee-1114">The size of this pool of **GX_ANIMATION** structures is defined by the constant **GX_ANIMATION_POOL_SIZE**, which defaults to 6, meaning that by default 6 simultaneous animations can be allocated from the system pool.</span></span> <span data-ttu-id="32aee-1115">Эта константа может быть переопределена в файле заголовка gx_user.h, если требуется больше одновременных анимаций.</span><span class="sxs-lookup"><span data-stu-id="32aee-1115">This constant can of course be re-defined in the gx_user.h header file is more simultaneous animations are required.</span></span> <span data-ttu-id="32aee-1116">Если **GX_ANIMATION_POOL_SIZE** имеет значение 0, то системный компонент GUIX не предоставляет пул анимаций или связанные службы.</span><span class="sxs-lookup"><span data-stu-id="32aee-1116">If **GX_ANIMATION_POOL_SIZE** is set to zero, then the GUIX system component does not provide an animation pool or related services.</span></span>

<span data-ttu-id="32aee-1117">Вторым блоком управления или второй структурой, которые используются для определения анимации, является структура **GX_ANIMATION_INFO**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1117">The second control block or structure used to define an animation is the **GX_ANIMATION_INFO** structure.</span></span> <span data-ttu-id="32aee-1118">Эта структура используется для определения одной конкретной последовательности анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1118">This structure is used to define one particular animation sequence.</span></span> <span data-ttu-id="32aee-1119">Эта информационная структура передается в контроллер анимации для инициации последовательности анимации с помощью службы API gx_animation_start.</span><span class="sxs-lookup"><span data-stu-id="32aee-1119">You pass this information structure to your animation controller to initiate an animation sequence using the gx_animation_start API service.</span></span> <span data-ttu-id="32aee-1120">Структура **GX_ANIMATION_INFO** содержит следующие поля:</span><span class="sxs-lookup"><span data-stu-id="32aee-1120">The **GX_ANIMATION_INFO** structure contains the following fields:</span></span>

```C
typedef struct GX_ANIMATION_INFO_STRUCT
{
    GX_WIDGET *gx_animation_target;
    GX_WIDGET *gx_animation_parent;
    GX_WIDGET *gx_animation_screen_list;
    USHORT gx_animation_style;
    USHORT gx_animation_id;
    USHORT gx_animation_start_delay;
    USHORT gx_animation_frame_interval;
    GX_POINT gx_animation_start_position;
    GX_POINT gx_animation_end_position;
    GX_UBYTE gx_animation_start_alpha;
    GX_UBYTE gx_animation_end_alpha;
    GX_UBYTE gx_animation_steps;
} GX_ANIMATION_INFO;
```

<span data-ttu-id="32aee-1121">Элемент **gx_animation_target** определяет целевое мини-приложение, на основе которого будет работать контроллер анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1121">The **gx_animation_target** member defines the target widget that the animation controller will act upon.</span></span>

<span data-ttu-id="32aee-1122">Элемент **gx_animation_parent** определяет родительское мини-приложение, если таковое имеется, к которому будет подключено целевое мини-приложение после завершения последовательности анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1122">The **gx_animation_parent** member defines the parent widget, if any, to which the target widget will be attached when the animation sequence is complete.</span></span> <span data-ttu-id="32aee-1123">Элемент gx_animation_parent является также получателем события GX_ANIMATION_COMPLETE, которое создается при завершении анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1123">The gx_animation_parent is also the recipient of the GX_ANIMATION_COMPLETE event that is generated when an animation is completed.</span></span>

<span data-ttu-id="32aee-1124">Элемент **gx_animation_screen_list** определяет список мини-приложений для анимаций перетаскивания экрана при вводе с помощью пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1124">The **gx_animation_screen_list** member defines a widget list for pen-input-driven screen slide animations.</span></span> <span data-ttu-id="32aee-1125">Список мини-приложений должен заканчиваться указателем GX_NULL, а каждое мини-приложение в списке должно иметь те же измерения x, y, что и элемент gx_animation_parent.</span><span class="sxs-lookup"><span data-stu-id="32aee-1125">The widge list should be terminated with GX_NULL pointer, and each widget in the list should have the same x,y dimensions as the gx_animation_parent.</span></span>

<span data-ttu-id="32aee-1126">**gx_animation_style** — это битовая маска, определяющая тип выполняемой анимации и связанные с ней параметры.</span><span class="sxs-lookup"><span data-stu-id="32aee-1126">The **gx_animation_style** is a bitmask defining the type of animation to be performed and associated options.</span></span> <span data-ttu-id="32aee-1127">К флагам стиля анимации относятся указанные ниже элементы.</span><span class="sxs-lookup"><span data-stu-id="32aee-1127">The animation style flags include the following.</span></span>

| <span data-ttu-id="32aee-1128">Флаг &nbsp;стиля&nbsp; анимации</span><span class="sxs-lookup"><span data-stu-id="32aee-1128">Animation&nbsp;Style&nbsp;Flag</span></span> | <span data-ttu-id="32aee-1129">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-1129">Description</span></span> |
| --- | --- |
| <span data-ttu-id="32aee-1130">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="32aee-1130">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="32aee-1131">Запрос анимации перетаскивания или типа эффекта исчезания или появления изображения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1131">Request a slide or fade type animation.</span></span> |
| <span data-ttu-id="32aee-1132">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="32aee-1132">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="32aee-1133">Запрос анимации перетаскивания экрана при вводе с помощью пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1133">Request a pen-input driven screen drag animation.</span></span> |

<span data-ttu-id="32aee-1134">Указанные ниже флаги можно использовать в сочетании с анимацией типа **SCREEN_DRAG**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1134">The following flags can be used in combination with **SCREEN_DRAG** type animations.</span></span>

| <span data-ttu-id="32aee-1135">Флаги&nbsp;перетаскивания&nbsp;экрана</span><span class="sxs-lookup"><span data-stu-id="32aee-1135">Screen&nbsp;Drag&nbsp;Flags</span></span> | <span data-ttu-id="32aee-1136">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-1136">Description</span></span> |
| --- | --- |
| <span data-ttu-id="32aee-1137">GX_ANIMATION_WRAP</span><span class="sxs-lookup"><span data-stu-id="32aee-1137">GX_ANIMATION_WRAP</span></span> | <span data-ttu-id="32aee-1138">Перенос списка экранов должен выполняться от конечного элемента обратно к начальному элементу.</span><span class="sxs-lookup"><span data-stu-id="32aee-1138">The screen list should wrap from end back to start.</span></span> |
| <span data-ttu-id="32aee-1139">GX_ANIMATION_HORIZONTAL</span><span class="sxs-lookup"><span data-stu-id="32aee-1139">GX_ANIMATION_HORIZONTAL</span></span> | <span data-ttu-id="32aee-1140">Перетаскивание экрана разрешено в горизонтальном направлении.</span><span class="sxs-lookup"><span data-stu-id="32aee-1140">Screen drag allowed in horizontal direction.</span></span>  |
| <span data-ttu-id="32aee-1141">GX_ANIMATION_VERTICAL</span><span class="sxs-lookup"><span data-stu-id="32aee-1141">GX_ANIMATION_VERTICAL</span></span> | <span data-ttu-id="32aee-1142">Перетаскивание экрана разрешено в вертикальном направлении.</span><span class="sxs-lookup"><span data-stu-id="32aee-1142">Screen drag allowed in vertical direction.</span></span> |

<span data-ttu-id="32aee-1143">Указанный ниже флаг можно использовать в сочетании с анимациями преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1143">The following flag can be used in combination with translate animations.</span></span>

| <span data-ttu-id="32aee-1144">Флаги&nbsp;анимаций&nbsp;преобразования</span><span class="sxs-lookup"><span data-stu-id="32aee-1144">Translate&nbsp;Animations&nbsp;Flags</span></span> | <span data-ttu-id="32aee-1145">Описание</span><span class="sxs-lookup"><span data-stu-id="32aee-1145">Description</span></span> |
| --- | --- |
| <span data-ttu-id="32aee-1146">GX_ANIMATION_DETACH</span><span class="sxs-lookup"><span data-stu-id="32aee-1146">GX_ANIMATION_DETACH</span></span> | <span data-ttu-id="32aee-1147">Удалите целевой объект анимации из родительского элемента анимации по завершении анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1147">Detach the animation target from the animation parent when the animation is completed.</span></span> <span data-ttu-id="32aee-1148">Если целевой объект динамически выделен и создан с помощью автоматизированной обработки событий на основе GUIX Studio, он удаляется после его отключения.</span><span class="sxs-lookup"><span data-stu-id="32aee-1148">If the target was dynamically allocated and created by the GUIX Studio generated automated event handling, the target will be deleted after it is detached.</span></span> |
| <span data-ttu-id="32aee-1149">GX_ANIMATION_TRANSLATE</span><span class="sxs-lookup"><span data-stu-id="32aee-1149">GX_ANIMATION_TRANSLATE</span></span> | <span data-ttu-id="32aee-1150">Типы анимации — это анимации, управляемые таймером.</span><span class="sxs-lookup"><span data-stu-id="32aee-1150">Animation types are timer driven animations.</span></span> <span data-ttu-id="32aee-1151">Приложение определяет начальное и конечное положение, а также начальный и конечный альфа-фактор для целевого мини-приложения, а диспетчер анимации создает таймер для выполнения анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1151">The application defines the starting and ending position and starting and ending alpha value for the target widget, and the animation manager creates a timer to serve and as the driving force to execute the animation.</span></span>
| <span data-ttu-id="32aee-1152">GX_ANIMATION_SCREEN_DRAG</span><span class="sxs-lookup"><span data-stu-id="32aee-1152">GX_ANIMATION_SCREEN_DRAG</span></span> | <span data-ttu-id="32aee-1153">Отличается от анимаций **TRANSLATE** тем, что этот тип анимации инициируется событиями ввода с помощью пера.</span><span class="sxs-lookup"><span data-stu-id="32aee-1153">Differs from the **TRANSLATE** animations in that this animation type is driven by pen input events.</span></span> <span data-ttu-id="32aee-1154">Этот тип анимации отслеживает при вводе с помощью сенсорного экрана прокрутку целевого мини-приложения, когда пользователь перетаскивает перо на сенсорном экране ввода.</span><span class="sxs-lookup"><span data-stu-id="32aee-1154">This animation type tracks along with the touch screen input to swipe the target widget as the user drags a pen or stylus across the input touch screen.</span></span> <span data-ttu-id="32aee-1155">Чтобы использовать этот тип анимации, приложение должно вызвать API **_gx_animation_drag_enable_** и включить эту анимацию.</span><span class="sxs-lookup"><span data-stu-id="32aee-1155">To utilize this type of animation, the application should call the **_gx_animation_drag_enable_** API to enable this animation.</span></span> |

<span data-ttu-id="32aee-1156">Значение **gx_animation_id** передается обратно родительскому элементу анимации в поле event.gx_event_sender события **GX_ANIMATION_COMPLETE**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1156">The **gx_animation_id** value is passed back to the animation parent in the event.gx_event_sender field of the **GX_ANIMATION_COMPLETE** event.</span></span> <span data-ttu-id="32aee-1157">Это значение используется родительским элементом анимации для определения того, какая из возможных нескольких дочерних анимаций сообщает о завершении операции.</span><span class="sxs-lookup"><span data-stu-id="32aee-1157">This value is used by the animation parent to determine which of possibly several child animations is reporting completion.</span></span> <span data-ttu-id="32aee-1158">Это значение может быть равно 0, а анимация со значением идентификатора 0 не может создать событие **ANIMATION_COMPLETE**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1158">This value can be 0, and an animation with ID value 0 will not generate an **ANIMATION_COMPLETE** event at all.</span></span>

<span data-ttu-id="32aee-1159">Значение **gx_animation_start_delay** — это счетчик тактов GUIX, указывающий количество тактов таймера для задержки после вызова **_gx_animation_start_ *_ перед фактическим выполнением анимации. Значение может быть равно 0 для запуска анимации сразу после вызова _* _gx_animation_start_**.</span><span class="sxs-lookup"><span data-stu-id="32aee-1159">The **gx_animation_start_delay** value is a GUIX tick count indicating the number of timer ticks to delay after **_gx_animation_start_*_ is called before actually executing the animation. The value can be 0 to start the animation immediately upon calling _*_gx_animation_start_**.</span></span>

<span data-ttu-id="32aee-1160">Поле **gx_animation_frame_interval** определяет количество тактов таймера GUIX (кратное частоте тактов ОС) для задержки между кадрами последовательности анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1160">The **gx_animation_frame_interval** field defines the number of GUIX timer ticks (a multiple of the underlying OS tick rate) to delay between each frame of the animation sequence.</span></span> <span data-ttu-id="32aee-1161">Минимальное значение: 1.</span><span class="sxs-lookup"><span data-stu-id="32aee-1161">The minimum value is 1.</span></span>

<span data-ttu-id="32aee-1162">Элемент **gx_animation_start_position** определяет начальную верхнюю левую точку для целевого мини-приложения для анимаций преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1162">The **gx_animation_start_position** defines the top-left starting point for the target widget for translation animations.</span></span>

<span data-ttu-id="32aee-1163">Элемент **gx_animation_end_position** определяет конечную верхнюю левую точку для целевого мини-приложения для анимаций типа преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1163">The **gx_animation_end_position** defines the top-left ending position for the target widget for translation type animations.</span></span>

<span data-ttu-id="32aee-1164">Поле **gx_animation_start_alpha** определяет начальное значение альфа-фактора холста для анимаций типа преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1164">The **gx_animation_start_alpha** field defines the starting canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="32aee-1165">Поле **gx_animation_end_alpha** определяет конечное значение альфа-фактора холста для анимаций типа преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1165">The **gx_animation_end_alpha** field defines the ending canvas alpha value for translation type animations.</span></span>

<span data-ttu-id="32aee-1166">Поле **gx_animation_steps** определяет количество шагов или кадров, которые контроллер должен выполнить для анимаций преобразования.</span><span class="sxs-lookup"><span data-stu-id="32aee-1166">The **gx_animation_steps** field defines how many steps or frames the controller should execute for translation animations.</span></span> <span data-ttu-id="32aee-1167">Чем больше шагов, тем более гладко выполняется перетаскивание и (или) появление (исчезание) изображения, но для этого также требуется большая пропускная способность системы.</span><span class="sxs-lookup"><span data-stu-id="32aee-1167">A larger number of steps produces a smoother slide and/or fade appearance, but also requires greater system bandwidth.</span></span>

<span data-ttu-id="32aee-1168">Чтобы реализовать эффекты анимации в приложении, необходимо сначала вызвать ***gx_animation_create*** для инициализации контроллера анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1168">To implement animation effects in your application, you must first call ***gx_animation_create*** to initialize your animation controller.</span></span> <span data-ttu-id="32aee-1169">Если для анимации используется вторичный холст, инициализируйте данный холст, вызвав gx_animation_canvas_define.</span><span class="sxs-lookup"><span data-stu-id="32aee-1169">If your animation will be using a secondary canvas, initialize this canvas by calling gx_animation_canvas_define.</span></span> <span data-ttu-id="32aee-1170">Далее следует инициализировать структуру **GX_ANIMATION_INFO**, чтобы определить конкретный тип выполняемой анимации и другие параметры анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1170">Next, you should initialize the **GX_ANIMATION_INFO** structure to define the specific type of animation to be performed and the other animation parameters.</span></span> <span data-ttu-id="32aee-1171">Наконец, вызовите gx_animation_start, чтобы запустить последовательность анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1171">Finally, call gx_animation_start to trigger the animation sequence.</span></span>

<span data-ttu-id="32aee-1172">Когда контроллер анимации завершает последовательность анимации, он отправляет событие **GX_ANIMATION_COMPLETE** родительскому мини-приложению для выполнения всех необходимых операций очистки холста анимации.</span><span class="sxs-lookup"><span data-stu-id="32aee-1172">When the animation controller completes an animation sequence, it sends an **GX_ANIMATION_COMPLETE** event to the parent widget, allowing the any desired cleanup of the animation canvas to be done at that time.</span></span>

## <a name="guix-utility-component"></a><span data-ttu-id="32aee-1173">Компонент служебной программы GUIX</span><span class="sxs-lookup"><span data-stu-id="32aee-1173">GUIX Utility Component</span></span> 

<span data-ttu-id="32aee-1174">Компонент служебной программы выполняет все общие служебные функции в GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1174">The utility component is responsible for all common utility functions in GUIX.</span></span> <span data-ttu-id="32aee-1175">Это распространенные функции, которые являются полезными служебными программами. Их можно вызвать из любого расположения в приложении или во внутреннем коде GUIX.</span><span class="sxs-lookup"><span data-stu-id="32aee-1175">These are common functions that are useful utilities and can be invoked from anywhere in the application or the internal GUIX code.</span></span> <span data-ttu-id="32aee-1176">Служебные функции компонентов указаны ниже.</span><span class="sxs-lookup"><span data-stu-id="32aee-1176">The utility component functions include the following.</span></span>

<span data-ttu-id="32aee-1177">***gx_utility_canvas_to_bmp***</span><span class="sxs-lookup"><span data-stu-id="32aee-1177">***gx_utility_canvas_to_bmp***</span></span>

<span data-ttu-id="32aee-1178">***gx_utility_circle_point_get***</span><span class="sxs-lookup"><span data-stu-id="32aee-1178">***gx_utility_circle_point_get***</span></span>

<span data-ttu-id="32aee-1179">***gx_utility_alphamap_create***</span><span class="sxs-lookup"><span data-stu-id="32aee-1179">***gx_utility_alphamap_create***</span></span>

<span data-ttu-id="32aee-1180">***gx_utility_gradient_create***</span><span class="sxs-lookup"><span data-stu-id="32aee-1180">***gx_utility_gradient_create***</span></span>

<span data-ttu-id="32aee-1181">***gx_utility_gradient_delete***</span><span class="sxs-lookup"><span data-stu-id="32aee-1181">***gx_utility_gradient_delete***</span></span>

<span data-ttu-id="32aee-1182">***gx_utlity_ltoa***</span><span class="sxs-lookup"><span data-stu-id="32aee-1182">***gx_utlity_ltoa***</span></span>

<span data-ttu-id="32aee-1183">***gx_utility_math_acos***</span><span class="sxs-lookup"><span data-stu-id="32aee-1183">***gx_utility_math_acos***</span></span>

<span data-ttu-id="32aee-1184">***gx_utility_math_asin***</span><span class="sxs-lookup"><span data-stu-id="32aee-1184">***gx_utility_math_asin***</span></span>

<span data-ttu-id="32aee-1185">***gx_utility_math_cos***</span><span class="sxs-lookup"><span data-stu-id="32aee-1185">***gx_utility_math_cos***</span></span>

<span data-ttu-id="32aee-1186">***gx_utility_math_sin***</span><span class="sxs-lookup"><span data-stu-id="32aee-1186">***gx_utility_math_sin***</span></span>

<span data-ttu-id="32aee-1187">***gx_utility_math_sqrt***</span><span class="sxs-lookup"><span data-stu-id="32aee-1187">***gx_utility_math_sqrt***</span></span>

<span data-ttu-id="32aee-1188">***gx_utility_pixelmap_resize***</span><span class="sxs-lookup"><span data-stu-id="32aee-1188">***gx_utility_pixelmap_resize***</span></span>

<span data-ttu-id="32aee-1189">***gx_utility_pixelmap_rotate***</span><span class="sxs-lookup"><span data-stu-id="32aee-1189">***gx_utility_pixelmap_rotate***</span></span>

<span data-ttu-id="32aee-1190">***gx_utility_pixelmap_simple_rotate***</span><span class="sxs-lookup"><span data-stu-id="32aee-1190">***gx_utility_pixelmap_simple_rotate***</span></span>

<span data-ttu-id="32aee-1191">***gx_utility_rectangle_center***</span><span class="sxs-lookup"><span data-stu-id="32aee-1191">***gx_utility_rectangle_center***</span></span>

<span data-ttu-id="32aee-1192">***gx_utility_rectangle_center_find***</span><span class="sxs-lookup"><span data-stu-id="32aee-1192">***gx_utility_rectangle_center_find***</span></span>

<span data-ttu-id="32aee-1193">***gx_utility_rectangle_combine***</span><span class="sxs-lookup"><span data-stu-id="32aee-1193">***gx_utility_rectangle_combine***</span></span>

<span data-ttu-id="32aee-1194">***gx_utility_rectangle_compare***</span><span class="sxs-lookup"><span data-stu-id="32aee-1194">***gx_utility_rectangle_compare***</span></span>

<span data-ttu-id="32aee-1195">***gx_utility_rectangle_define***</span><span class="sxs-lookup"><span data-stu-id="32aee-1195">***gx_utility_rectangle_define***</span></span>

<span data-ttu-id="32aee-1196">***gx_utility_rectangle_overlap_detect***</span><span class="sxs-lookup"><span data-stu-id="32aee-1196">***gx_utility_rectangle_overlap_detect***</span></span>

<span data-ttu-id="32aee-1197">***gx_utility_rectangle_point_detect***</span><span class="sxs-lookup"><span data-stu-id="32aee-1197">***gx_utility_rectangle_point_detect***</span></span>

<span data-ttu-id="32aee-1198">***gx_utility_rectangle_resize***</span><span class="sxs-lookup"><span data-stu-id="32aee-1198">***gx_utility_rectangle_resize***</span></span>

<span data-ttu-id="32aee-1199">***gx_utility_rectangle_shift***</span><span class="sxs-lookup"><span data-stu-id="32aee-1199">***gx_utility_rectangle_shift***</span></span>

<span data-ttu-id="32aee-1200">***gx_utility_string_to_alphamap***</span><span class="sxs-lookup"><span data-stu-id="32aee-1200">***gx_utility_string_to_alphamap***</span></span>
