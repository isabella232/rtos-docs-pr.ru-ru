---
title: Глава 3. Функциональное описание ОСРВ Azure NetX Secure DTLS
description: Эта глава содержит функциональное описание ОСРВ Azure NetX Secure DTLS.
author: philmea
ms.author: philmea
ms.date: 06/04/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: 7db319e45c6d1f4a2030734fc01fefc4f3907aebeec1b3f47a5bde57dd5bfcc4
ms.sourcegitcommit: 93d716cf7e3d735b18246d659ec9ec7f82c336de
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/07/2021
ms.locfileid: "116797097"
---
# <a name="chapter-3-functional-description-of-azure-rtos-netx-secure-dtls"></a>Глава 3. Функциональное описание ОСРВ Azure NetX Secure DTLS

## <a name="execution-overview"></a>Общие сведения о выполнении

Эта глава содержит функциональное описание ОСРВ Azure NetX Secure DTLS. В приложении NetX Secure DTLS используются два основных типа выполнения программы: инициализация и вызовы интерфейса приложения. 

NetX Secure предполагает наличие компонентов ThreadX и NetX или NetX Duo. В ThreadX требуется выполнение потоков, приостановка, периодические таймеры и средства взаимного исключения. В NetX или NetX Duo требуются сетевые средства и драйверы UDP и IP.

## <a name="datagram-transport-layer-security-dtls-and-transport-layer-security-tls"></a>Протоколы DTLS и TLS

NetX Secure DTLS реализует протокол датаграмм безопасности транспортного уровня версии 1.2, определенный в документе RFC 6347. Протокол DTLS версии 1.0 был определен в документе RFC 4347 и соответствует протоколу TLS версии 1.1. Так как DTLS является расширением протокола TLS, было решено, что его следующая версия получит тот же номер, что и соответствующая версия протокола TLS. Поэтому не существует протокол DTLS версии 1.1, так как протоколу TLS версии 1.2 соответствует DTLS версии 1.2.

> [!NOTE]
> NetX Secure поддерживает DTLS версии 1.2. Протокол DTLS 1.0 (RFC 4347) в настоящее время **не** поддерживается.

*SSL* — это первоначальное название протокола TLS, использовавшееся до того, как он стал стандартом в RFC 2246, и название "SSL" часто используется в качестве универсального названия протоколов TLS. Последней версией SSL была версия 3.0, а протокол TLS 1.0 иногда называют протоколом SSL версии 3.1. Все версии официального протокола SSL считаются устаревшими и небезопасными, и в настоящее время NetX Secure не предоставляет реализацию SSL.

TLS задает протокол для создания *ключей сеанса*, которые создаются во время *подтверждения* TLS между клиентом и сервером TLS. Эти ключи используются для шифрования данных, отправляемых приложением во время *сеанса* TLS.

Протокол DTLS тесно связан с протоколом TLS, так как в них используются одинаковые механизмы безопасности. Тем не менее, протокол TLS предназначен для работы на транспортном уровне, обеспечивающем гарантированную доставку пакетов и их порядок. На практике почти всегда это протокол TCP, так как протокол TLS не будет функционировать посредством ненадежного протокола, например UDP. Именно из-за протокола UDP был создан протокол DTLS. Протокол DTLS был разработан специально с учетом ненадежности протокола UDP и аналогичных протоколов. В нем реализована логика упорядочения и обеспечения надежности (например, повторная передача удаленных данных), как в надежных протоколах, например TCP.

Подробное описание протокола TLS приведено в главе 3 руководства пользователя NetX Secure TLS, поэтому в этом документе основное внимание уделяется различиям между протоколами TLS и DTLS.

### <a name="dtls-record-header"></a>Заголовок записи DTLS

Любая допустимая запись DTLS должна иметь заголовок DTLS, как показано на рисунке 1. Заголовок такой же, как и в протоколе TLS, только в него добавлены два поля: 16-разрядное значение *эпохи* и 48-разрядный *порядковый номер*, описанные ниже.

![Схема заголовка записи DTLS.](media/image2.png)

**Рисунок 1. Заголовок записи DTLS**

Ниже приведены определения полей заголовка записи TLS.

| Поле заголовка TLS | Назначение  |
| ---------------- | --------- |
| **8 разрядов: тип сообщения** | Это поле содержит тип отправляемой записи DTLS. Допустимые типы:<br />- ChangeCipherSpec: 0x14;<br />- Alert: 0x15;<br />- Handshake: 0x16;<br />- данные приложения: 0x17.<br /> |
| **16 разрядов: версия протокола** | Это поле содержит версию протокола DTLS. Допустимы следующие значения:<br />- DTLS 1.1: 0xFEFD |
|  **16 разрядов: эпоха** |  Это поле содержит "эпоху" DTLS. Это счетчик, который увеличивается при каждом изменении состояния шифрования (например, при создании новых ключей сеанса).  |
|  **48 разрядов: порядковый номер** |  Это поле содержит порядковый номер, который определяет данную запись. Он используется протоколом DTLS для упорядочения записей и проверки необходимости повторной передачи. |
|  **16 разрядов: длина в битах** |  Это поле содержит длину данных, инкапсулированных в запись DTLS.  |

### <a name="dtls-handshake-record-header"></a>Заголовок записи подтверждения DTLS

Любая допустимая запись подтверждения DTLS должна содержать заголовок подтверждения DTLS, как показано на рисунке 2.

![Схема заголовка записи подтверждения DTLS.](media/image3.png)

**Рисунок 2. Заголовок записи подтверждения DTLS**

Ниже приведены определения полей заголовка записи подтверждения DTLS.

| Поле заголовка TLS | Назначение  |
| ---------------- | ------------------------------------------------ |
| **8 разрядов: тип сообщения** | Это поле содержит тип отправляемой записи DTLS. Допустимые типы:<br />- ChangeCipherSpec: 0x14;<br />- Alert: 0x15;<br />- Handshake: 0x16;<br />- данные приложения: 0x17. |
|  **16 разрядов: эпоха** | Это поле содержит "эпоху" DTLS. Это счетчик, который увеличивается при каждом изменении состояния шифрования (например, при создании новых ключей сеанса). |
|  **48 разрядов: порядковый номер** | Это поле содержит порядковый номер, который определяет данную запись. Он используется протоколом DTLS для упорядочения записей и проверки необходимости повторной передачи. |
|  **16 разрядов: версия протокола** | Это поле содержит версию протокола DTLS. Допустимы следующие значения:<br />- DTLS 1.1: 0xFEFD |
| **16 разрядов: длина в битах** | Это поле содержит длину данных, инкапсулированных в запись DTLS. |
| **8 разрядов: тип подтверждения** | Это поле содержит тип сообщения подтверждения. Допустимы следующие значения:<br />- HelloRequest: 0x00;<br />- ClientHello: 0x01;<br />- ServerHello: 0x02;<br />- Certificate: 0x0B;<br />- ServerKeyExchange: 0x0C;<br />- CertificateRequest: 0x0D;<br />- ServerHelloDone: 0x0E;<br />- CertificateVerify: 0x0F;<br />- ClientKeyExchange: 0x10;<br />- Finished: 0x14; |
| **24 разряда: длина** | Это поле содержит длину данных сообщения подтверждения. |
| **16 разрядов: порядковый номер** | Это поле содержит порядковый номер. |

### <a name="the-dtls-handshake-and-dtls-session"></a>Подтверждение DTLS и сеанс DTLS

Типичное подтверждение DTLS показано на рисунке 3. Оно почти очень похоже на типичное подтверждение TLS с одним важным отличием — при первой отправке сообщения ClientHello сервер отвечает новым сообщением DTLS, *HelloVerifyRequest*, которое содержит файл cookie. Клиент DTLS должен ответить вторым сообщением ClientHello, содержащим этот файл cookie, прежде чем можно будет продолжить подтверждение. Этот механизм был добавлен в протокол DTLS для предотвращения атак типа "отказ в обслуживании", так как протокол UDP не зависит от подключения (для протокола TCP требуется выделенное подключение или порт, поэтому протокол TLS не подвержен данной проблеме).

Подтверждение DTLS начинается, когда клиент отправляет сообщение *ClientHello* на сервер DTLS, указывая необходимость начать сеанс DTLS. Это сообщение содержит сведения о шифровании, которое клиент предпочитает использовать для сеанса, а также данные, используемые для создания ключей сеанса позже при подтверждении. Пока не созданы ключи сеанса, все сообщения в подтверждении DTLS не шифруются. Как упоминалось выше, сервер DTLS может отправить сообщение HelloVerifyRequest в ответ на ClientHello, вынуждая клиент ответить вторым, обновленным сообщением ClientHello.

После получения второго сообщения ClientHello сервер DTLS проверит файл cookie и, если он правильный, ответит сообщением ServerHello, указывающим выбранные параметры шифрования, предоставленные клиентом. За сообщением ServerHello следует сообщение Certificate, в котором сервер предоставляет цифровой сертификат для проверки подлинности клиента (если используется проверка X.509). Наконец, сервер отправляет сообщение ServerHelloDone, указывающее, что отправлены все сообщения. Сервер может дополнительно отправлять и другие сообщения после сообщения ServerHello, а в некоторых случаях он может не отправлять сообщение Certificate (например, если используются общие ключи), поэтому потребуется сообщение ServerHelloDone.

После того как клиент получит все сообщения сервера, у него будет достаточно сведений для создания ключей сеанса. Для этого протокол TLS или DTLS создает общий фрагмент случайных данных, называемый *предварительной главной копией секрета*, который имеет фиксированный размер и используется в качестве начального значения для создания всех необходимых ключей после включения шифрования. Предварительная главная копия секрета шифруется с помощью алгоритма с открытым ключом (например, RSA), указанного в сообщениях Hello (дополнительные сведения об алгоритмах с открытым ключом см. ниже), и открытого ключа, предоставленного сервером в его сертификате. Необязательная функция TLS или DTLS, называемая общими ключами (PSK), включает в себя комплекты шифров, которые не используют сертификат, а вместо этого используют значение секрета, которое передается между узлами (как правило, путем физического перемещения или другого безопасного метода). Если использование PSK включено, то для создания предварительной главной копии секрета используется общий секретный ключ. Ознакомьтесь с информацией об общих ключах в разделе "Способы проверки подлинности" ниже.

При обычном подтверждении TLS или DTLS зашифрованная предварительная главная копия секрета передается на сервер в сообщении ClientKeyExchange. При получении сообщения ClientKeyExchange сервер расшифровывает предварительную главную копию секрета с помощью своего закрытого ключа и продолжает создавать ключи сеанса одновременно с клиентом DTLS.

После создания ключей сеанса все последующие сообщения могут быть зашифрованы с помощью алгоритма с закрытым ключом (например, AES), выбранного в сообщениях Hello. Одно завершающее незашифрованное сообщение, именуемое ChangeCipherSpec, отправляет как клиент, так и сервер, чтобы указать, что все последующие сообщения будут зашифрованы.

Первое зашифрованное сообщение, отправленное и клиентом, и сервером, также является завершающим сообщением подтверждения TLS, именуемым Finished. Это сообщение содержит хэш всех полученных и отправленных сообщений подтверждения. Этот хэш используется, чтобы проверить, что ни одно из сообщений в подтверждении не было изменено или повреждено (что может указывать на нарушение безопасности).

После получения сообщений Finished и проверки хэшей подтверждения начинается сеанс TLS или DTLS. Приложение начинает отправку и получение данных. Все данные, отправляемые любой из сторон во время сеанса TLS или DTLS, сначала хэшируются с помощью хэш-алгоритма, выбранного в сообщениях Hello (для обеспечения целостности сообщений), и шифруются с помощью выбранного алгоритма с закрытым ключом и созданных ключей сеанса.

Наконец, сеанс TLS иил DTLS может быть успешно завершен только в том случае, если это действие выбрал клиент или сервер. Усеченный сеанс считается нарушением безопасности, так как злоумышленник может попытаться предотвратить получение всех данных. Поэтому, когда одна из сторон желает завершить сеанс, передается специальное уведомление, которое называется оповещением CloseNotify. Как клиент, так и сервер должны отправить и обработать оповещение CloseNotify, чтобы успешно завершить сеанс.

![Схема типичного сеанса подтверждения DTLS.](media/image4.png)

**Рисунок 3. Типичное подтверждение DTLS**

### <a name="initialization"></a>Инициализация

Прежде чем использовать NetX Secure DTLS, необходимо инициализировать стек NetX или NetX Duo. Сведения о том, как правильно инициализировать стек TCP/IP для операций UDP, см. в руководстве пользователя NetX или NetX Duo.

После инициализации NetX UDP можно включить протокол DTLS. На внутреннем уровне передача всего сетевого трафика и обработка DTLS выполняется стеком NetX или NetX Duo без необходимости вмешательства пользователя. Однако протокол DTLS накладывает определенные требования, которые должны выполняться отдельно от базового сетевого стека. Для операций клиента DTLS эти параметры присваиваются блоку управления DTLS с именем ***NX_SECURE_DTLS_SESSION** _. Для операций сервера DTLS блок управления называется _ *_NX_SECURE_DTLS_SERVER_** и содержит инфраструктуру, необходимую для работы с несколькими сеансами DTLS через один UDP-порт. Обратите внимание, что это отличается от протокола TLS, в котором каждый сеанс TLS привязывается к отдельному TCP-порту.

В приложении можно включить два режима DTLS, сервер или клиент (но только один режим на сокет NetX). Каждый из режимов имеет собственные требования. Они описаны ниже.

### <a name="initialization--dtls-server"></a>Инициализация: сервер DTLS

Режим NetX Secure DTLS Server отличается от режима сервера TLS, так как в качестве базового сетевого транспортного протокола используется UDP. При использовании протокола TCP порт привязывается к одному удаленному узлу на время сеанса TLS. В протоколе UDP не сохраняются сведения о состоянии удаленного узла, поэтому все запросы DTLS от разных узлов будут приниматься на один и тот же интерфейс UDP. Поэтому протокол DTLS должен обрабатывать состояние сеанса, а не полагаться на сокет, как в случае с протоколами TLS и TCP. По этой причине блок управления сервером DTLS (NX_SECURE_DTLS_SERVER) поддерживает сопоставление сведений об удаленном узле (IP-адрес и порт) с сеансами DTLS. Все входящие данные на сокете UDP, назначенном серверу DTLS, будут сопоставляться с существующим или новым сеансом DTLS, в зависимости от удаленного узла. По этой причине, помимо параметров клиента TLS и DTLS, при создании сервера DTLS требуется указать ряд дополнительных параметров.

В дополнение к блоку управления сервером DTLS, комплектам шифров TLS и области временных данных шифров или буферу метаданных, серверам DTLS требуется буфер для обслуживания сеансов DTLS и буфер для повторной сборки пакетов, используемый для расшифровки входящих записей DTLS.

Помимо буферов сеансов, серверам DTLS требуется *цифровой сертификат*— документ, используемый для идентификации сервера TLS для подключающегося клиента TLS, а также сертификаты, соответствующие *закрытому ключу* (обычно для алгоритма шифрования RSA). Стандарт X.509 Международного союза электросвязи определяет формат сертификата, используемого протоколом TLS или DTLS, и существует множество служебных программ для создания цифровых сертификатов X.509.

Для NetX Secure DTLS сертификат X.509 должен быть зашифрован в двоичном формате Distinguished Encoding Rules (DER) ASN.1. DER — это стандартный сетевой двоичный формат TLS для сертификатов.

Закрытый ключ, связанный с предоставленным сертификатом, должен быть зашифрован в формате DER с открытым ключом (PKCS) № 1. Закрытый ключ используется только на устройстве и никогда не передается по сети. Обеспечьте безопасность закрытых ключей, так как они обеспечивают защиту при обмене данными по протоколу TLS или DTLS.

Чтобы инициализировать сертификат сервера DTLS, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, и (необязательно) данные закрытого ключа RSA, зашифрованные в формате DER с открытым ключом (PKCS) № 1, с помощью службы ***nx_secure_x509_certificate_intialize***, которая заполняет структуру **NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.

После инициализации сертификата сервера его необходимо добавить в блок управления TLS с помощью службы ***nx_secure_dtls_server_local_certificate_add***.

После добавления сертификата сервера в блок управления сервером DTLS этот сервер можно использовать для безопасного обмена данными по протоколу DTLS (см. пример выше).

### <a name="initialization--dtls-client"></a>Инициализация: клиент DTLS

Режим NetX Secure DTLS Client прост в работе по сравнению с сервером DTLS, так как в нем используется только одно исходящее подключение к удаленному узлу через сокет UDP.

Для настройки клиента DTLS требуется *хранилище доверенных сертификатов*, которое представляет собой коллекцию цифровых сертификатов в кодировке X.509 из доверенных центров сертификации (ЦС). Предполагается, что эти сертификаты являются доверенными для протокола DTLS. Они служат базой для проверки подлинности сертификатов, предоставляемых сущностями сервера DTLS клиентскому приложению NetX Secure DTLS.

Сертификат доверенного ЦС может быть либо *самозаверяющим*, либо подписанным другим центром сертификации. В последнем случае сертификат называется сертификатом *промежуточного ЦС* (ICA). В типичном приложении TLS или DTLS сервер предоставляет сертификаты ICA вместе с сертификатом сервера, но единственным требованием для успешной проверки подлинности является то, что цепочка издателей (сертификатов, используемых для подписи других сертификатов) должна отслеживаться от сертификата сервера до сертификата доверенного ЦС в хранилище доверенных сертификатов. Эта цепочка называется *цепочкой доверия* или *цепочкой сертификатов*.

Чтобы инициализировать сертификат доверенного ЦС или сертификат ICA, приложение должно предоставить указатель на буфер, содержащий сертификат X.509, зашифрованный в формате DER, с помощью службы ***nx_secure_x509_certificate_intialize** _, которая заполняет структуру _ *NX_SECURE_X509_CERT** соответствующими данными сертификата для протокола TLS.

Клиенту DTLS также нужно пространство, выделяемое для входящего сертификата сервера (при условии, что не используется режим общего ключа), и буфер для сборки пакетов в записи DTLS, предназначенные для расшифровки. Эти буферы передаются в качестве параметров в службу ***nx_secure_dtls_session_create*** (дополнительные сведения см. в справочнике по API).

После этого доверенные сертификаты, которые были инициализированы, добавляются в блок управления сеансом DTLS с помощью службы ***nx_secure_dtls_session_trusted_certificate_add***. Сбой при добавлении сертификата приведет к сбою сеанса клиента DTLS, так как протокол DTLS не сможет проверить подлинность удаленных узлов сервера.

После создания хранилища доверенных сертификатов можно будет использовать сеанс для безопасного подключения клиента TLS.

### <a name="application-interface-calls"></a>Вызовы интерфейса приложения

Приложения NetX Secure DTLS обычно будут выполнять вызовы функций из потоков приложения, работающих в ОСРВ ThreadX. В некоторых случаях инициализация, особенно для базовых протоколов сетевого взаимодействия (например, UDP и IP), может быть вызвана из ***tx_application_define*** . Дополнительные сведения об инициализации сетевого взаимодействия см. в руководстве пользователя NetX или NetX Duo.

Протокол DTLS активно использует процедуры шифрования, которые являются ресурсоемкими операциями. Как правило, эти операции будут выполняться в контексте вызывающего потока.

### <a name="dtls-session-start"></a>Начало сеанса DTLS

Для работы протокола DTLS требуется базовый сетевой протокол транспортного уровня. Обычно используется протокол TCP. Чтобы установить сеанс NetX Secure TLS, необходимо создать **NX_UDP_SOCKET** и передать его в службу **_NX_SECURE_DTLS_CLIENT_SESSION_START_** для клиентов DTLS.

Серверы DTLS работают иначе. Сокет UDP, используемый для входящих запросов клиентов DTLS, содержится в блоке управления NX_SECURE_DTLS_SERVER и инициализируется в вызове службы ***nx_secure_dtls_server_create** _, которая принимает локальный UDP-порт в качестве параметра. Затем служба _*_nx_secure_dtls_server_start_*_ используется для запуска сервера DTLS для обработки входящих запросов. Все входящие запросы обрабатываются в подпрограммах обратного вызова (одна для подключений и одна для получения уведомлений), предоставленных для _nx_secure_dtls_server_create*. Приложение обрабатывает запуск сеанса DTLS при получении уведомления о подключении (обратный вызов уведомления о подключении выполняет DTLS) путем вызова ***nx_secure_dtls_server_session_start**_. Приложение также должно обрабатывать входящие данные при выполнении обратного вызова для уведомления о получении (который следует после завершения подтверждения DTLS), вызывая службу _*_nx_secure_dtls_session_receive_**. Подробные сведения об этом приведены в примере выше, а также в справочнике по API для каждой из перечисленных ранее служб.

### <a name="dtls-packet-allocation"></a>Выделение пакетов DTLS

NetX Secure DTLS использует ту же структуру пакетов, что и NetX TCP или NetX Duo TCP (***NX_PACKET** _), за исключением того, что вместо службы _*_nx_packet_allocate_*_ необходимо вызвать службу _ *_nx_secure_dtls_packet_allocate_**, чтобы правильно выделить пространство для заголовка DTLS.

### <a name="dtls-session-send"></a>Отправка данных в сеансе DTLS

После начала сеанса TLS приложение может отправить данные с помощью службы ***nx_secure_dtls_session_send***. Служба send работает как служба ***nx_udp_socket_send** _. Она принимает структуру данных _ *_NX_PACKET_**, содержащую отправляемые данные, целевой IP-адрес и целевой UDP-порт.

> [!IMPORTANT]
> При отправке данных с помощью службы nx_secure_dtls_session_send важно использовать те же IP-адрес и порт, которые использовались для установления сеанса DTLS, если не существует механизма для динамического перемещения сеанса на новый адрес и UDP-порт (что не распространено).

Все данные, передаваемые по протоколу DTLS, перед отправкой шифруются с помощью стека NX Secure DTLS и настроенных процедур шифрования.

### <a name="dtls-session-receive"></a>Получение данных в сеансе DTLS

После начала сеанса DTLS приложение может начать получение данных с помощью службы ***nx_secure_dtls_session_send** _. Как и в случае отправки данных в сеансе DTLS, эта служба работает аналогично службе _*_nx_tcp_socket_receive_**, за исключением того, что входящие данные расшифровываются и проверяются стеком DTLS перед возвращением в структуру пакета.

### <a name="tls-session-close"></a>Закрытие сеанса TLS

По завершении сеанса DTLS и клиент DTLS, и сервер DTLS должны отправить оповещение CloseNotify другой стороне, чтобы окончательно завершить сеанс. Обе стороны должны получить и обработать это оповещение, чтобы успешно завершить сеанс.

Если удаленный узел отправляет оповещение CloseNotify, все вызовы службы ***nx_secure_dtls_session_receive** _ обрабатывают его, отправляют соответствующее оповещение обратно на удаленный узел и возвращают значение _*_NX_SECURE_TLS_SESSION_CLOSED_**. После закрытия сеанса дальнейшие попытки отправить или получить данные в этом сеансе DTLS завершатся ошибкой.

Если приложению нужно закрыть сеанс TLS, необходимо вызвать службу ***nx_secure_dtls_session_end** _. Эта служба отправит оповещение CloseNotify и обработает ответное оповещение CloseNotify. Если ответ не получен, будет возвращено значение ошибки _ *_NX_SECURE_TLS_SESSION_CLOSE_FAIL_**, указывающее на то, что сеанс DTLS не был корректно завершен, возможно из-за нарушения безопасности.

### <a name="tlsdtls-alerts"></a>Оповещения TLS и DTLS

Протоколы TLS и DTLS предназначены для обеспечения максимальной безопасности, поэтому любое аномальное поведение в протоколе считается потенциальным нарушением безопасности. По этой причине все ошибки, возникающие при обработке, шифровании или расшифровке сообщений, считаются неустранимыми ошибками, которые немедленно завершают подтверждение или сеанс.

Хотя обработка ошибок в локальном приложении относительно проста, удаленный узел должен быть уведомлен о том, что произошла ошибка, чтобы правильно обработать ситуацию и предотвратить возможные дальнейшие нарушения безопасности. По этой причине при любой ошибке протокол TLS или DTLS отправляет сообщение *Alert* на удаленный узел.

Сообщения Alert обрабатываются так же, как и любые другие сообщения TLS и DTLS, и шифруются во время сеанса, чтобы предотвратить сбор информации злоумышленником из указанного типа оповещения. Во время подтверждения отправляются ограниченные оповещения, чтобы уменьшить объем сведений, которые могут быть получены потенциальным злоумышленником.

Оповещение CloseNotify, используемое для закрытия сеанса TLS или DTLS, является единственным оповещением не об неустранимом сбое. Хотя оно считается оповещением и отправляется в виде сообщения Alert, отличие CloseNotify от других оповещений состоит в том, что оно не указывает на ошибку.

### <a name="tlsdtls-session-renegotiation-and-resumption"></a>Повторное согласование и возобновление сеанса TLS или DTLS

Протокол TLS поддерживает понятие "повторное согласование", которое представляет собой просто согласование параметров сеанса TLS в контексте существующего сеанса TLS.

*Возобновление* сеанса TLS не следует путать с *повторным согласованием* сеанса, несмотря на некоторое сходство. *Повторное согласование* сеанса включает в себя запуск нового подтверждения в существующем сеансе TLS, тогда как *возобновление* сеанса является необязательной функцией, включающей в себя перезапуск сеанса TLS без полного подтверждения TLS.

NX Secure DTLS обрабатывает входящие запросы на повторное согласование от удаленных узлов. NX Secure DTLS **не** поддерживает возобновление сеансов. Более подробное описание этих функций можно найти в главе 3 руководства пользователя NetX Secure TLS.

### <a name="protocol-layering"></a>Уровень протокола

Протокол TLS (и, следовательно, DTLS) располагается между транспортным уровнем (например, протоколы TCP или UDP) и прикладным уровнем. Протокол TLS иногда считают протоколом транспортного уровня (отсюда и его название — TLS, *Transport Layer* Security (безопасность транспортного уровня)), но так как он действует как приложение по отношению к базовым сетевым протоколам, иногда его относят к прикладному уровню.

Для протокола TLS требуется протокол транспортного уровня, поддерживающий доставку по порядку и без потерь, например протокол TCP. В соответствии с этим требованием протокол TLS не может выполняться на основе протокола UDP, так как UDP не гарантирует доставку датаграмм. Для приложений, которым требуется безопасность TLS по протоколу передачи датаграмм, например UDP, используется протокол *DTLS*, который является модифицированной версией протокола TLS.

![Схема уровней протокола TLS.](media/image6.png)

**Рисунок 4. Уровни протоколов TCP/IP, UDP, TLS и DTLS**

## <a name="network-communications-security-and-encryption"></a>Безопасность и шифрование сетевых подключений

Обеспечение безопасности взаимодействия через общедоступные сети и Интернет является важнейшей темой, которой посвящено огромное количество книг, статей и решений. Эта тема является немыслимо сложной, но ее можно упростить до следующей идеи: нужно отправлять информацию по сети так, чтобы только указанный адресат мог получить доступ к этой информации или изменить ее. Эта идея порождает три важных понятия: секретность, целостность и проверка подлинности. Протокол TLS или DTLS предоставляет решения для всех этих трех понятий.

Шифрование используется в протоколах TLS и DTLS различными способами для обеспечения секретности, целостности и проверки подлинности. Шифрование должно применяться к протоколу TLS или DTLS при создании экземпляра сеанса или сервера, так как протокол TLS предоставляет гибкую платформу для использования шифрования, а не само шифрование. NetX Secure DTLS предоставляет необходимые для большинства приложений процедуры шифрования, поэтому вам не нужно беспокоиться о поиске соответствующих средств шифрования.

Более подробное описание этих тем можно найти в главе 3 руководства пользователя NetX Secure TLS.

## <a name="tls-and-dtls-extensions"></a>Расширения TLS и DTLS

Протокол TLS (а, следовательно, и протокол DTLS) предоставляет ряд расширений, которые обеспечивают дополнительные функциональные возможности для определенных приложений. Эти расширения обычно передаются как часть сообщений ClientHello или ServerHello, указывая удаленному узлу намерение использовать расширение или предоставляя дополнительные сведения для установления безопасного сеанса TLS.

NetX Secure DTLS поддерживает все расширения, используемые в NetX Secure TLS, а полное описание этих расширений можно найти в главе 3 руководства пользователя NetX Secure TLS.

## <a name="authentication-methods"></a>Способы проверки подлинности

Протоколы TLS и DTLS предоставляют платформу для установления безопасного подключения между двумя устройствами по незащищенной сети, но часть проблемы заключается в том, чтобы определить подлинность устройства на другом конце этого подключения. Без механизма проверки подлинности удостоверений удаленных узлов злоумышленник легко сможет предоставить фальшивое доверенное устройство.

Изначально может показаться, что использование IP-адресов, аппаратных MAC-адресов или DNS обеспечивает относительно высокий уровень надежности для идентификации узлов в сети, но, учитывая характер технологии TCP/IP и простоту подмены адресов и повреждения записей DNS (например, с помощью подделки записей кэша DNS), для протокола TLS требуется дополнительный уровень защиты от поддельных удостоверений.

Существует ряд механизмов, которые могут обеспечить этот дополнительный уровень проверки подлинности для TLS, но наиболее распространенным является *цифровой сертификат*. К другим механизмам относятся схемы на основе общих ключей (PSK) и паролей.

### <a name="digital-cerificates"></a>Цифровые сертификаты

Цифровые сертификаты — наиболее распространенный способ проверки подлинности удаленного узла в протоколе TLS. По сути, цифровой сертификат — это документ с особым форматированием, который предоставляет идентификационные данные устройства в компьютерной сети.

В протоколе TLS обычно используется формат X.509 — стандарт, разработанный Международным союзом электросвязи, хотя могут использоваться и другие форматы сертификатов, если узлы TLS могут согласовать используемый формат. Стандарт X.509 определяет точный формат сертификатов и различные кодировки, которые можно использовать для создания цифрового документа. Большинство сертификатов X.509, используемых с протоколом TLS, кодируется с использованием разновидности ASN.1 — еще одного стандарта связи. В ASN.1 доступны различные цифровые кодировки, но чаще всего для кодирования сертификатов TLS применяется стандарт DER (Distinguished Encoding Rules). DER — это упрощенное подмножество стандарта BER (Basic Encoding Rules) ASN.1, которое предназначено обеспечить однозначность и упростить анализ. В сети сертификаты TLS обычно кодируются в двоичном формате DER, и именно в этом формате NetX Secure ожидает сертификаты X.509.

Хотя двоичные сертификаты в формате DER используются в фактическом протоколе TLS, они могут создаваться и храниться в разных кодировках с такими расширениями файла, как PEM, CRT и P12. Различные варианты используются приложениями разных производителей, но в целом их можно преобразовать в формат DER с помощью широко доступных средств.

Наиболее распространенной альтернативной кодировкой сертификатов является PEM. Формат PEM (Privacy-Enhanced Mail) представляет собой версию кодировки DER в формате Base64, которая часто используется, так как это кодирование позволяет получить печатный текст, который можно легко отправить с помощью электронной почты или веб-протоколов.

Создание сертификата для вашего приложения NetX Secure обычно выходит за рамки данного руководства, но программа командной строки OpenSSL ([www.openssl.org](http://www.openssl.org)) широко доступна и может выполнять взаимное преобразование большинства форматов.

В зависимости от приложения вы можете создавать собственные сертификаты, получать сертификаты от изготовителя или правительственной организации или приобретать сертификаты у коммерческого центра сертификации.

Чтобы использовать цифровой сертификат в приложении NetX Secure, необходимо сначала преобразовать этот сертификат в двоичный формат DER и, при необходимости, преобразовать в двоичный формат соответствующий закрытый ключ (например, "закрытый показатель" для RSA), обычно это ключ RSA в кодировке DER и формате PKCS № 1. После завершения преобразования необходимо загрузить сертификат и закрытый ключ на устройство. Возможные варианты включают в себя использование файловой системы флэш-памяти или создание массива C на основе данных (с помощью такого инструмента, как xxd в Linux), а также компиляцию сертификата и ключа в приложении в качестве постоянных данных.

После загрузки сертификата на устройство можно использовать API DTLS, чтобы связать этот сертификат с сеансом или сервером DTLS.

Дополнительные сведения и примеры использования сертификатов X.509 с NetX Secure DTLS приведены в разделе "Импорт сертификатов X.509 в NetX Secure" руководства пользователя NetX Secure TLS.

Ознакомьтесь с дополнительными сведениями о приведенных ниже службах DTLS в справочнике по API:

- nx_secure_x509_certificate_initialize
- nx_secure_dtls_session_local_certificate_add
- nx_secure_dtls_server_local_certificate_add
- nx_secure_dtls_session_local_certificate_remove
- nx_secure_dtls_server_local_certificate_remove
- nx_secure_dtls_session_trusted_certificate_add
- nx_secure_dtls_server_trusted_certificate_add
- nx_secure_dtls_session_trusted_certificate_remove
- nx_secure_dtls_server_trusted_certificate_remove

### <a name="tls-client-certificate-specifics"></a>Особенности сертификата клиента TLS

Для реализаций клиента DTLS обычно не требуется загрузка локального сертификата на устройство. Локальный сертификат — это сертификат, идентифицирующий локальное устройство. В частности, локальный сертификат предоставляет идентификационные данные устройства, на которое загружено приложение TLS или DTLS. Исключением является применение проверки подлинности на основе сертификата клиента, но она гораздо менее распространена.

Клиенту DTLS требуется загрузка по крайней мере одного доверенного сертификата (при необходимости может быть загружено больше) и выделение пространства для удаленного сертификата. Доверенный сертификат — это сертификат, который предоставляет основу для доверия и проверки подлинности удаленного устройства напрямую либо посредством инфраструктуры открытых ключей (PKI). Корень цепочки доверия обычно называется центром сертификации или сертификатом ЦС. Удаленный сертификат означает сертификат, отправленный удаленным узлом во время подтверждения TLS. Он предоставляет удостоверение этого удаленного узла и проходит проверку подлинности, при которой это удостоверение сравнивается с доверенным сертификатом на локальном устройстве.

Дополнительные сведения о добавлении доверенных сертификатов и выделении пространства для удаленных сертификатов см. в справочнике по API TLS для служб nx_secure_dtls_session_create и nx_secure_dtls_session_trusted_certificate_add.

### <a name="tlsdtls-server-certificate-specifics"></a>Особенности сертификата сервера TLS или DTLS

Для реализации сервера DTLS обычно не требуется загрузка доверенных сертификатов на устройство или выделение удаленных сертификатов. Исключением является применение проверки подлинности на основе сертификата клиента.

Сервер TLS требует загрузки локального сертификата (или удостоверения), чтобы сервер мог предоставить его удаленному клиенту во время подтверждения TLS, чтобы клиент мог проверить подлинность сервера.

Дополнительные сведения о загрузке локальных сертификатов для использования серверными приложениями NetX TLS см. в справочнике по API для служб nx_secure_dtls_server_local_certificate_add и nx_secure_dtls_server_local_certificate_remove.


### <a name="pre-shared-keys-psk"></a>Общие ключи (PSK)

Альтернативным механизмом идентификации для проверки подлинности в протоколе TLS является понятие общих ключей (PSK). Использование комплекта шифров PSK устраняет необходимость выполнять операции шифрования с открытым ключом, требующие интенсивного использования процессора, что является явным преимуществом для встроенных устройств с ограниченными ресурсами. PSK заменяет сертификат в подтверждении TLS и DTLS и используется вместо зашифрованной предварительной главной копии секрета для создания ключа сеанса TLS или DTLS.

Комплекты шифров PSK ограничены в том смысле, что общий секрет должен находиться на обоих устройствах, прежде чем можно будет установить сеанс TLS или DTLS. Это означает, что этот секрет должен быть загружен на устройства каким-либо альтернативным безопасным способом, а не через подключение по протоколу TLS для PSK. PSK можно обновить через подключение TLS для PSK, но устройство должно быть запущено с PSK, загруженным с помощью какого-либо другого механизма. Например, ключи PSK можно загрузить на устройства датчика и его шлюза на фабрике перед отправкой или использовать стандартное подключение TLS (с сертификатом) для загрузки PSK.

Существуют два варианта комплектов шифров PSK, они описаны в документе RFC 4279. В первом применяются ключи RSA или Диффи-Хелмана, которые используются точно так же, как и открытые ключи, передаваемые в сертификате при стандартном подтверждении TLS. Во втором варианте, который чаще используется в среде с ограниченными ресурсами, применяется PSK, который используется для непосредственного создания ключей сеанса (например, для использования AES), что позволяет избежать выполнения ресурсоемких операций RSA или Диффи-Хелмана.

NetX Secure поддерживает второй вариант комплектов шифров PSK, что позволяет избавить приложения от всего кода шифрования с открытым ключом и проблем с использованием памяти. Сам по себе PSK не является ключом AES, а, скорее, является паролем, с помощью которого создаются фактические ключи. Существует несколько ограничений для значения PSK, хотя более длинные значения обеспечивают большую безопасность (то же относится и к паролям).

Чтобы использовать PSK в приложении NetX Secure, необходимо сначала определить глобальный макрос **NX_SECURE_ENABLE_PSK_CIPHERSUITES**. Обычно это делается с помощью параметров компилятора, но определение можно также поместить в файл заголовка nx_secure_tls.h. После определения макроса поддержка комплекта шифров PSK будет скомпилирована в приложение NetX Secure DTLS.

После включения поддержки PSK можно будет использовать API DTLS, чтобы настроить ключи PSK для приложения. Для каждого PSK потребуется значение PSK (фактический секретный "ключ", который должен храниться в безопасном месте), значение "удостоверения", используемое для идентификации конкретного PSK, и "указание удостоверения", которое используется сервером TLS для выбора определенного значения PSK.

PSK может быть любым двоичным значением, так как он никогда не передается через сетевое подключение. Значение PSK может содержать до 64 байт.

Удостоверение и указание должны представлять собой печатные строки символов в формате UTF-8. Значения удостоверения и указания могут содержать до 128 байт.

Удостоверение и PSK образуют уникальную пару, которая загружается на все устройства в сети, которые должны взаимодействовать друг с другом.

"Указание" в основном используется, чтобы определить конкретные профили приложений для группирования ключей PSK по функциям или службам. Эти значения должны быть согласованы заранее, и они зависят от приложения. Например, серверное приложение командной строки OpenSSL (использующее PSK) применяет строку по умолчанию "Client_identity", которая должна быть предоставлена клиентом TLS для продолжения подтверждения TLS.

Дополнительные сведения о ключах PSK см. в справочнике по API NetX Secure для служб nx_secure_dtls_psk_add и nx_secure_dtls_server_psk_add.

## <a name="importing-x509-certificates-into-netx-secure"></a>Импорт сертификатов X.509 в NetX Secure

Цифровые сертификаты необходимы для большинства подключений TLS в Интернете. Сертификаты обеспечивают метод проверки подлинности неизвестных ранее узлов через Интернет за счет использования доверенных посредников, которые обычно называются *центрами сертификации* (ЦА). Чтобы подключить устройство NetX Secure к коммерческой облачной службе (например, Amazon Web Services), необходимо будет импортировать сертификаты в свое приложение, загрузив их на устройство.

Наряду с сертификатами иногда может понадобиться *закрытый ключ*, связанный с вашим сертификатом. В некоторых приложениях (например, в клиенте TLS, если не используется проверка подлинности на основе сертификата клиента) будет достаточно только сертификата, но если сертификат используется для идентификации устройства, вам потребуется закрытый ключ. Закрытые ключи обычно создаются при создании сертификата и хранятся в отдельном файле, который часто шифруется и защищается паролем.

Подробное описание импорта сертификатов в приложения NetX Secure см. в главе 3 руководства пользователя NetX Secure TLS.

## <a name="client-certificate-authentication-in-netx-secure-tls"></a>Проверка подлинности на основе сертификата клиента в NetX Secure TLS

При использовании проверки подлинности на основе сертификата X.509 протокол TLS или DTLS требует, чтобы экземпляр сервера DTLS предоставил сертификат для идентификации, но по умолчанию экземпляру клиента DTLS не требуется предоставлять сертификат для проверки подлинности. Вместо этого используется другая разновидность проверки подлинности (например, сочетание имени пользователя и пароля). Это соответствует наиболее распространенному использованию протокола TLS в Интернете для веб-сайтов. Например, веб-сайт розничной торговли должен доказать потенциальному клиенту, использующему веб-браузер, что сервером является действительным, но пользователь будет использовать имя для входа и пароль для доступа к определенной учетной записи.

Однако вариант использования по умолчанию не всегда желателен, поэтому протоколы TLS и DTLS дополнительно позволяют экземпляру сервера DTLS запрашивать сертификат у удаленного клиента. Если эта функция включена, то во время подтверждения сервер DTLS отправляет сообщение CertificateRequest клиенту DTLS. Клиент должен отправить в ответ свой сертификат и сообщение CertificateVerify, которое содержит криптографический маркер, подтверждающий, что клиент владеет соответствующим закрытым ключом, связанным с этим сертификатом. Если проверка завершается сбоем или сертификат не связан с доверенным сертификатом на сервере, происходит сбой подтверждения TLS.

Существуют два отдельных варианта проверки подлинности на основе сертификата клиента в протоколе TLS, они рассматриваются в следующих разделах.

### <a name="client-certificate-authentication-for-dtls-clients"></a>Проверка подлинности на основе сертификата клиента для клиентов DTLS

Клиент DTLS может попытаться подключиться к серверу, который запрашивает сертификат для проверки подлинности клиента. В этом случае клиент должен предоставить сертификат серверу и подтвердить, что он владеет соответствующим закрытым ключом, иначе сервер завершит подтверждение DTLS.

В NetX Secure DTLS нет специальной конфигурации для поддержки этой функции, но приложению потребуется указать локальный сертификат для экземпляра клиента DTLS с помощью службы *nx_secure_tls_session_local_certificate_add*. Если приложение не предоставило сертификат, а удаленный сервер использует проверку подлинности на основе сертификата клиента и запрашивает сертификат, то подтверждение DTLS завершится сбоем. Для выполнения подтверждения DTLS сертификат, предоставленный сеансу DTLS службой *nx_secure_dtls_session_local_certificate_add*, должен быть распознан удаленным сервером.

### <a name="client-certificate-authentication-for-tls-servers"></a>Проверка подлинности на основе сертификата клиента для серверов TLS

В случае сервера DTLS проверка подлинности на основе сертификата клиента выполняется немного сложнее, чем в случае клиента DTLS, ввиду необязательного использования функции. В этом случае сервер TLS должен запросить сертификат у удаленного клиента TLS, обработать сообщение CertificateVerify, чтобы убедиться, что удаленный клиент владеет соответствующим закрытым ключом, а затем сервер должен убедиться, что сертификат, предоставленный клиентом, можно отследить до сертификата в хранилище локальных доверенных сертификатов.

В экземплярах сервера NetX Secure TLS проверкой подлинности на основе сертификата клиента управляют службы *nx_secure_dtls_server_x509_client_verify_configure* и *nx_secure_dtls_server_x509_client_verify_disable*.

Чтобы включить проверку подлинности на основе сертификата клиента, приложение должно вызвать службу *nx_secure_dtls_server_x509_client_verify_configure* для экземпляра сеанса сервера DTLS, прежде чем вызывать службу *nx_secure_dtls_server_start*. Для проверки необходимо выделить пространство для входящих сертификатов клиента, которые передаются в качестве параметра в службу *nx_secure_dtls_server_x509_client_verify_configure*. Обратите внимание на то, что буфер должен быть достаточно большим. Он должен вместить столько цепочек сертификатов максимального размера, предоставляемых клиентом, сколько может существовать *сеансов сервера DTLS*. Каждому сеансу сервера требуется пространство, выделяемое из одного предоставленного буфера. Убедитесь, что буфер достаточно большой. Если предоставленная цепочка сертификатов клиента окажется слишком велика, возникнет ошибка.

Если включена проверка подлинности на основе сертификата клиента, сервер DTLS запрашивает сертификат у удаленного клиента DTLS во время подтверждения DTLS. На сервере NetX Secure DTLS сертификат клиента проверяется с помощью хранилища доверенных сертификатов, созданных с помощью *nx_secure_dtls_server_trusted_certificate_add*, в соответствии с цепочкой издателей X.509. Удаленный клиент должен предоставить цепочку, которая связывает удостоверяющий сертификат с сертификатом в доверенном хранилище, иначе произойдет сбой подтверждения DTLS. Кроме того, если происходит сбой обработки сообщения CertificateVerify, то подтверждение DTLS также завершается ошибкой.

Методы сигнатур, используемые для метода CertificateVerify, являются фиксированными для протоколов TLS 1.0 и TLS 1.1 и задаются сервером TLS в протоколе TLS 1.2. Именно на основе этих методов реализован протокол NetX Secure DTLS. Для протокола DTLS 1.2 поддерживаются методы сигнатур, которые, как правило, соответствуют методам, передаваемым в таблице криптографических методов, но обычно это RSA с SHA-256 (ознакомьтесь с разделом "Шифрование в NetX Secure TLS", чтобы получить дополнительные сведения об инициализации TLS с помощью криптографических методов).

## <a name="cryptography-in-netx-secure-tls"></a>Шифрование в NetX Secure TLS

TLS определяет протокол, в котором может использоваться шифрование для защиты сетевого взаимодействия. Поэтому выбор фактического алгоритма шифрования, который может быть применен, не слишком ограничен для пользователей протокола TLS. Спецификация только требует реализовать один комплект шифров. В случае протокола TLS 1.2 это комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA, предписывающий использование RSA для операций с открытым ключом, AES — в режиме CBC с 128-разрядными ключами для шифрования сеансов и SHA-1 — для хэшей для проверки подлинности сообщений.

Так как протокол NetX Secure совместим с протоколом TLS 1.2, он обеспечивает обязательный комплект шифров TLS_RSA_WITH_AES_128_CBC_SHA по умолчанию, но, учитывая количество возможных реализаций для каждого из криптографических методов ввиду возможностей оборудования и других соображений, NetX Secure предоставляет универсальный криптографический API, позволяющий пользователю указать, какие криптографические методы использовать в протоколе TLS.

> [!NOTE]
> Механизм универсального криптографического API также позволяет пользователям реализовать собственные комплекты шифров, но это рекомендуется для опытных пользователей, уже работавших с комплектами шифров и расширениями TLS. Если вы заинтересованы в поддержке собственных комплектов шифров, обратитесь к своему представителю Express Logic.

Подробное описание настройки криптографических методов для DTLS см. в главе 3 руководства пользователя NetX Secure TLS. Для протоколов TLS и DTLS используются одинаковые процедуры.
